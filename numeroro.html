<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aureum Nebulae - Sacred Geometry</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020005;
            font-family: 'Segoe UI', sans-serif;
            color: #00f2ff;
            user-select: none;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 8px #00f2ff;
        }
        canvas { display: block; }
        
        /* Controles Táctiles Minimalistas */
        .touch-zone {
            position: fixed;
            bottom: 40px;
            width: 100px;
            height: 100px;
            background: rgba(0, 242, 255, 0.03);
            border: 1px solid rgba(0, 242, 255, 0.15);
            border-radius: 50%;
            z-index: 1000;
            transition: opacity 1s ease;
            opacity: 0; /* Por defecto ocultos */
            pointer-events: auto;
        }
        #joy-left { left: 30px; }
        #joy-right { right: 30px; }
        .knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 34px; height: 34px;
            margin: -17px;
            background: rgba(0, 242, 255, 0.2);
            border: 1px solid rgba(0, 242, 255, 0.4);
            border-radius: 50%;
            pointer-events: none;
        }
        
        #loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 2s ease;
            letter-spacing: 5px;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>

<div id="loading">INICIALIZANDO ÉTER FRACTAL...</div>

<div id="ui">
    <h1 style="margin:0; font-size: 1rem; font-weight: 200; letter-spacing: 4px;">AUREUM NEBULAE</h1>
    <div id="stats" style="font-size: 0.7rem; margin-top: 5px; opacity: 0.7;">
        SECTOR: <span id="pos-info">0, 0, 0</span><br>
        PARTÍCULAS: <span id="part-count">0</span><br>
        <span id="stereo-status" style="color: #ffcc00; font-weight: bold;"></span>
    </div>
</div>

<!-- Contenedores de Joysticks -->
<div id="joy-left" class="touch-zone"><div class="knob" id="knob-left"></div></div>
<div id="joy-right" class="touch-zone"><div class="knob" id="knob-right"></div></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    const GOLDEN_ANGLE = (3 - Math.sqrt(5)) * Math.PI;
    const SECTOR_SIZE = 600;
    const PARTICLES_PER_SYSTEM = 8000;
    
    let scene, camera, renderer, clock;
    let sectors = new Map();
    const keys = {};
    let rotation = { x: 0, y: 0, z: 0 };
    
    // Configuración Estereoscópica
    let isStereoMode = false;
    let eyeSeparation = 1.2; // Intensidad inicial del efecto 3D

    // Gestión Táctil e Inactividad
    let isTouchDevice = false;
    let lastUserActionTime = Date.now();
    const joyLeft = { active: false, x: 0, y: 0 };
    const joyRight = { active: false, x: 0, y: 0 };

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x010002);
        scene.fog = new THREE.FogExp2(0x010002, 0.0018);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 8000);
        camera.position.set(0, 0, 100);

        renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // Detectar si el dispositivo es táctil
        isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        
        if(isTouchDevice) {
            initTouchEvents();
        }

        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onResize);

        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => {
            const loading = document.getElementById('loading');
            if(loading) loading.remove();
        }, 2000);

        animate();
    }

    function updateStereoStatus() {
        const statusElement = document.getElementById('stereo-status');
        if (isStereoMode) {
            statusElement.innerText = `MODO ESTÉREO ACTIVO (CROSS-EYE) | PROFUNDIDAD: ${eyeSeparation.toFixed(1)}`;
        } else {
            statusElement.innerText = "";
        }
    }

    function onKeyDown(e) {
        keys[e.code] = true;
        lastUserActionTime = Date.now();
        
        // Tecla 3 para activar/desactivar Estereoscopía
        if (e.code === 'Digit3' || e.code === 'Numpad3') {
            isStereoMode = !isStereoMode;
            updateStereoStatus();
            onResize(); 
        }

        // Teclas 9 y 0 para ajustar la separación de ojos (Solo en modo estéreo)
        if (isStereoMode) {
            if (e.code === 'Digit9' || e.code === 'Numpad9') {
                eyeSeparation += 0.1;
                updateStereoStatus();
            }
            if (e.code === 'Digit0' || e.code === 'Numpad0') {
                eyeSeparation = Math.max(0.1, eyeSeparation - 0.1);
                updateStereoStatus();
            }
        }
    }

    function initTouchEvents() {
        const handleStart = (e, joy, knobId) => {
            e.preventDefault();
            joy.active = true;
            lastUserActionTime = Date.now();
            updateJoy(e.targetTouches[0], joy, knobId);
        };

        const handleMove = (e, joy, knobId) => {
            e.preventDefault();
            if(!joy.active) return;
            lastUserActionTime = Date.now();
            updateJoy(e.targetTouches[0], joy, knobId);
        };

        const handleEnd = (joy, knobId) => {
            joy.active = false;
            joy.x = 0; joy.y = 0;
            document.getElementById(knobId).style.transform = `translate(0px, 0px)`;
        };

        const updateJoy = (touch, joy, knobId) => {
            const zone = document.getElementById(knobId).parentElement;
            const rect = zone.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let dx = (touch.clientX - centerX) / (rect.width / 2);
            let dy = (touch.clientY - centerY) / (rect.height / 2);
            
            const limit = Math.sqrt(dx*dx + dy*dy);
            if(limit > 1) { dx /= limit; dy /= limit; }
            
            joy.x = dx; joy.y = dy;
            document.getElementById(knobId).style.transform = `translate(${dx * 30}px, ${dy * 30}px)`;
        };

        const leftZone = document.getElementById('joy-left');
        const rightZone = document.getElementById('joy-right');

        leftZone.addEventListener('touchstart', (e) => handleStart(e, joyLeft, 'knob-left'));
        leftZone.addEventListener('touchmove', (e) => handleMove(e, joyLeft, 'knob-left'));
        leftZone.addEventListener('touchend', () => handleEnd(joyLeft, 'knob-left'));

        rightZone.addEventListener('touchstart', (e) => handleStart(e, joyRight, 'knob-right'));
        rightZone.addEventListener('touchmove', (e) => handleMove(e, joyRight, 'knob-right'));
        rightZone.addEventListener('touchend', () => handleEnd(joyRight, 'knob-right'));
        
        // Mostrar al tocar cualquier parte
        window.addEventListener('touchstart', () => { lastUserActionTime = Date.now(); }, {passive: true});
    }

    class GoldenNebula {
        constructor(ix, iy, iz) {
            this.id = `${ix},${iy},${iz}`;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLES_PER_SYSTEM * 3);
            const colors = new Float32Array(PARTICLES_PER_SYSTEM * 3);
            const sizes = new Float32Array(PARTICLES_PER_SYSTEM);

            const seed = Math.abs(Math.sin(ix * 12.98 + iy * 78.23 + iz * 45.16) * 43758.54);
            const hueBase = (seed * 0.4) % 1;

            for (let i = 0; i < PARTICLES_PER_SYSTEM; i++) {
                const phi = Math.acos(1 - 2 * (i / PARTICLES_PER_SYSTEM));
                const theta = i * GOLDEN_ANGLE;
                const r = 150 * (0.2 + (seed % 0.8)) * Math.sqrt(i / PARTICLES_PER_SYSTEM) * 2;
                const petalMod = 1 + 0.3 * Math.sin(theta * (3 + Math.floor(seed * 5)));
                
                positions[i*3] = r * Math.sin(phi) * Math.cos(theta) * petalMod;
                positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta) * petalMod;
                positions[i*3+2] = r * Math.cos(phi) + (Math.sin(i * 0.01 + seed) * 20);

                const color = new THREE.Color().setHSL((hueBase + i * 0.00005) % 1, 1.0, 0.6);
                colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
                sizes[i] = Math.random() * 2.5 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            this.points = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 2, vertexColors: true, transparent: true, opacity: 0.8,
                blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true
            }));
            this.points.position.set(ix * SECTOR_SIZE, iy * SECTOR_SIZE, iz * SECTOR_SIZE);
            this.points.rotation.set(seed, seed * 2, seed * 0.5);
            scene.add(this.points);
        }
        update(time) {
            this.points.rotation.y += 0.0005;
            this.points.scale.setScalar(1 + Math.sin(time * 0.5) * 0.05);
        }
        dispose() {
            this.points.geometry.dispose();
            this.points.material.dispose();
            scene.remove(this.points);
        }
    }

    function updateSectors() {
        const cx = Math.round(camera.position.x / SECTOR_SIZE);
        const cy = Math.round(camera.position.y / SECTOR_SIZE);
        const cz = Math.round(camera.position.z / SECTOR_SIZE);
        const activeIds = new Set();

        for (let x = cx - 1; x <= cx + 1; x++) {
            for (let y = cy - 1; y <= cy + 1; y++) {
                for (let z = cz - 1; z <= cz + 1; z++) {
                    const id = `${x},${y},${z}`;
                    activeIds.add(id);
                    if (!sectors.has(id)) sectors.set(id, new GoldenNebula(x, y, z));
                }
            }
        }
        sectors.forEach((s, id) => { if(!activeIds.has(id)) { s.dispose(); sectors.delete(id); } });
        document.getElementById('pos-info').innerText = `${cx}, ${cy}, ${cz}`;
        document.getElementById('part-count').innerText = (sectors.size * PARTICLES_PER_SYSTEM).toLocaleString();
    }

    function onMouseMove(e) {
        if (document.pointerLockElement === renderer.domElement) {
            rotation.y -= e.movementX * 0.0015;
            rotation.x -= e.movementY * 0.0015;
            rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));
            lastUserActionTime = Date.now();
        }
    }

    function onResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        // Si es estéreo, el aspect ratio de la cámara es de media pantalla
        camera.aspect = (isStereoMode ? width / 2 : width) / height;
        camera.updateProjectionMatrix();
    }

    function handleInput(dt) {
        const moveMult = (keys['Space'] ? 500 : 160) * dt;
        const rotateMult = 2.2 * dt;

        // Mezclar Teclado + Joypads
        const moveFwd = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0) - (joyLeft.active ? joyLeft.y : 0);
        const moveSide = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0) + (joyLeft.active ? joyLeft.x : 0);
        const moveVert = (keys['KeyZ'] ? 1 : 0) - (keys['KeyX'] ? 1 : 0) - (joyRight.active ? joyRight.y : 0);
        const rotYaw = (keys['KeyE'] ? 1 : 0) - (keys['KeyQ'] ? 1 : 0) - (joyRight.active ? joyRight.x : 0);

        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

        camera.position.addScaledVector(forward, moveFwd * moveMult);
        camera.position.addScaledVector(right, moveSide * moveMult);
        camera.position.addScaledVector(up, moveVert * moveMult);
        
        rotation.y += rotYaw * rotateMult;
        
        camera.rotation.order = 'YXZ';
        camera.rotation.set(rotation.x, rotation.y, rotation.z);

        // Control de visibilidad UI (Inactividad 5s)
        if (isTouchDevice) {
            const isInactive = (Date.now() - lastUserActionTime > 5000);
            const opacity = isInactive ? '0' : '1';
            document.getElementById('joy-left').style.opacity = opacity;
            document.getElementById('joy-right').style.opacity = opacity;
        }
    }

    function render() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        if (isStereoMode) {
            renderer.setScissorTest(true);

            // Vista Derecha (Renderizada a la izquierda para Cross-Eye)
            camera.position.x += eyeSeparation;
            renderer.setScissor(0, 0, width / 2, height);
            renderer.setViewport(0, 0, width / 2, height);
            renderer.render(scene, camera);

            // Vista Izquierda (Renderizada a la derecha)
            camera.position.x -= eyeSeparation * 2;
            renderer.setScissor(width / 2, 0, width / 2, height);
            renderer.setViewport(width / 2, 0, width / 2, height);
            renderer.render(scene, camera);

            camera.position.x += eyeSeparation; // Restaurar posición central
            renderer.setScissorTest(false);
        } else {
            renderer.setViewport(0, 0, width, height);
            renderer.render(scene, camera);
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        handleInput(dt);
        updateSectors();
        sectors.forEach(s => s.update(clock.getElapsedTime()));
        render();
    }

    window.onload = init;
</script>
</body>
</html>
