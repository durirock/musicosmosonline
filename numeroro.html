<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aureum Nebulae - Sacred Geometry</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020005;
            font-family: 'Segoe UI', sans-serif;
            color: #00f2ff;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 8px #00f2ff;
        }
        canvas { display: block; }
        #loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 2s ease;
            letter-spacing: 5px;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>

<div id="loading">INICIALIZANDO ÉTER FRACTAL...</div>

<div id="ui">
    <h1 style="margin:0; font-size: 1rem; font-weight: 200; letter-spacing: 4px;">AUREUM NEBULAE</h1>
    <div id="stats" style="font-size: 0.7rem; margin-top: 5px; opacity: 0.7;">
        SECTOR: <span id="pos-info">0, 0, 0</span><br>
        PARTÍCULAS: <span id="part-count">0</span>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    /**
     * AUREUM NEBULAE: Experiencia Inmersiva de Partículas Áureas
     * Basado en el Ángulo de Oro y Geometría Sagrada 3D
     */

    const GOLDEN_ANGLE = (3 - Math.sqrt(5)) * Math.PI;
    const SECTOR_SIZE = 600;
    const PARTICLES_PER_SYSTEM = 8000;
    
    let scene, camera, renderer, clock;
    let sectors = new Map();
    const keys = {};
    let rotation = { x: 0, y: 0, z: 0 };

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x010002);
        
        // Niebla densa para aparición suave (diffuse)
        scene.fog = new THREE.FogExp2(0x010002, 0.0018);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 8000);
        camera.position.set(0, 0, 100);

        renderer = new THREE.WebGLRenderer({ 
            antialias: false, 
            powerPreference: "high-performance" 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1); // Optimización máxima
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // Eventos
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onResize);
        renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());

        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => document.getElementById('loading').remove(), 2000);

        animate();
    }

    /**
     * Clase que genera una "Nebulosa de Fibonacci" única
     */
    class GoldenNebula {
        constructor(ix, iy, iz) {
            this.id = `${ix},${iy},${iz}`;
            
            // Generar geometría de puntos
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLES_PER_SYSTEM * 3);
            const colors = new Float32Array(PARTICLES_PER_SYSTEM * 3);
            const sizes = new Float32Array(PARTICLES_PER_SYSTEM);

            const seed = Math.abs(Math.sin(ix * 12.98 + iy * 78.23 + iz * 45.16) * 43758.54);
            const hueBase = (seed * 0.4) % 1;

            for (let i = 0; i < PARTICLES_PER_SYSTEM; i++) {
                // Algoritmo de Vogel 3D (Filotaxis Esférica y Toroidal)
                const phi = Math.acos(1 - 2 * (i / PARTICLES_PER_SYSTEM));
                const theta = i * GOLDEN_ANGLE;
                
                // Radio basado en semilla para formas orgánicas únicas
                const r = 150 * (0.2 + (seed % 0.8)) * Math.sqrt(i / PARTICLES_PER_SYSTEM) * 2;
                
                // Geometría Sagrada: Variación de pétalos/hojas mediante modulación
                const petalMod = 1 + 0.3 * Math.sin(theta * (3 + Math.floor(seed * 5)));
                
                const x = r * Math.sin(phi) * Math.cos(theta) * petalMod;
                const y = r * Math.sin(phi) * Math.sin(theta) * petalMod;
                const z = r * Math.cos(phi) + (Math.sin(i * 0.01 + seed) * 20);

                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;

                // Color Neón HSL
                const color = new THREE.Color().setHSL((hueBase + i * 0.00005) % 1, 1.0, 0.6);
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;

                sizes[i] = Math.random() * 2.5 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending, // Efecto Neón
                depthWrite: false,
                sizeAttenuation: true
            });

            this.points = new THREE.Points(geometry, material);
            this.points.position.set(ix * SECTOR_SIZE, iy * SECTOR_SIZE, iz * SECTOR_SIZE);
            
            // Rotación inicial aleatoria para mayor diversidad
            this.points.rotation.set(seed, seed * 2, seed * 0.5);
            
            scene.add(this.points);
        }

        update(time) {
            // Animación sutil de respiración sin CPU pesada
            this.points.rotation.y += 0.0005;
            this.points.scale.setScalar(1 + Math.sin(time * 0.5) * 0.05);
        }

        dispose() {
            this.points.geometry.dispose();
            this.points.material.dispose();
            scene.remove(this.points);
        }
    }

    function updateSectors() {
        const cx = Math.round(camera.position.x / SECTOR_SIZE);
        const cy = Math.round(camera.position.y / SECTOR_SIZE);
        const cz = Math.round(camera.position.z / SECTOR_SIZE);

        const range = 1;
        const activeIds = new Set();

        for (let x = cx - range; x <= cx + range; x++) {
            for (let y = cy - range; y <= cy + range; y++) {
                for (let z = cz - range; z <= cz + range; z++) {
                    const id = `${x},${y},${z}`;
                    activeIds.add(id);
                    if (!sectors.has(id)) {
                        sectors.set(id, new GoldenNebula(x, y, z));
                    }
                }
            }
        }

        for (const [id, sector] of sectors) {
            if (!activeIds.has(id)) {
                sector.dispose();
                sectors.delete(id);
            }
        }

        document.getElementById('pos-info').innerText = `${cx}, ${cy}, ${cz}`;
        document.getElementById('part-count').innerText = (sectors.size * PARTICLES_PER_SYSTEM).toLocaleString();
    }

    function onMouseMove(e) {
        if (document.pointerLockElement === renderer.domElement) {
            rotation.y -= e.movementX * 0.0015;
            rotation.x -= e.movementY * 0.0015;
            rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));
        }
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function handleInput(dt) {
        const speed = keys['Space'] ? 400 * dt : 80 * dt;
        
        // Movimiento local de cámara
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

        if (keys['KeyW']) camera.position.addScaledVector(forward, speed);
        if (keys['KeyS']) camera.position.addScaledVector(forward, -speed);
        if (keys['KeyA']) camera.position.addScaledVector(right, -speed);
        if (keys['KeyD']) camera.position.addScaledVector(right, speed);
        if (keys['KeyZ']) camera.position.addScaledVector(up, speed);
        if (keys['KeyX']) camera.position.addScaledVector(up, -speed);

        if (keys['KeyQ']) rotation.z += 0.01;
        if (keys['KeyE']) rotation.z -= 0.01;

        camera.rotation.order = 'YXZ';
        camera.rotation.set(rotation.x, rotation.y, rotation.z);
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();

        handleInput(dt);
        updateSectors();

        sectors.forEach(s => s.update(time));

        renderer.render(scene, camera);
    }

    window.onload = init;
</script>
</body>
</html>
