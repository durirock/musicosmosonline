
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0", maximum-scale=1.0, user-scalable=no">
    <title>Musicosmos - Universo Musical Interactivo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: white;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            opacity: 1;
            transition: opacity 2s ease-in;
        }
        .fade-out {
            opacity: 0 !important; /* A√±adimos !important para forzar la prioridad */
            transition: opacity 2s ease-in; /* Reducir a 2 segundos para una transici√≥n m√°s r√°pida */
            pointer-events: none; /* Impedir que se pueda hacer click despu√©s del fade */
        }
        #midiStatus {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
        }
        #coordinates {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
        }
        #teleportPanel {
            position: absolute;
            bottom: 60px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            z-index: 100;
            border-radius: 5px;
            display: none;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(100, 120, 255, 0.3);
            box-shadow: 0 0 15px rgba(100, 120, 255, 0.3);
        }
        #teleportPanel input {
            width: 60px;
            background-color: rgba(30,30,40,0.8);
            color: white;
            border: 1px solid #557;
            border-radius: 3px;
            padding: 5px;
            margin: 0 5px;
            font-family: monospace;
        }
        #teleportPanel button {
            background-color: #4466dd;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 6px 12px;
            cursor: pointer;
            margin-left: 10px;
        }
        #teleportPanel button:hover {
            background-color: #5577ee;
        }
        canvas {
            display: block;
        }
        .btn-settings {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 15px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-settings:hover {
            background-color: rgba(70,70,100,0.8);
            transform: scale(1.1);
        }
        .btn-teleport {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 0 10px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-teleport:hover {
            background-color: rgba(70,70,100,0.8);
        }
        .btn-perspective {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 0 10px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-perspective:hover {
            background-color: rgba(70,70,100,0.8);
        }
        #settingsMenu {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            /* CAMBIA ESTA L√çNEA para mayor transparencia */
            background-color: rgba(30, 30, 50, 0.85); 
            color: white;
            border-radius: 10px;
            padding: 0; /* Lo quitamos de aqu√≠ para controlar por secciones */
            box-shadow: 0 0 20px rgba(0,0,255,0.3);
            z-index: 200;
            display: none;
            backdrop-filter: blur(8px); /* Aumentamos el blur para que se vea mejor */
        }

        #settingsMenu h3 {
            margin-top: 0;
            color: #aaf;
            border-bottom: 1px solid #557;
            padding-bottom: 10px;
        }
        #viewControls {
            position: absolute;
            right: 20px;
            bottom: 70px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #viewControls button {
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        #viewControls button:hover {
            background-color: rgba(70,70,100,0.8);
        }
        .midi-device-item {
            margin-bottom: 10px;
            padding: 8px;
            background-color: rgba(50,50,80,0.5);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .midi-device-item.active {
            background-color: rgba(80,80,180,0.5);
            border-left: 3px solid #88f;
        }
        .toggle-button {
            width: 40px;
            height: 20px;
            background-color: #444;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
        }
        .toggle-button.active {
            background-color: #55f;
        }
        .toggle-button::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        .toggle-button.active::after {
            transform: translateX(20px);
        }
        .network-status {
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid #557;
        }
        #usernameInput {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background-color: rgba(40,40,60,0.9);
            color: white;
            border: 1px solid #557;
            border-radius: 5px;
        }
        #connectButton {
            padding: 8px 16px;
            background-color: #4466dd;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #connectButton:hover {
            background-color: #5577ee;
        }

        .playlist-separator {
            border: none;
            height: 1px;
            background-color: #557;
            margin: 15px 0;
        }

        .playlist-section {
            width: 100%;
        }

        .playlist-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 0 5px;
        }

        .playlist-header-controls strong {
            font-size: 14px;
            color: #c7e5ff;
        }

        .playlist-buttons button {
            background: none;
            border: 1px solid #557;
            color: #aab;
            width: 28px;
            height: 28px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .playlist-buttons button:hover {
            border-color: #fff;
            color: #fff;
        }

        .playlist-buttons button.active {
            background-color: rgba(68, 102, 221, 0.6);
            border-color: #4466dd;
            color: #fff;
        }

        .playlist-item.radio-stream {
            background-color: rgba(20, 20, 25, 0.8);
            border: 1px solid #98324a;
            color: #ff99aa;
            font-weight: bold;
            border-radius: 5px;
            margin: 0 15px; /* Margen para que no ocupe todo el ancho */
        }

        .playlist-item.radio-stream:hover {
            border-color: #ff5577;
            color: #ffdde2;
            background-color: rgba(50, 25, 30, 0.8);
        }

        .playlist-item.radio-stream.active {
            background-color: rgba(180, 60, 90, 0.6);
            border-color: #ff809d;
            color: #fff;
        }

        .playlist-item-empty {
            padding: 10px;
            text-align: center;
            font-style: italic;
            color: #778;
        }
        </style>
    </style>
</head>
<body>
    <div id="touch-controls" class="touch-controls-container">
        <div id="joystick-container">
            <div id="joystick-knob"></div>
        </div>
        
        <div id="joystick-container-rotation">
            <div id="joystick-knob-rotation"></div>
        </div>

        <div id="button-hyperspace" class="action-button">üöÄ</div>
    </div>
    <div id="info">
        <h1>Musicosmos</h1>
        <p>Conecta un dispositivo MIDI y toca para crear galaxias musicales.</p>
        <p>Usa las teclas W, A, S, D para moverte, rat√≥n para navegar en todas direcciones.</p>
    </div>
    
    <div id="midiStatus">Esperando conexi√≥n MIDI...</div>
    <div id="coordinates">X: 0.00, Y: 0.00, Z: 0.00</div>
    
    <button class="btn-teleport" id="btnTeleport">Teletransporte</button>
    <button class="btn-perspective" id="btnPerspective">Cambiar Vista</button>
    
    <div id="teleportPanel">
        <div>X: <input type="number" id="teleportX" step="0.1"></div>
        <div>Y: <input type="number" id="teleportY" step="0.1"></div>
        <div>Z: <input type="number" id="teleportZ" step="0.1"></div>
        <button id="btnGoToCoords">Ir a Coordenadas</button>
    </div>
    

    
    <button class="btn-settings" id="btnSettings">‚öôÔ∏è</button>
    
    <div id="settingsMenu"> 
        
        <div class="settings-tabs">
            <button class="tab-button active" data-tab="tab-general">General</button>
            <button class="tab-button" data-tab="tab-playlist">Playlist</button>
            <button class="tab-button" data-tab="tab-pulsares">Pulsares</button>
        </div>
        
        <div id="tab-general" class="tab-content active">
            <h3>Configuraci√≥n General</h3>
            
            <div>
                <h4>Dispositivos MIDI</h4>
                <div id="midiDevicesContainer">
                    <p>No se encontraron dispositivos MIDI</p>
                </div>
            </div>
            
            <div class="network-status">
                <h4>Multijugador</h4>
                <input type="text" id="usernameInput" placeholder="Tu nombre en el cosmos" maxlength="20">
                <button id="connectButton">Conectar</button>
                <div id="playersOnline"></div>
            </div>
        
            <div class="galaxy-settings">
                <h4>Configuraci√≥n de Galaxia</h4>
                <div class="setting-item">
                    <label for="galaxySize">Tama√±o de Galaxia:</label>
                    <input type="range" id="galaxySize" min="15" max="50" value="25" class="slider">
                    <span id="galaxySizeValue">25</span>
                </div>
                <div class="setting-item">
                    <label for="particleCount">Part√≠culas Afectadas por Nota:</label>
                    <input type="range" id="particleCount" min="5" max="30" value="12" class="slider">
                    <span id="particleCountValue">12%</span>
                </div>
                <div class="setting-item">
                    <label for="colorMixing">Intensidad de Mezcla de Color:</label>
                    <input type="range" id="colorMixing" min="30" max="80" value="50" class="slider">
                    <span id="colorMixingValue">50%</span>
                </div>
                <div class="setting-item">
                    <label for="expansionTime">Tiempo de Expansi√≥n:</label>
                    <input type="range" id="expansionTime" min="2000" max="8000" value="4000" step="1000" class="slider">
                    <span id="expansionTimeValue">4s</span>
                </div>
                <div class="setting-item">
                    <label for="fadeoutTime">Tiempo de Inactividad:</label>
                    <input type="range" id="fadeoutTime" min="10000" max="60000" value="20000" step="5000" class="slider">
                    <span id="fadeoutTimeValue">20s</span>
                </div>
                <button id="applyGalaxySettings" class="settings-button">Guardar Configuraci√≥n</button>
                <button id="resetGalaxySettings" class="settings-button secondary">Restaurar Valores</button>
            </div>
        </div>
        
        <div id="tab-playlist" class="tab-content">
            <h3>Playlist del Cosmos</h3>
        
            <div class="playlist-section" id="radio-section">
                <div id="tagua-radio-item" class="playlist-item radio-stream">
                    <span class="play-indicator">‚ñ∂</span> Radio Tagua Tagua (Stream)
                </div>
            </div>
        
            <hr class="playlist-separator">
        
            <div class="playlist-section">
                <div class="playlist-header-controls">
                    <strong>P√∫lsares Descubiertos</strong>
                    <div class="playlist-buttons">
                        <button id="btn-repeat" title="Repetir">üîÅ</button>
                        <button id="btn-shuffle" title="Aleatorio">üîÄ</button>
                    </div>
                </div>
                <div class="playlist-container">
                    <ul id="playlist-list">
                        <li class="playlist-item-empty">A√∫n no has descubierto p√∫lsares.</li>
                    </ul>
                </div>
            </div>
            
            <div class="playlist-controls">
                <div id="now-playing">
                    <strong>Ahora suena:</strong> <span id="current-track-name">Silencio...</span>
                </div>
                <div class="volume-control">
                    <label for="playlist-volume">Volumen Playlist (2D):</label>
                    <input type="range" id="playlist-volume" min="0" max="1" step="0.01" value="0.7">
                </div>
                <div class="volume-control">
                    <label for="pulsarVolume">Volumen P√∫lsares (3D):</label>
                    <input type="range" id="pulsarVolume" min="0.1" max="15" value="5" step="0.1" class="slider">
                    <span id="pulsarVolumeValue">5.0</span>
                </div>
            </div>
        </div>
        
        
        
        <div id="tab-pulsares" class="tab-content">
            <h3>Forja de Pulsares</h3>

            <div class="forge-section placement-controls">
                <h4>1. Ubicaci√≥n de la Forja</h4>
                <p>Elige d√≥nde se materializar√° tu nuevo p√∫lsar.</p>
                <div class="forge-toggle-buttons">
                    <input type="radio" name="placementMode" id="placeFront" value="front" checked>
                    <label for="placeFront">Frente a m√≠</label>
                    
                    <input type="radio" name="placementMode" id="placeCoords" value="coords">
                    <label for="placeCoords">Coordenadas</label>
                </div>
                
                <div id="forge-coords-inputs" class="forge-coords-inputs">
                    <div>X: <input type="number" id="forgeX" class="alien-coord-input" step="1"></div>
                    <div>Y: <input type="number" id="forgeY" class="alien-coord-input" step="1"></div>
                    <div>Z: <input type="number" id="forgeZ" class="alien-coord-input" step="1"></div>
                </div>
            </div>

            <div class="forge-section">
                <h4>2. Forjar P√∫lsar en Vivo (L√≠nea/Mic)</h4>
                <p>Visualiza una entrada de audio. Puedes crear m√∫ltiples p√∫lsares.</p>
                
                <div style="margin-bottom: 10px;">
                    <button id="scanAudioDevicesBtn" class="settings-button secondary" style="width:100%">üîç Escanear Dispositivos de Audio</button>
                </div>

                <label for="audioInputDevice">Fuente de audio:</label>
                <select id="audioInputDevice" class="alien-input">
                    <option value="">Primero escanea dispositivos...</option>
                </select>
                
                <div class="button-group">
                    <button id="startLivePulsar" class="settings-button">Crear P√∫lsar</button>
                    <button id="clearLivePulsars" class="settings-button secondary">Eliminar Todos los Vivos</button>
                </div>
                <div id="livePulsarStatus" class="forge-status"></div>
            </div>

            <div class="forge-section">
                <h4>3. Forjar P√∫lsar Personal (MP3)</h4>
                <p>Sube un archivo de audio. El p√∫lsar sonar√° en 3D en la ubicaci√≥n seleccionada.</p>
                
                <label for="newPulsarName">Nombre del P√∫lsar:</label>
                <input type="text" id="newPulsarName" placeholder="Ej: Mi Canci√≥n Favorita" class="alien-input">
                
                <label for="newPulsarFileInput">Archivo de Audio (MP3, WAV, etc.):</label>
                <input type="file" id="newPulsarFileInput" accept="audio/*" class="alien-file-input">
                
                <button id="createPersonalPulsarButton" class="settings-button">Forjar P√∫lsar MP3</button>
                <div id="forgePulsarStatus" class="forge-status"></div>
            </div>

            <div class="forge-section">
                <h4>3. Establecer Radio Tagua Tagua</h4>
                <p>Crear√° una nebulosa majestuosa de la Radio Tagua Tagua en la ubicaci√≥n seleccionada.</p>
                
                <button id="createTaguaPulsarButton" class="settings-button">Forjar Radio Tagua Tagua</button>
                <div id="forgeRadioStatus" class="forge-status"></div>
            </div>
        </div>
          
          <!-- Estilos para el panel de configuraci√≥n -->
          <style>
            /* Controles T√°ctiles */
            /* --- NUEVOS ESTILOS T√ÅCTILES MEJORADOS --- */
            .touch-controls-container {
                position: fixed; /* Fixed evita que se muevan al rotar la pantalla */
                top: 0; left: 0; right: 0; bottom: 0;
                width: 100%; height: 100%;
                pointer-events: none;
                z-index: 999;
                display: none;
            }

            /* Joystick Izquierdo (Movimiento) */
            #joystick-container {
                position: fixed;
                bottom: 20px;
                left: 20px;
                width: 100px;
                height: 100px;
                background-color: rgba(255, 255, 255, 0.05); /* Muy transparente */
                border: 1px solid rgba(255, 255, 255, 0.3);
                border-radius: 50%;
                display: flex;
                justify-content: center;
                align-items: center;
                pointer-events: auto;
                backdrop-filter: blur(2px);
                user-select: none;
                -webkit-user-select: none;
            }

            #joystick-knob {
                width: 40px;
                height: 40px;
                background-color: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(255, 255, 255, 0.6);
                border-radius: 50%;
                position: absolute;
                cursor: pointer;
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
            }

            /* Joystick Derecho (Rotaci√≥n) - Reemplaza los estilos anteriores */
            #joystick-container-rotation {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 100px;
                height: 100px;
                background-color: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.3);
                border-radius: 50%;
                display: flex;
                justify-content: center;
                align-items: center;
                pointer-events: auto;
                backdrop-filter: blur(2px);
                user-select: none;
                -webkit-user-select: none;
            }

            #joystick-knob-rotation {
                width: 40px;
                height: 40px;
                background-color: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(255, 255, 255, 0.6);
                border-radius: 50%;
                position: absolute;
                cursor: pointer;
            }

            /* Bot√≥n Hipersalto */
            #button-hyperspace {
                position: fixed;
                bottom: 140px; 
                right: 45px;
                width: 50px;
                height: 50px;
                background-color: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.4);
                border-radius: 50%;
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 20px;
                color: white;
                pointer-events: auto;
                backdrop-filter: blur(2px);
                transition: all 0.2s;
                user-select: none;
                -webkit-user-select: none;
            }

            #button-hyperspace.active {
                background-color: rgba(98, 215, 255, 0.4);
                border-color: #fff;
                box-shadow: 0 0 15px rgba(98, 215, 255, 0.6);
                transform: scale(1.1);
            }

            /* Asegurar que el body no haga scroll en t√°ctil */
            body.touch-active {
                overscroll-behavior: none;
            }

            .galaxy-settings {
              margin-top: 20px;
              padding-top: 15px;
              border-top: 1px solid #557;
            }
            
            .setting-item {
              margin: 12px 0;
              display: flex;
              align-items: center;
              flex-wrap: wrap;
            }
            
            .setting-item label {
              width: 100%;
              margin-bottom: 5px;
              color: #aaf;
              font-size: 14px;
            }
            
            .slider {
              flex: 1;
              height: 6px;
              appearance: none;
              background: rgba(50,50,100,0.6);
              border-radius: 3px;
              margin-right: 10px;
            }
            
            .slider::-webkit-slider-thumb {
              appearance: none;
              width: 15px;
              height: 15px;
              border-radius: 50%;
              background: #4466dd;
              cursor: pointer;
            }
            
            .slider::-moz-range-thumb {
              width: 15px;
              height: 15px;
              border-radius: 50%;
              background: #4466dd;
              cursor: pointer;
            }
            
            .settings-button {
              padding: 8px 16px;
              background-color: #4466dd;
              color: white;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              margin-top: 10px;
              margin-right: 10px;
            }
            
            .settings-button:hover {
              background-color: #5577ee;
            }
            
            .settings-button.secondary {
              background-color: #555;
            }
            
            .settings-button.secondary:hover {
              background-color: #777;
            }

            /* --- ESTILOS PARA PESTA√ëAS DEL PANEL DE CONFIGURACI√ìN --- */
            .settings-tabs {
                display: flex;
                border-bottom: 1px solid #557;
                background-color: rgba(40, 40, 60, 0.9);
                padding: 5px 5px 0 5px;
                border-top-left-radius: 10px;
                border-top-right-radius: 10px;
            }

            .tab-button {
                padding: 10px 15px;
                cursor: pointer;
                background-color: transparent;
                border: none;
                color: #aab;
                font-size: 14px;
                border-radius: 5px 5px 0 0;
                transition: background-color 0.3s, color 0.3s;
                outline: none;
            }

            .tab-button:hover {
                background-color: rgba(80, 80, 120, 0.5);
                color: #fff;
            }

            .tab-button.active {
                background-color: rgba(30, 30, 50, 0.9); /* Mismo color que el fondo del panel */
                color: #fff;
                border-bottom: 2px solid #4466dd;
            }

            .tab-content {
                display: none; /* Oculto por defecto */
                padding: 15px;
                animation: fadeIn 0.5s;
            }

            .tab-content.active {
                display: block; /* Visible solo si tiene la clase active */
            }

            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }

            /* --- ESTILOS PARA LA PESTA√ëA PLAYLIST --- */
            .playlist-container {
                max-height: 200px;
                overflow-y: auto;
                background-color: rgba(15, 15, 25, 0.7);
                border: 1px solid #557;
                border-radius: 5px;
                margin-bottom: 15px;
            }

            #playlist-list {
                list-style: none;
                padding: 0;
                margin: 0;
            }

            .playlist-item {
                padding: 10px 12px;
                border-bottom: 1px solid #334;
                cursor: pointer;
                transition: background-color 0.2s;
                font-size: 14px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .playlist-item:last-child {
                border-bottom: none;
            }

            .playlist-item:hover {
                background-color: rgba(80, 80, 120, 0.5);
            }

            .playlist-item.active {
                background-color: rgba(68, 102, 221, 0.6);
                color: #fff;
                font-weight: bold;
            }

            .playlist-item .play-indicator {
                font-size: 10px;
                color: #9f9;
                opacity: 0;
                transition: opacity 0.3s;
            }

            .playlist-item.active .play-indicator {
                opacity: 1;
            }

            .playlist-controls {
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid #557;
            }

            #now-playing {
                font-size: 13px;
                margin-bottom: 10px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            #now-playing span {
                color: #aac;
            }

            .volume-control {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 14px;
            }

            #playlist-volume {
                flex-grow: 1;
            }

            /* --- A√ëADE ESTOS ESTILOS AL FINAL DE TU CSS --- */
            .radio-control-section {
                padding: 10px;
                background-color: rgba(30, 30, 50, 0.8);
                border-radius: 5px;
                margin-bottom: 15px;
                text-align: center;
            }
            .radio-control-section strong {
                font-size: 14px;
                color: #ffc0d0; /* Color distintivo para la radio */
            }
            .radio-buttons {
                margin-top: 8px;
                display: flex;
                justify-content: center;
                gap: 10px;
            }
            .radio-buttons button {
                background-color: #555;
                border: 1px solid #777;
                color: #eee;
                padding: 5px 15px;
                border-radius: 4px;
                cursor: pointer;
            }
            .radio-buttons button:hover {
                background-color: #666;
            }
            /* A√ëADE ESTE BLOQUE A TU CSS */

            .playlist-separator {
                border: none;
                height: 1px;
                background-color: #557;
                margin: 10px 15px;
            }
            .playlist-section {
                padding: 0 15px;
            }
            #radio-section {
                padding-bottom: 5px;
            }
            .playlist-header-controls {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
            }
            .playlist-buttons button {
                background: none; border: 1px solid #557; color: #aab;
                width: 28px; height: 28px; border-radius: 5px; cursor: pointer;
                font-size: 14px; transition: all 0.2s;
            }
            .playlist-buttons button:hover {
                border-color: #fff; color: #fff;
            }
            .playlist-buttons button.active {
                background-color: rgba(68, 102, 221, 0.6);
                border-color: #4466dd; color: #fff;
            }
            .playlist-item.radio-stream {
                background-color: rgba(20, 20, 25, 0.8);
                border: 1px solid #98324a; color: #ff99aa;
                font-weight: bold; border-radius: 5px;
            }
            .playlist-item.radio-stream:hover {
                border-color: #ff5577; color: #ffdde2;
                background-color: rgba(50, 25, 30, 0.8);
            }
            .playlist-item.radio-stream.active {
                background-color: rgba(180, 60, 90, 0.6);
                border-color: #ff809d; color: #fff;
            }
            .playlist-item-empty {
                padding: 10px; text-align: center;
                font-style: italic; color: #778;
            }
            .volume-control {
                margin-top: 10px;
            }

            /* --- ESTILOS PARA EL SEGUNDO JOYSTICK (ROTACI√ìN) --- */
        #joystick-container-rotation {
            position: absolute;
            bottom: 30px;
            right: 30px; /* <-- La clave es 'right' en lugar de 'left' */
            width: 150px;
            height: 150px;
            background-color: rgba(50, 50, 80, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            border: 2px solid rgba(120, 120, 150, 0.5);
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        #joystick-knob-rotation {
            width: 70px;
            height: 70px;
            background-color: rgba(100, 100, 150, 0.7);
            border-radius: 50%;
            border: 2px solid rgba(180, 180, 220, 0.8);
            position: absolute;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
        /* --- ESTILOS PARA EL BOT√ìN DE HIPERVELOCIDAD --- */
        #button-hyperspace {
            position: absolute;
            bottom: 180px; /* Posici√≥n vertical */
            right: 30px;   /* Posici√≥n horizontal */
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }

        #button-hyperspace.active {
            background-color: rgba(98, 215, 255, 0.7);
            box-shadow: 0 0 20px rgba(98, 215, 255, 1);
            transform: scale(1.1);
        }

        /* --- ESTILOS PARA LA FORJA DE P√öLSARES --- */
        .forge-section {
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(15, 15, 25, 0.7);
            border: 1px solid #557;
            border-radius: 5px;
        }

        .forge-section h4 {
            color: #c7e5ff;
            margin-top: 0;
            margin-bottom: 8px;
            border-bottom: 1px solid #445;
            padding-bottom: 5px;
        }

        .forge-section p {
            font-size: 13px;
            color: #aab;
            margin-bottom: 15px;
        }

        .forge-section label {
            font-size: 12px;
            color: #aaf;
            display: block;
            margin-bottom: 4px;
        }

        .alien-input {
            width: 100%;
            box-sizing: border-box; /* Para que el padding no rompa el ancho */
            padding: 8px;
            margin-bottom: 10px;
            background-color: rgba(40,40,60,0.9);
            color: white;
            border: 1px solid #557;
            border-radius: 5px;
            font-family: 'Arial', sans-serif;
        }

        /* Estilo para el <select> de audio */
        select.alien-input {
            appearance: none;
            -webkit-appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23AAAAFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-13%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2013l128%20128c3.6%203.6%207.8%205.4%2013%205.4s9.4-1.8%2013-5.4l128-128c3.6-3.6%205.4-7.8%205.4-13%200-4.8-1.8-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 10px;
        }

        .alien-file-input {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 15px;
            font-size: 12px;
        }

        .alien-file-input::file-selector-button {
            background-color: #4466dd;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 6px 12px;
            cursor: pointer;
            margin-right: 10px;
        }
        .alien-file-input::file-selector-button:hover {
            background-color: #5577ee;
        }

        .forge-status {
            font-size: 13px;
            margin-top: 10px;
            color: #9f9;
            text-align: center;
        }

        .forge-status.error {
            color: #f99;
        }

        /* Controles de Ubicaci√≥n */
        .placement-controls {
            background-color: rgba(30, 30, 50, 0.8);
            border-color: #7799ff;
        }

        .forge-toggle-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .forge-toggle-buttons input[type="radio"] {
            display: none;
        }

        .forge-toggle-buttons label {
            padding: 8px 12px;
            background-color: #334;
            border: 1px solid #557;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            color: #aab;
            transition: all 0.2s;
            display: block;
            margin: 0;
        }

        .forge-toggle-buttons input[type="radio"]:checked + label {
            background-color: #4466dd;
            color: #fff;
            border-color: #7799ff;
            box-shadow: 0 0 8px rgba(68, 102, 221, 0.5);
        }

        .forge-coords-inputs {
            display: none; /* Oculto por defecto */
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            background-color: rgba(10, 10, 20, 0.5);
            border-radius: 5px;
        }

        #placeCoords:checked ~ #forge-coords-inputs {
            display: flex;
        }

        .alien-coord-input {
            width: 70px;
            padding: 5px;
            background-color: rgba(40,40,60,0.9);
            color: white;
            border: 1px solid #557;
            border-radius: 3px;
            font-family: monospace;
        }

        /* Grupo de botones (para Live) */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
          </style>
          
          <!-- Script para manejar la configuraci√≥n de la galaxia -->
          <script>
          // Variables para almacenar la configuraci√≥n de la galaxia
          let galaxySettings = {
            size: 25,
            particleCount: 12,
            colorMixing: 50,
            expansionTime: 4000,
            fadeoutTime: 20000
          };
          
          // Funci√≥n para inicializar los sliders y eventos
          function initGalaxySettings() {
            // Vincular sliders con sus valores de visualizaci√≥n
            const sliders = {
                'galaxySize': { elem: document.getElementById('galaxySizeValue'), suffix: '', key: 'size' },
                'particleCount': { elem: document.getElementById('particleCountValue'), suffix: '%', key: 'particleCount' },
                'colorMixing': { elem: document.getElementById('colorMixingValue'), suffix: '%', key: 'colorMixing' },
                'expansionTime': { elem: document.getElementById('expansionTimeValue'), suffix: 's', key: 'expansionTime' },
                'fadeoutTime': { elem: document.getElementById('fadeoutTimeValue'), suffix: 's', key: 'fadeoutTime' }
            };
            
            // Configurar eventos de los sliders
            Object.keys(sliders).forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const info = sliders[sliderId];
                
                slider.addEventListener('input', () => {
                let displayValue = slider.value;
                
                // Formatear valores especiales
                if (sliderId === 'expansionTime' || sliderId === 'fadeoutTime') {
                    displayValue = (slider.value / 1000).toFixed(0);
                }
                
                info.elem.textContent = displayValue + info.suffix;
                galaxySettings[info.key] = parseInt(slider.value);
                
                // Aplicar cambios inmediatamente
                applyGalaxySettings(false); // Pasar false para no mostrar notificaci√≥n
                });
            });
            
            // El bot√≥n aplicar ahora solo guarda la configuraci√≥n
            document.getElementById('applyGalaxySettings').textContent = 'Guardar Configuraci√≥n';
            document.getElementById('applyGalaxySettings').addEventListener('click', applyGalaxySettings);
            
            // Bot√≥n restaurar valores
            document.getElementById('resetGalaxySettings').addEventListener('click', resetGalaxySettings);
            }

            // Modificar la funci√≥n // Modificar la funci√≥n applyGalaxySettings para aceptar un par√°metro de notificaci√≥n
            function applyGalaxySettings(showNotification = true) {
    // 1. Guardar en localStorage
    if (showNotification) {
        localStorage.setItem('musicosmosGalaxySettings', JSON.stringify(galaxySettings));
    }

    // 2. Crear objeto de configuraci√≥n nueva
    const newConfig = {
        maxExpansion: galaxySettings.size,
        particleAffectedRatio: galaxySettings.particleCount / 100,
        colorMixFactor: galaxySettings.colorMixing / 100,
        expansionTime: galaxySettings.expansionTime,
        inactivityTime: galaxySettings.fadeoutTime
    };

    // 3. Aplicar SOLO a la galaxia LOCAL (la tuya)
    if (galaxies[username] && galaxies[username].pixelGalaxy) {
        if (galaxies[username].pixelGalaxy.updateConfig) {
            galaxies[username].pixelGalaxy.updateConfig(newConfig);
        }
    }

    // 4. IMPORTANTE: Forzar el env√≠o de estos datos a la red inmediatamente
    // para que los dem√°s vean tu cambio.
    sendPosition(); 

    // 5. Notificar
    if (showNotification) {
        showNotification('Configuraci√≥n de TU galaxia guardada', 2000);
    }
}
          
          // Funci√≥n para restaurar valores predeterminados
          function resetGalaxySettings() {
            // Restaurar valores por defecto
            document.getElementById('galaxySize').value = 25;
            document.getElementById('galaxySizeValue').textContent = '25';
            document.getElementById('particleCount').value = 12;
            document.getElementById('particleCountValue').textContent = '12%';
            document.getElementById('colorMixing').value = 50;
            document.getElementById('colorMixingValue').textContent = '50%';
            document.getElementById('expansionTime').value = 4000;
            document.getElementById('expansionTimeValue').textContent = '4s';
            document.getElementById('fadeoutTime').value = 20000;
            document.getElementById('fadeoutTimeValue').textContent = '20s';
            
            // Actualizar objeto de configuraci√≥n
            galaxySettings = {
              size: 25,
              particleCount: 12,
              colorMixing: 50,
              expansionTime: 4000,
              fadeoutTime: 20000
            };
            
            // Aplicar valores restaurados
            applyGalaxySettings();
          }
          
          // Funci√≥n auxiliar para mostrar notificaciones
          function showNotification(message, duration = 3000) {
            // Crear elemento de notificaci√≥n si no existe
            let notification = document.getElementById('notification');
            if (!notification) {
              notification = document.createElement('div');
              notification.id = 'notification';
              notification.style.position = 'fixed';
              notification.style.bottom = '20px';
              notification.style.left = '50%';
              notification.style.transform = 'translateX(-50%)';
              notification.style.backgroundColor = 'rgba(68, 102, 221, 0.8)';
              notification.style.color = 'white';
              notification.style.padding = '10px 20px';
              notification.style.borderRadius = '5px';
              notification.style.zIndex = '1000';
              notification.style.transition = 'opacity 0.3s';
              document.body.appendChild(notification);
            }
            
            // Mostrar mensaje
            notification.textContent = message;
            notification.style.opacity = '1';
            
            // Ocultar despu√©s de la duraci√≥n
            setTimeout(() => {
              notification.style.opacity = '0';
            }, duration);
          }
          
          // Cargar configuraci√≥n guardada al iniciar
          function loadGalaxySettings() {
            const savedSettings = localStorage.getItem('musicosmosGalaxySettings');
            if (savedSettings) {
              try {
                const parsedSettings = JSON.parse(savedSettings);
                galaxySettings = parsedSettings;
                
                // Actualizar sliders con valores guardados
                document.getElementById('galaxySize').value = galaxySettings.size;
                document.getElementById('galaxySizeValue').textContent = galaxySettings.size;
                document.getElementById('particleCount').value = galaxySettings.particleCount;
                document.getElementById('particleCountValue').textContent = galaxySettings.particleCount + '%';
                document.getElementById('colorMixing').value = galaxySettings.colorMixing;
                document.getElementById('colorMixingValue').textContent = galaxySettings.colorMixing + '%';
                document.getElementById('expansionTime').value = galaxySettings.expansionTime;
                document.getElementById('expansionTimeValue').textContent = (galaxySettings.expansionTime / 1000) + 's';
                document.getElementById('fadeoutTime').value = galaxySettings.fadeoutTime;
                document.getElementById('fadeoutTimeValue').textContent = (galaxySettings.fadeoutTime / 1000) + 's';
              } catch (e) {
                console.error('Error al cargar configuraci√≥n guardada:', e);
              }
            }
          }
          
          // Inicializar configuraci√≥n cuando el DOM est√© cargado
          document.addEventListener('DOMContentLoaded', function() {
            // Inicializar cuando el DOM est√© listo
            initGalaxySettings();
            
            // Cargar configuraci√≥n guardada
            loadGalaxySettings();
          });
          </script>
          
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Variables principales
        let scene, camera, renderer;
        let nebulaRadarElement, radarArrowElement, radarDotElement;
        let ultimaCancionUrl = null; // Aqu√≠ guardaremos la URL de la √∫ltima canci√≥n usada
        // A√ëADIR ESTAS VARIABLES PARA EL CONTROL DE LA √ìRBITA
        // ----------------------------------------------------
        let currentOrbitAngleH = 0; // √Ångulo horizontal
        let currentOrbitAngleV = 0.2; // √Ångulo vertical (un poco picado)
        // ----------------------------------------------------
        let clock = new THREE.Clock();
        let updatableSpecialFeatures = [];
        let audioListener;
        let galaxies = {};
        let particles = [];  // Para mezcla de colores global
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        let rotateCameraLeft = false;
        let rotateCameraRight = false;
        const cameraRotationSpeed = 0.02; // Velocidad de rotaci√≥n
        let pitchAngle = 0;
        let yawAngle = 0;
        let gridHelper;
        let proceduralGenerator; // A√±ade esta l√≠nea
        let hyperspaceEffect;
        let hyperspaceModeActive = false;
        // A√ëADIR ESTAS VARIABLES GLOBALES PARA EL MODO √ìRBITA
        // ----------------------------------------------------
        let isOrbitingNebula = false;
        let orbitingNebulaInstance = null;
        let orbitDistance = 200; // Distancia de la √≥rbita
        let orbitAngle = 0.0;
        const ORBIT_SPEED = 0.0005; // La velocidad a la que el avatar girar√° autom√°ticamente
        const MIN_ORBIT_DISTANCE = 40;
        const MAX_ORBIT_DISTANCE = 500;
        const ORBIT_ZOOM_SPEED = 2.5; // Velocidad para acercarse/alejarse con teclas en modo √≥rbita.
        let currentOrbitType = 'comet'; // <-- ¬°A√ëADE ESTA L√çNEA! 'comet' o 'fixed'


        let playerOrbitSpeed = 0.0; // A√ëADIDO: Controlar√° la velocidad orbital del jugador con A y D.

        // A√ëADIR ESTAS NUEVAS VARIABLES GLOBALES PARA EL ARRASTRE DE P√öLSARES
        // ----------------------------------------------------
        let raycaster = new THREE.Raycaster();
        let mousePosition = new THREE.Vector2();
        let draggedPulsar = null; // Guardar√° la instancia del p√∫lsar que estamos arrastrando

         // A√ëADE ESTAS DOS L√çNEAS PARA EVITAR EL CRASH
        // ----------------------------------------------------
        let radioNebulaInstance = null;
        let radioNebulaInstanceTaguaTagua = null;
        let audioContext;

        // A√ëADE ESTA CONSTANTE PARA LA CAPA DE CLIC
        const CLICKABLE_LAYER = 1;

        // --- Variables para la Radio Tagua Tagua Est√°tica ---
        let radioTaguaTaguaStream;
        let radioTaguaTaguaNebula = null;
        let analyserNodeTaguaTagua;
        const TAGUA_TAGUA_STREAM_URL = 'https://stream-165.zeno.fm/d5rixk44lfyvv';
        const TAGUA_TAGUA_NEBULA_POS = new THREE.Vector3(0, 250, 400); // Posici√≥n: 400 unidades por encima del origen.

       // REEMPLAZA las variables de la playlist con estas:
         // --- Variables de la Playlist (Versi√≥n Simplificada) ---
        let playlistAudio = new Audio(); // Un √∫nico reproductor para todo
        let playlist = []; 
        let currentTrackId = null; // Usaremos un ID √∫nico ('radio' o el pulsarId) en lugar de un √≠ndice
        let userPlaylistVolume = 0.7; 
        let pulsarVolumeMultiplier = 10.0;
        let isRepeatOn = false;
        let isShuffleOn = false;

        // --- Constantes para el Fade ---
        const FADE_START_DISTANCE = 800; // Distancia a la que empieza el fade out
        const FADE_END_DISTANCE = 350;   // Distancia a la que el volumen es 0

        let isStereoMode = false;
        let eyeSeparation = 0.15; // Esta es la nueva variable que controla la intensidad del 3D

        // --- Variables para controles t√°ctiles ---
        let isTouchDevice = false;
        let joystickActive = false;
        let joystickInitialPos = { x: 0, y: 0 };
        const joystickMaxDistance = 25; // Radio m√°ximo de movimiento del knob (aj√∫stalo si es necesario)

          // --> A√ëADIDO: Variables para el segundo joystick y doble toque
        let rotationJoystickActive = false;
        let rotationJoystickInitialPos = { x: 0, y: 0 };
        let touchIdentifierRotationJoystick = null;
        let lastJoystickTapTime = 0; // Para detectar el doble toque

        // --- Variables para P√∫lsar en Vivo (Micr√≥fono/L√≠nea) ---
        let livePulsarInstance = null;
        let livePulsarAnalyser = null;
        let livePulsarStream = null;
        let livePulsarSource = null;
        let liveFrequencyData = null; // Array para datos de frecuencia
        let liveTimeData = null;      // Array para datos de dominio de tiempo

        let selectedPulsarId = null; // Guardar√° el ID del p√∫lsar seleccionado para borrar
        let selectionHalo = null;    // Objeto visual para indicar selecci√≥n


// ----------------------------------------------------
        function elegirSiguienteCancion() {
            // Si solo hay una canci√≥n en la biblioteca, no hay opci√≥n, devolvemos esa.
            if (miBibliotecaMusical.length <= 1) {
                return miBibliotecaMusical[0];
            }

            let cancionElegida;
            // Usamos un bucle 'do-while' para asegurarnos de que la nueva canci√≥n
            // sea diferente a la √∫ltima. Repetir√° el sorteo si sale la misma.
            do {
                const indiceAleatorio = Math.floor(Math.random() * miBibliotecaMusical.length);
                cancionElegida = miBibliotecaMusical[indiceAleatorio];
            } while (cancionElegida === ultimaCancionUrl);

            // Actualizamos nuestra memoria con la nueva canci√≥n que vamos a usar
            ultimaCancionUrl = cancionElegida;
            
            // Devolvemos la canci√≥n que no se repite
            return cancionElegida;
        }
        // A√±ade esto despu√©s de las variables principales (let scene, camera, renderer; etc.)

        // Sistema de generaci√≥n procedural para Musicosmos
        // Versi√≥n mejorada del sistema procedural
        class ProceduralGenerator {
            constructor(scene, chunkSize = 200) {
                this.scene = scene;
                this.chunkSize = chunkSize;
                this.activeChunks = new Map();
                this.visibleDistance = 2;
                this.playerPosition = new THREE.Vector3();
                this.currentChunkCoords = null;
                this.chunkSeed = 12345;
                this.nebulaeObjects = []; // Tracking para animaci√≥n de nebulosas
            }

            applyFadeOutEffect(chunkObject, onComplete) {
                const fadeOutDuration = 1500; // 1.5 segundos para el desvanecimiento
                const startTime = Date.now();

                const fadeOut = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1, elapsedTime / fadeOutDuration);
                    const opacity = 1 - progress; // Opacidad inversa

                    chunkObject.traverse(object => {
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(mat => {
                                    if (mat._originalOpacity) {
                                        mat.opacity = opacity * mat._originalOpacity;
                                    }
                                });
                            } else if (object.material._originalOpacity) {
                                object.material.opacity = opacity * object.material._originalOpacity;
                            }
                        }
                    });

                    if (progress < 1) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        onComplete(); // Llama a la funci√≥n de completado cuando termina
                    }
                };
                fadeOut();
            }

            update(playerPosition) {
                this.playerPosition.copy(playerPosition);
                
                const chunkX = Math.floor(playerPosition.x / this.chunkSize);
                const chunkY = Math.floor(playerPosition.y / this.chunkSize);
                const chunkZ = Math.floor(playerPosition.z / this.chunkSize);
                const chunkCoords = `${chunkX},${chunkY},${chunkZ}`;
                
                if (this.currentChunkCoords !== chunkCoords) {
                    this.currentChunkCoords = chunkCoords;
                    this.updateChunks();
                }
                
                // Animar las nebulosas
                this.animateNebulae();
            }
            
            updateChunks() {
                const [chunkX, chunkY, chunkZ] = this.currentChunkCoords.split(',').map(Number);
                const chunksToKeep = new Set();
                
                for (let x = chunkX - this.visibleDistance; x <= chunkX + this.visibleDistance; x++) {
                    for (let y = chunkY - this.visibleDistance; y <= chunkY + this.visibleDistance; y++) {
                        for (let z = chunkZ - this.visibleDistance; z <= chunkZ + this.visibleDistance; z++) {
                            const coords = `${x},${y},${z}`;
                            chunksToKeep.add(coords);
                            
                            if (!this.activeChunks.has(coords)) {
                                this.generateChunk(x, y, z);
                            }
                        }
                    }
                }
                
                for (const coords of this.activeChunks.keys()) {
                    if (!chunksToKeep.has(coords)) {
                        this.removeChunk(coords);
                    }
                }
            }
            
            generateChunk(x, y, z) {
                console.log(`Generando cuadrante en [${x}, ${y}, ${z}]`);
                const chunkId = `${x},${y},${z}`;
                
                const chunkObject = new THREE.Group();
                chunkObject.position.set(
                    x * this.chunkSize + this.chunkSize/2,
                    y * this.chunkSize + this.chunkSize/2,
                    z * this.chunkSize + this.chunkSize/2
                );
                
                const chunkSeed = this.getChunkSeed(x, y, z);
                
                // Generar estrellas para este cuadrante
                this.generateStars(chunkObject, chunkSeed);
                
                // Reducir la probabilidad de nebulosas al 10%
                if (this.pseudoRandom(chunkSeed + 123) < 0.10) {
                    this.generateNebula(chunkObject, chunkSeed);
                }

                // A√ëADIR ESTE BLOQUE PARA GENERAR PULSARES MP3
                // -------------------------------------------------------------------
                const pulsarChance = 0.02; 
                    if (Math.random() < pulsarChance) {
                        const pulsarId = `pulsar_${x}_${y}_${z}`;
                        if (!gestorDePulsares.activos[pulsarId]) {
                            const MIN_DISTANCE_BETWEEN_PULSARS = 1200;
                            let isTooClose = false;

                            const offsetX = (Math.random() - 0.5) * this.chunkSize * 0.8;
                            const offsetY = (Math.random() - 0.5) * this.chunkSize * 0.8;
                            const offsetZ = (Math.random() - 0.5) * this.chunkSize * 0.8;
                            const potentialPosition = new THREE.Vector3(chunkObject.position.x + offsetX, chunkObject.position.y + offsetY, chunkObject.position.z + offsetZ);

                            for (const existingPulsarId in gestorDePulsares.activos) {
                                const existingPulsar = gestorDePulsares.activos[existingPulsarId];
                                if (potentialPosition.distanceTo(existingPulsar.nebula.initialStaticPosition) < MIN_DISTANCE_BETWEEN_PULSARS) {
                                    isTooClose = true;
                                    break;
                                }
                            }

                            if (!isTooClose) {
                                console.log(`‚ú® Creando Pulsar Persistente en chunk [${x}, ${y}, ${z}]`);
                                
                                // ¬°Punto Clave! Elegimos la canci√≥n AHORA, en el nacimiento.
                                const cancionUrl = elegirSiguienteCancion();

                                // A√ëADE ESTA L√çNEA PARA AGREGAR LA CANCI√ìN A LA PLAYLIST
                                addTrackToPlaylist(`Pulsar Descubierto #${Math.floor(Math.random()*1000)}`, cancionUrl);


                                const audioElement = new Audio();
                                audioElement.crossOrigin = "anonymous";
                                audioElement.loop = true;
                                // Guardamos la URL permanentemente en el objeto del pulsar
                                audioElement.url = cancionUrl;

                                const analyserNode = audioListener.context.createAnalyser();
                                analyserNode.fftSize = 512;
                                analyserNode.smoothingTimeConstant = 0.75;
                                
                                const positionalAudio = new THREE.PositionalAudio(audioListener);
                                const radioNebula = new RadioNebula(scene, potentialPosition, analyserNode, GALAXY_PULSAR_CONFIG, 'mp3', false);
                                radioNebula.particlesObject.add(positionalAudio);

                                gestorDePulsares.activos[pulsarId] = {
                                    id: pulsarId,
                                    nebula: radioNebula,
                                    audio: audioElement,
                                    analyser: analyserNode,
                                    positionalAudio: positionalAudio,
                                    url: cancionUrl, // Guardamos la URL asignada
                                    tiempoGuardado: 0, // NUEVO: Para guardar el tiempo de reproducci√≥n
                                    mediaSource: null,
                                    isLoaded: false,
                                    isPlaying: false
                                };
                            }
                        }
                    }

                
                // Aplicar aparici√≥n gradual
                this.applyFadeInEffect(chunkObject);
                
                this.scene.add(chunkObject);
                this.activeChunks.set(chunkId, chunkObject);
            }

            
            // Aplicar efecto de aparici√≥n gradual
            applyFadeInEffect(chunkObject) {
                // Comenzar con opacidad cero
                chunkObject.traverse(object => {
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(mat => {
                                mat.transparent = true;
                                mat._originalOpacity = mat.opacity || 1.0;
                                mat.opacity = 0;
                            });
                        } else {
                            object.material.transparent = true;
                            object.material._originalOpacity = object.material.opacity || 1.0;
                            object.material.opacity = 0;
                        }
                    }
                });
                
                // Definir la duraci√≥n de la aparici√≥n gradual
                const fadeInDuration = 1000; // 1.5 segundos
                const startTime = Date.now();
                
                const fadeIn = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1, elapsedTime / fadeInDuration);
                    
                    // Aplicar opacidad gradual
                    chunkObject.traverse(object => {
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(mat => {
                                    if (mat._originalOpacity) {
                                        mat.opacity = progress * mat._originalOpacity;
                                    }
                                });
                            } else if (object.material._originalOpacity) {
                                object.material.opacity = progress * object.material._originalOpacity;
                            }
                        }
                    });
                    
                    if (progress < 1) {
                        requestAnimationFrame(fadeIn);
                    }
                };
                
                // Iniciar la animaci√≥n de aparici√≥n
                fadeIn();
            }
            
            removeChunk(chunkId) {
                const chunkObject = this.activeChunks.get(chunkId);
                if (chunkObject) {
                    // Eliminar las nebulosas asociadas de la lista de animaci√≥n
                    this.nebulaeObjects = this.nebulaeObjects.filter(nebData => {
                        return !chunkObject.children.includes(nebData.object);
                    });

                    // Iniciar el fade-out y eliminar el chunk solo cuando termine
                    this.applyFadeOutEffect(chunkObject, () => {
                        this.disposeChunkContents(chunkObject);
                        this.scene.remove(chunkObject);
                        console.log(`Eliminando cuadrante ${chunkId} despu√©s del fade-out`);
                    });

                    // Es importante eliminarlo del mapa de chunks activos inmediatamente
                    // para que no se intente eliminar de nuevo.
                    this.activeChunks.delete(chunkId);
                }
            }

            
            disposeChunkContents(chunkObject) {
                chunkObject.traverse(object => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            
            pseudoRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }
            
            getChunkSeed(x, y, z) {
                return this.chunkSeed + x * 73856093 + y * 19349663 + z * 83492791;
            }
            
            // Genera estrellas dentro del cuadrante (versi√≥n actualizada)
            generateStars(chunkObject, seed) {
                // Reducir cantidad de estrellas
                const starCount = Math.floor(this.pseudoRandom(seed) * 150) + 30; // Reducido de 500+100 a 150+50
                
                const starGeometry = new THREE.BufferGeometry();
                const starPositions = new Float32Array(starCount * 3);
                const starColors = new Float32Array(starCount * 3);
                const starSizes = new Float32Array(starCount);
                
                for (let i = 0; i < starCount; i++) {
                    const offsetX = (this.pseudoRandom(seed + i) - 0.5) * this.chunkSize;
                    const offsetY = (this.pseudoRandom(seed + i + 1000) - 0.5) * this.chunkSize;
                    const offsetZ = (this.pseudoRandom(seed + i + 2000) - 0.5) * this.chunkSize;
                    
                    starPositions[i * 3] = offsetX;
                    starPositions[i * 3 + 1] = offsetY;
                    starPositions[i * 3 + 2] = offsetZ;
                    
                    // Color y tama√±o basado en posici√≥n
                    const colorOffset = this.pseudoRandom(seed + i * 3) * 0.2;
                    starColors[i * 3] = 0.8 + colorOffset;
                    starColors[i * 3 + 1] = 0.8 + colorOffset;
                    starColors[i * 3 + 2] = 0.9 + colorOffset * 0.5;
                    
                    // Tama√±o reducido
                    starSizes[i] = 0.2 + this.pseudoRandom(seed + i * 7) * 0.5; // Reducido de 0.5+1.5 a 0.3+0.7
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
                starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: 0.2, // Reducido de 1.0 a 0.7
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true
                });
                
                const stars = new THREE.Points(starGeometry, starMaterial);
                chunkObject.add(stars);
            }
            
            // Genera una nebulosa dentro del cuadrante (versi√≥n actualizada con movimiento)
           // Versi√≥n mejorada con tama√±os de nebulosas variables

            // Modificar el m√©todo de generaci√≥n de nebulosas
            generateNebula(chunkObject, seed) {
                // Determinar el tama√±o de la nebulosa - peque√±a, mediana o grande
                const sizeCategory = this.pseudoRandom(seed + 222);
                let nebulaSizeBase, particleCount;
                
                if (sizeCategory < 0.33) {
                    // Nebulosa peque√±a (33% de probabilidad)
                    nebulaSizeBase = 30;
                    particleCount = 1500; // Menos part√≠culas para nebulosas peque√±as
                } else if (sizeCategory < 0.85) {
                    // Nebulosa mediana (52% de probabilidad)
                    nebulaSizeBase = 70;
                    particleCount = 3000; // Part√≠culas est√°ndar para nebulosas medianas
                } else {
                    // Nebulosa grande (15% de probabilidad)
                    nebulaSizeBase = 120;
                    particleCount = 5000; // M√°s part√≠culas para nebulosas grandes
                }
                
                // A√±adir variaci√≥n al tama√±o base
                const nebulaSize = nebulaSizeBase + this.pseudoRandom(seed + 333) * (nebulaSizeBase * 0.4);
                
                // Usar colores variados como en el procedural actual
                const hue = this.pseudoRandom(seed + 444); // Color aleatorio (0-1)
                const saturation = 0.6 + this.pseudoRandom(seed + 555) * 0.4; // Entre 0.6 y 1.0
                const baseLightness = 0.4 + this.pseudoRandom(seed + 666) * 0.2; // Entre 0.4 y 0.6
                
                // Crear geometr√≠a para la nebulosa
                const nebulaGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                // Distribuci√≥n de part√≠culas mejorada para n√∫cleo m√°s definido
                for (let i = 0; i < particleCount; i++) {
                    // Determinar si esta part√≠cula ser√° parte del n√∫cleo o de la regi√≥n externa
                    const isCore = this.pseudoRandom(seed + i * 15) < 0.3; // 30% de part√≠culas en el n√∫cleo
                    
                    // Radio variable seg√∫n si es n√∫cleo o regi√≥n externa
                    let radius;
                    if (isCore) {
                        // Part√≠culas del n√∫cleo m√°s concentradas
                        radius = Math.pow(this.pseudoRandom(seed + i * 10), 2.5) * nebulaSize * 0.3;
                    } else {
                        // Part√≠culas externas m√°s dispersas
                        radius = (0.3 + Math.pow(this.pseudoRandom(seed + i * 10), 1.2) * 0.7) * nebulaSize;
                    }
                    
                    // Forma esf√©rica con aplastamiento
                    const theta = this.pseudoRandom(seed + i * 20) * Math.PI * 2;
                    const phi = this.pseudoRandom(seed + i * 30) * Math.PI;
                    
                    // Distorsi√≥n para crear forma de nebulosa - var√≠a seg√∫n el tama√±o
                    // Las nebulosas peque√±as tienen menos distorsi√≥n para mantener forma compacta
                    const baseDistortion = sizeCategory < 0.33 ? 0.8 : 0.6;
                    const distortion = baseDistortion + this.pseudoRandom(seed + i * 40) * 
                                    (sizeCategory < 0.33 ? 0.4 : 0.8);
                    
                    // Coordenadas en polares
                    const x = radius * Math.sin(phi) * Math.cos(theta) * distortion;
                    const y = radius * Math.sin(phi) * Math.sin(theta) * 
                            (sizeCategory < 0.33 ? 0.7 : 0.5); // Menos aplastamiento para nebulosas peque√±as
                    const z = radius * Math.cos(phi) * distortion;
                    
                    // Posiciones
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                    
                    // Ajustar color basado en si es n√∫cleo o regi√≥n externa
                    let lightness = baseLightness;
                    let particleHue = hue;
                    
                    if (isCore) {
                        // El n√∫cleo es m√°s brillante
                        lightness += 0.2;
                        // Peque√±a variaci√≥n de tono para el n√∫cleo
                        particleHue = (hue + this.pseudoRandom(seed + i * 50) * 0.05) % 1.0;
                    } else {
                        // M√°s variaci√≥n en tono para las part√≠culas externas
                        particleHue = (hue + (this.pseudoRandom(seed + i * 50) - 0.5) * 0.15) % 1.0;
                    }
                    
                    const c = new THREE.Color().setHSL(particleHue, saturation, lightness);
                    colors[i * 3] = c.r;
                    colors[i * 3 + 1] = c.g;
                    colors[i * 3 + 2] = c.b;
                    
                    // Tama√±os variables - ajustados seg√∫n el tama√±o de la nebulosa
                    const particleSizeFactor = sizeCategory < 0.33 ? 0.8 : (sizeCategory > 0.85 ? 1.3 : 1.0);
                    
                    if (isCore) {
                        sizes[i] = (3 + Math.pow(this.pseudoRandom(seed + i * 60), 2) * 12) * particleSizeFactor;
                    } else {
                        sizes[i] = (1.5 + Math.pow(this.pseudoRandom(seed + i * 60), 2) * 8) * particleSizeFactor;
                    }
                }
                
                nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Material para nebulosa
                const nebulaMaterial = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.25,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false
                });
                
                const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
                
                // Rotaci√≥n inicial aleatoria
                nebula.rotation.x = this.pseudoRandom(seed + 777) * Math.PI;
                nebula.rotation.y = this.pseudoRandom(seed + 888) * Math.PI;
                nebula.rotation.z = this.pseudoRandom(seed + 999) * Math.PI;
                
                // Posici√≥n dentro del cuadrante - ajustar seg√∫n el tama√±o
                // Las nebulosas grandes estar√°n m√°s centradas para evitar cortes en los bordes
                const positionFactor = sizeCategory > 0.85 ? 0.5 : 0.8;
                const offsetX = (this.pseudoRandom(seed + 1111) - 0.5) * this.chunkSize * positionFactor;
                const offsetY = (this.pseudoRandom(seed + 2222) - 0.5) * this.chunkSize * positionFactor;
                const offsetZ = (this.pseudoRandom(seed + 3333) - 0.5) * this.chunkSize * positionFactor;
                nebula.position.set(offsetX, offsetY, offsetZ);
                
                // A√±adir al cuadrante
                chunkObject.add(nebula);
                
                // Par√°metros de animaci√≥n - adaptados al tama√±o
                // Las nebulosas m√°s grandes se mueven m√°s lentamente
                const speedFactor = sizeCategory > 0.85 ? 0.6 : (sizeCategory < 0.33 ? 1.3 : 1.0);
                
                const nebulaData = {
                    object: nebula,
                    // Velocidades de rotaci√≥n escaladas por tama√±o
                    rotationSpeed: {
                        x: (this.pseudoRandom(seed + 4444) - 0.5) * 0.002 * speedFactor,
                        y: (this.pseudoRandom(seed + 5555) - 0.5) * 0.002 * speedFactor,
                        z: (this.pseudoRandom(seed + 6666) - 0.5) * 0.002 * speedFactor
                    },
                    // Movimiento en elipse
                    movementPath: {
                        center: new THREE.Vector3(offsetX, offsetY, offsetZ),
                        amplitude: {
                            // Las amplitudes escalan con el tama√±o - nebulosas m√°s grandes tienen amplitudes mayores
                            x: (20 + this.pseudoRandom(seed + 7777) * 50) * (sizeCategory < 0.33 ? 0.7 : (sizeCategory > 0.85 ? 1.5 : 1.0)),
                            y: (20 + this.pseudoRandom(seed + 8888) * 50) * (sizeCategory < 0.33 ? 0.7 : (sizeCategory > 0.85 ? 1.5 : 1.0)),
                            z: (20 + this.pseudoRandom(seed + 9999) * 50) * (sizeCategory < 0.33 ? 0.7 : (sizeCategory > 0.85 ? 1.5 : 1.0))
                        },
                        phase: {
                            x: this.pseudoRandom(seed + 11111) * Math.PI * 2,
                            y: this.pseudoRandom(seed + 22222) * Math.PI * 2,
                            z: this.pseudoRandom(seed + 33333) * Math.PI * 2
                        },
                        speed: {
                            x: (this.pseudoRandom(seed + 44444) - 0.5) * 0.005 * speedFactor,
                            y: (this.pseudoRandom(seed + 55555) - 0.5) * 0.005 * speedFactor,
                            z: (this.pseudoRandom(seed + 66666) - 0.5) * 0.005 * speedFactor
                        }
                    }
                };
                
                // A√±adir a la lista de nebulosas para animaci√≥n
                this.nebulaeObjects.push(nebulaData);
            }
            
            // Animar todas las nebulosas (similar a la funci√≥n original)
            animateNebulae() {
                const time = Date.now() * 0.001; // Tiempo en segundos para movimiento suave
                
                this.nebulaeObjects.forEach(nebulaData => {
                    const { object, rotationSpeed, movementPath } = nebulaData;
                    
                    // Aplicar rotaci√≥n
                    object.rotation.x += rotationSpeed.x;
                    object.rotation.y += rotationSpeed.y;
                    object.rotation.z += rotationSpeed.z;
                    
                    // Movimiento en elipse alrededor del centro
                    object.position.x = movementPath.center.x + 
                        Math.sin(time * movementPath.speed.x + movementPath.phase.x) * movementPath.amplitude.x;
                    
                    object.position.y = movementPath.center.y + 
                        Math.cos(time * movementPath.speed.y + movementPath.phase.y) * movementPath.amplitude.y;
                    
                    object.position.z = movementPath.center.z + 
                        Math.sin(time * movementPath.speed.z + movementPath.phase.z) * movementPath.amplitude.z;
                });
            }
        }

        class HyperspaceEffect {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.active = false;
                this.speedFactor = 1.0; // Factor normal de velocidad
                this.maxSpeedFactor = 10.0; // Velocidad m√°xima (10x)
                this.acceleration = 0.2; // Tasa de aceleraci√≥n
                this.deceleration = 0.4; // Tasa de desaceleraci√≥n (m√°s r√°pida que la aceleraci√≥n)
                this.targetSpeedFactor = 1.0;
                
                // Efecto de estrellas de velocidad
                this.speedLinesCount = 300;
                this.speedLinesObject = null;
                this.speedLinesVisible = false;
                
                // Sonido de hipervelocidad (opcional)
                this.hyperspaceSound = null;
                this.soundInitialized = false;
                
                // Crear el efecto visual
                this.createSpeedLines();
                
                // Opcionalmente inicializar sonido
                this.initializeSound();
            }
            
            // Activar/desactivar el modo hipervelocidad
            toggleHyperspace(enabled) {
                this.active = enabled;
                this.targetSpeedFactor = enabled ? this.maxSpeedFactor : 1.0;
                
                // Si est√° activo, mostrar las l√≠neas de velocidad
                if (enabled && !this.speedLinesVisible) {
                    this.showSpeedLines();
                }
                
                // Activar/desactivar sonido
                if (this.soundInitialized) {
                    if (enabled && !this.hyperspaceSound.isPlaying) {
                        this.hyperspaceSound.play();
                    }
                }
            }
            
            // Actualizar el efecto (llamar desde el loop de animaci√≥n)
            update(playerDirection) {
                // Ajustar velocidad actual gradualmente
                if (this.active && this.speedFactor < this.targetSpeedFactor) {
                    this.speedFactor += this.acceleration;
                    if (this.speedFactor > this.targetSpeedFactor) {
                        this.speedFactor = this.targetSpeedFactor;
                    }
                } else if (!this.active && this.speedFactor > this.targetSpeedFactor) {
                    this.speedFactor -= this.deceleration;
                    if (this.speedFactor < this.targetSpeedFactor) {
                        this.speedFactor = this.targetSpeedFactor;
                    }
                }
                
                // Si ya desaceler√≥ completamente, ocultar las l√≠neas de velocidad
                if (!this.active && this.speedFactor <= 1.1 && this.speedLinesVisible) {
                    this.hideSpeedLines();
                }
                
                // Actualizar el efecto visual de l√≠neas de velocidad
                if (this.speedLinesVisible) {
                    this.updateSpeedLines(playerDirection);
                }
                
                // Actualizar sonido si est√° activo
                if (this.soundInitialized && this.hyperspaceSound.isPlaying) {
                    // Ajustar volumen y pitch basado en velocidad
                    const speedRatio = (this.speedFactor - 1.0) / (this.maxSpeedFactor - 1.0);
                    this.hyperspaceSound.volume = Math.min(0.7, speedRatio * 0.7);
                    
                    // Si ya no est√° en hipervelocidad y el sonido casi desaparece, detenerlo
                    if (!this.active && speedRatio < 0.1) {
                        this.hyperspaceSound.stop();
                    }
                }
                
                // Devolver el factor de velocidad actual para que sea usado por el movimiento
                return this.speedFactor;
            }
            
            // Crear las l√≠neas de velocidad (inicialmente ocultas)
            createSpeedLines() {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.speedLinesCount * 3);
                const colors = new Float32Array(this.speedLinesCount * 3);
                const sizes = new Float32Array(this.speedLinesCount);
                const speedParams = new Float32Array(this.speedLinesCount * 2); // Longitud y velocidad
                
                // Generar posiciones iniciales en forma de hemisferio delante del jugador
                for (let i = 0; i < this.speedLinesCount; i++) {
                    // Posici√≥n inicial aleatoria en un hemisferio
                    const theta = Math.random() * Math.PI * 2; // √Ångulo horizontal
                    const phi = Math.random() * Math.PI / 2; // √Ångulo vertical (solo hemisferio frontal)
                    const r = 5 + Math.random() * 95; // Radio entre 5 y 100
                    
                    // Coordenadas esf√©ricas a cartesianas
                    positions[i * 3] = -r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = r * Math.cos(phi);
                    positions[i * 3 + 2] = -r * Math.sin(phi) * Math.sin(theta);
                    
                    // Color azulado con variaci√≥n para efecto de velocidad
                    const blueIntensity = 0.5 + Math.random() * 0.5;
                    colors[i * 3] = 0.7; // R
                    colors[i * 3 + 1] = 0.8; // G
                    colors[i * 3 + 2] = blueIntensity; // B (azul m√°s intenso)
                    
                    // Tama√±o de la l√≠nea (variar para diversidad)
                    sizes[i] = 0.5 + Math.random() * 1.5;
                    
                    // Par√°metros de velocidad y longitud
                    speedParams[i * 2] = 0.5 + Math.random() * 2.5; // Longitud de estela
                    speedParams[i * 2 + 1] = 0.5 + Math.random() * 1.5; // Velocidad relativa
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Crear textura para las l√≠neas
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 16;
                const ctx = canvas.getContext('2d');
                
                // Dibujar l√≠nea con degradado
                const grd = ctx.createLinearGradient(0, 8, 64, 8);
                grd.addColorStop(0, "rgba(255, 255, 255, 1.0)");
                grd.addColorStop(1, "rgba(255, 255, 255, 0.0)");
                
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, 64, 16);
                
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                
                // Material para las l√≠neas de velocidad
                const material = new THREE.PointsMaterial({
                    size: 2.0,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0,  // Inicialmente invisible
                    map: texture,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                // Crear el objeto y a√±adirlo a la escena (inicialmente invisible)
                this.speedLinesObject = new THREE.Points(geometry, material);
                this.speedLinesObject.frustumCulled = false; // Evitar que desaparezca fuera del frustum
                this.scene.add(this.speedLinesObject);
                
                // Guardar referencia a los atributos para animaci√≥n
                this.speedLinesPositions = geometry.attributes.position;
                this.speedLinesColors = geometry.attributes.color;
                this.speedLinesSizes = geometry.attributes.size;
                this.speedParams = speedParams;
            }
            
            // Mostrar las l√≠neas de velocidad con fade in
            showSpeedLines() {
                if (!this.speedLinesObject) return;
                this.speedLinesVisible = true;
                
                // Hacer aparecer gradualmente
                const material = this.speedLinesObject.material;
                const startOpacity = material.opacity;
                const targetOpacity = 0.7;
                const duration = 500; // ms
                const startTime = Date.now();
                
                const fadeIn = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1.0, elapsedTime / duration);
                    
                    material.opacity = startOpacity + (targetOpacity - startOpacity) * progress;
                    
                    if (progress < 1.0) {
                        requestAnimationFrame(fadeIn);
                    }
                };
                
                fadeIn();
            }
            
            // Ocultar las l√≠neas de velocidad con fade out
            hideSpeedLines() {
                if (!this.speedLinesObject) return;
                
                // Hacer desaparecer gradualmente
                const material = this.speedLinesObject.material;
                const startOpacity = material.opacity;
                const targetOpacity = 0.0;
                const duration = 500; // ms
                const startTime = Date.now();
                
                const fadeOut = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1.0, elapsedTime / duration);
                    
                    material.opacity = startOpacity + (targetOpacity - startOpacity) * progress;
                    
                    if (progress < 1.0) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        this.speedLinesVisible = false;
                    }
                };
                
                fadeOut();
            }
            
            // Actualizar la posici√≥n y apariencia de las l√≠neas de velocidad
            updateSpeedLines(playerDirection) {
                if (!this.speedLinesObject || !this.speedLinesVisible) return;
                
                // Obtener la direcci√≥n en la que est√° mirando el jugador
                const forward = playerDirection.clone().normalize();
                
                // Crear un sistema de coordenadas local
                const up = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3().crossVectors(forward, up).normalize();
                up.crossVectors(right, forward);
                
                // Efecto incremental con velocidad
                const speedEffect = this.speedFactor / this.maxSpeedFactor;
                const positions = this.speedLinesPositions.array;
                const sizes = this.speedLinesSizes.array;
                const colors = this.speedLinesColors.array;
                
                for (let i = 0; i < this.speedLinesCount; i++) {
                    // Obtener posici√≥n actual
                    const px = positions[i * 3];
                    const py = positions[i * 3 + 1];
                    const pz = positions[i * 3 + 2];
                    
                    // Mover hacia atr√°s (efecto de estela)
                    const speed = this.speedParams[i * 2 + 1] * this.speedFactor * 0.2;
                    positions[i * 3] -= forward.x * speed;
                    positions[i * 3 + 1] -= forward.y * speed;
                    positions[i * 3 + 2] -= forward.z * speed;
                    
                    // Si la l√≠nea se fue muy lejos, reiniciarla al frente
                    const distanceToCamera = Math.sqrt(
                        px * px + py * py + pz * pz
                    );
                    
                    if (distanceToCamera > 120) {
                        // Nueva posici√≥n en un c√≠rculo delante del jugador
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 5 + Math.random() * 15;
                        
                        positions[i * 3] = right.x * Math.cos(angle) * radius + 
                                        up.x * Math.sin(angle) * radius + 
                                        forward.x * (-10 - Math.random() * 20);
                                        
                        positions[i * 3 + 1] = right.y * Math.cos(angle) * radius + 
                                            up.y * Math.sin(angle) * radius + 
                                            forward.y * (-10 - Math.random() * 20);
                                            
                        positions[i * 3 + 2] = right.z * Math.cos(angle) * radius + 
                                            up.z * Math.sin(angle) * radius + 
                                            forward.z * (-10 - Math.random() * 20);
                    }
                    
                    // Ajustar tama√±o basado en velocidad
                    sizes[i] = (0.5 + Math.random() * 0.5) * (1 + speedEffect * this.speedParams[i * 2] * 2);
                    
                    // Ajustar color (m√°s azul a mayor velocidad)
                    colors[i * 3 + 2] = Math.min(1.0, 0.7 + speedEffect * 0.3);
                }
                
                // Marcar atributos para actualizaci√≥n
                this.speedLinesPositions.needsUpdate = true;
                this.speedLinesSizes.needsUpdate = true;
                this.speedLinesColors.needsUpdate = true;
                
                // Alinear con la c√°mara (estrategia de billboarding)
                this.speedLinesObject.quaternion.copy(this.camera.quaternion);
            }
            
            // Inicializar sonido (si Three.js Audio est√° disponible)
            initializeSound() {
                if (typeof THREE.Audio === 'undefined') return;
                
                try {
                    // Crear listener de audio y a√±adirlo a la c√°mara
                    const listener = new THREE.AudioListener();
                    this.camera.add(listener);
                    
                    // Crear fuente de sonido
                    this.hyperspaceSound = new THREE.Audio(listener);
                    
                    // Crear buffer de audio con ruido blanco filtrado
                    const context = listener.context;
                    const bufferSize = 2 * context.sampleRate;
                    const buffer = context.createBuffer(1, bufferSize, context.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Generar ruido con m√°s bajas frecuencias (tipo "whoosh")
                    let lastOut = 0.0;
                    for (let i = 0; i < bufferSize; i++) {
                        // Ruido blanco filtrado para efecto de viento espacial
                        const white = Math.random() * 2 - 1;
                        // Filtro paso bajo simple
                        lastOut = (lastOut + (0.02 * white)) / 1.02;
                        data[i] = lastOut * 3.5; // Amplificaci√≥n
                    }
                    
                    // Configurar el sonido
                    this.hyperspaceSound.setBuffer(buffer);
                    this.hyperspaceSound.setLoop(true);
                    this.hyperspaceSound.setVolume(0);
                    
                    this.soundInitialized = true;
                } catch (e) {
                    console.error("Error initializing hyperspace sound:", e);
                }
            }
            
            // Limpiar recursos al destruir
            dispose() {
                if (this.speedLinesObject) {
                    if (this.speedLinesObject.geometry) {
                        this.speedLinesObject.geometry.dispose();
                    }
                    if (this.speedLinesObject.material) {
                        if (this.speedLinesObject.material.map) {
                            this.speedLinesObject.material.map.dispose();
                        }
                        this.speedLinesObject.material.dispose();
                    }
                    this.scene.remove(this.speedLinesObject);
                }
                
                if (this.hyperspaceSound && this.hyperspaceSound.isPlaying) {
                    this.hyperspaceSound.stop();
                }
            }
        }

        class RadioNebula {
            constructor(scene, initialStaticPosition, analyser, initialConfig, type = 'mp3', isMajestic = false) {
                this.scene = scene;
                this.initialStaticPosition = initialStaticPosition.clone(); 
                this.analyser = analyser;
                this.config = initialConfig; 
                this.type = type; 
                this.isMajestic = isMajestic; 

                this.orbitCenter = this.initialStaticPosition.clone(); 
                this.orbitAmplitude = new THREE.Vector3(80 + Math.random() * 70, 20 + Math.random() * 30, 80 + Math.random() * 70);
                this.orbitPhase = new THREE.Vector3(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
// Aumentamos la velocidad base para que sea un poco m√°s r√°pida que las nebulosas
                this.orbitSpeed = new THREE.Vector3(
                                    (Math.random() - 0.5) * 0.007, 
                                    (Math.random() - 0.5) * 0.004,
                                    (Math.random() - 0.5) * 0.007
                                );
                this.currentDynamicPosition = this.initialStaticPosition.clone(); 

                this.baseColorPalette = (type === 'tagua_tagua') ? TAGUA_TAGUA_BASE_COLORS_HSL : MAJESTIC_NEBULA_COLORS_HSL; 
                this.coreColorPalette = (type === 'tagua_tagua') ? TAGUA_TAGUA_CORE_COLORS_HSL : CORE_PULSATING_COLORS_HSL; 

                this.bufferLength = this.analyser.frequencyBinCount;
                this.particleCount = 12000; 
                if (this.isMajestic) this.particleCount = 15000; 

                this.particlesObject = new THREE.Object3D();
                this.particlesObject.position.copy(this.currentDynamicPosition); 
                this.scene.add(this.particlesObject);
                this.geometry = new THREE.BufferGeometry();
                
                this.currentBaseColorIndex = Math.floor(Math.random() * this.baseColorPalette.length);
                this.targetBaseColorIndex = this.currentBaseColorIndex;
                this.colorTransitionProgress = 1;
                
                this.currentCoreColorIndex = Math.floor(Math.random() * this.coreColorPalette.length);
                this.targetCoreColorIndex = this.currentCoreColorIndex;
                this.coreColorTransitionProgress = 1;
                this.currentCoronaColorIndex = 0; 

                const particleTexture = this.createParticleTexture(); 
                this.material = new THREE.PointsMaterial({
                    map: particleTexture,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9, 
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    sizeAttenuation: true, 
                    size: 1.0, 
                    alphaTest: 0.05 
                });
                this.maxExpansionRadius = this.config.baseSize;
                this.coreRadius = this.config.baseSize * 0.15;
                this.coronaRadius = this.isMajestic ? this.config.baseSize * 0.35 : 0; 
                this.coronaParticleRatio = this.isMajestic ? 0.15 : 0; 

                this.baseRotationSpeed = new THREE.Vector3(0.0007, 0.0012, 0.0005);
                this.particleAttributes = {
                    positions: new Float32Array(this.particleCount * 3), colors: new Float32Array(this.particleCount * 3),
                    targetColors: new Float32Array(this.particleCount * 3), alphas: new Float32Array(this.particleCount),
                    sizes: new Float32Array(this.particleCount), velocities: new Float32Array(this.particleCount * 3),
                    lifetimes: new Float32Array(this.particleCount), initialDistances: new Float32Array(this.particleCount),
                    isCoreParticle: new Uint8Array(this.particleCount), 
                    isTracerParticle: new Uint8Array(this.particleCount),
                    isCoronaParticle: this.isMajestic ? new Uint8Array(this.particleCount) : null 
                };
                 // A√ëADIR ESTAS NUEVAS PROPIEDADES AL CONSTRUCTOR DE RadioNebula
                // ----------------------------------------------------
                this.userDragOffset = new THREE.Vector3(0, 0, 0); // Desplazamiento temporal por arrastre
                this.momentumVelocity = new THREE.Vector3(0, 0, 0); // Velocidad para el efecto de inercia
                this.isBeingDragged = false; // Bandera para saber si est√° siendo arrastrado
                // ----------------------------------------------------

                this._initParticles();

                this.points = new THREE.Points(this.geometry, this.material);
                this.particlesObject.add(this.points);
                this.lastUpdateTime = Date.now();
                this.lastColorChangeTime = Date.now();
                this.lastCoreColorChangeTime = Date.now();
                const heartGeometry = new THREE.SphereGeometry(this.coreRadius * 0.25, 12, 8);
                const heartMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff, emissive: 0x555555, transparent: true, opacity: 0.15,
                    blending: THREE.AdditiveBlending, shininess: 50, specular: 0xaaaaaa
                });
                this.nebulaHeart = new THREE.Mesh(heartGeometry, heartMaterial);
                this.particlesObject.add(this.nebulaHeart);
                 // --- PEGA EL BLOQUE QUE CORTASTE JUSTO AQU√ç ---
                const clickTargetGeometry = new THREE.SphereGeometry(this.maxExpansionRadius * 0.6, 16, 16);
                const clickTargetMaterial = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide }); // Invisible
                this.nebulaClickTarget = new THREE.Mesh(clickTargetGeometry, clickTargetMaterial);
                this.nebulaClickTarget.parentNebula = this; // Creamos una referencia para saber a qui√©n pertenece
                this.nebulaClickTarget.layers.set(CLICKABLE_LAYER); // <-- A√ëADE ESTA L√çNEA

                this.particlesObject.add(this.nebulaClickTarget);
                // --- HASTA AQU√ç ---
            }

            updateOrbitalPosition(time) {
                // 1. Calculamos la posici√≥n orbital base (como antes)
                const baseOrbitX = this.orbitCenter.x + Math.sin(time * this.orbitSpeed.x + this.orbitPhase.x) * this.orbitAmplitude.x;
                const baseOrbitY = this.orbitCenter.y + Math.cos(time * this.orbitSpeed.y + this.orbitPhase.y) * this.orbitAmplitude.y;
                const baseOrbitZ = this.orbitCenter.z + Math.sin(time * this.orbitSpeed.z + this.orbitPhase.z) * this.orbitAmplitude.z;

                // 2. Aplicamos la f√≠sica de momentum y retorno (¬°la nueva magia!)
                //    Esto solo se ejecuta si NO estamos arrastrando el p√∫lsar.
                if (!this.isBeingDragged) {
                    // Aplicamos la velocidad del momentum que guardamos al arrastrar
                    this.userDragOffset.add(this.momentumVelocity);
                    // Frenamos el momentum un 5% en cada fotograma (amortiguaci√≥n)
                    this.momentumVelocity.multiplyScalar(0.95);
                    // Atraemos el p√∫lsar de vuelta a su √≥rbita original (efecto goma el√°stica)
                    this.userDragOffset.lerp(new THREE.Vector3(0, 0, 0), 0.02);
                }

                // 3. La posici√≥n final es la √≥rbita base + nuestro desplazamiento temporal
                this.currentDynamicPosition.set(
                    baseOrbitX + this.userDragOffset.x,
                    baseOrbitY + this.userDragOffset.y,
                    baseOrbitZ + this.userDragOffset.z
                );

                // 4. Actualizamos la posici√≥n del objeto en la escena
                this.particlesObject.position.copy(this.currentDynamicPosition);
            }




            applyConfigChange() {
                this.maxExpansionRadius = this.config.baseSize;
                this.coreRadius = this.config.baseSize * 0.15;
                if (this.nebulaHeart) {
                    this.nebulaHeart.geometry.dispose();
                    this.nebulaHeart.geometry = new THREE.SphereGeometry(this.coreRadius * 0.25, 12, 8);
                }
                if (this.isMajestic) {
                    this.coronaRadius = this.config.baseSize * 0.35;
                }
            }

            createParticleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 128; 
                canvas.height = 128;
                const context = canvas.getContext('2d');
                context.fillStyle = 'rgba(0,0,0,0)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = canvas.width / 2 - 2;
                const gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.7, 'rgba(255,255,255,0.9)');
                gradient.addColorStop(0.9, 'rgba(255,255,255,0.3)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                context.beginPath();
                context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
                context.fillStyle = gradient;
                context.fill();
                const innerGradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 0.5 );
                innerGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
                innerGradient.addColorStop(1, 'rgba(255,255,255,0)');
                context.beginPath();
                context.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2, false);
                context.fillStyle = innerGradient;
                context.fill();
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true; 
                return texture;
            }


            _initParticles() {
                const { positions, colors, targetColors, alphas, sizes, velocities, lifetimes, initialDistances, isCoreParticle, isTracerParticle, isCoronaParticle } = this.particleAttributes;
                for (let i = 0; i < this.particleCount; i++) { this._spawnParticle(i); }
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            }

            _spawnParticle(i, forceCore = false) {
                const { positions, colors, targetColors, alphas, sizes, velocities, lifetimes, initialDistances, isCoreParticle, isTracerParticle, isCoronaParticle } = this.particleAttributes;
                const i3 = i * 3; let r;
                
                isCoreParticle[i] = 0;
                isTracerParticle[i] = 0;
                if (this.isMajestic && isCoronaParticle) isCoronaParticle[i] = 0;

                if (this.isMajestic && Math.random() < this.coronaParticleRatio) {
                    if(isCoronaParticle) isCoronaParticle[i] = 1;
                    r = this.coreRadius * 0.8 + Math.random() * (this.coronaRadius - this.coreRadius * 0.8); 
                } else if (forceCore || Math.random() < (0.10 + Math.random() * 0.08)) {
                    isCoreParticle[i] = 1;
                    r = Math.pow(Math.random(), 3.0) * this.coreRadius;
                } else {
                    const peripheryFactor = 0.80;
                    r = this.coreRadius + Math.pow(Math.random(), 1.4) * (this.maxExpansionRadius * peripheryFactor - this.coreRadius);
                    if (!isCoreParticle[i] && (!this.isMajestic || (isCoronaParticle && !isCoronaParticle[i])) && Math.random() < 0.008) { 
                        isTracerParticle[i] = 1;
                    }
                }
                
                initialDistances[i] = r;
                const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                positions[i3] = r * Math.sin(phi) * Math.cos(theta); positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta); positions[i3 + 2] = r * Math.cos(phi);
                
                let chosenColorHSL; let finalColor = new THREE.Color();

                if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                    chosenColorHSL = MAJESTIC_CORONA_COLORS_HSL[this.currentCoronaColorIndex % MAJESTIC_CORONA_COLORS_HSL.length];
                    finalColor.setHSL(chosenColorHSL.h, chosenColorHSL.s, chosenColorHSL.l * (0.8 + Math.random() * 0.4)); 
                    alphas[i] = 0.3 + Math.random() * 0.4; 
                    sizes[i] = 2.5 + Math.random() * 3.0; 
                } else if (isTracerParticle[i]) {
                    const tracerBaseColor = this.baseColorPalette[this.currentBaseColorIndex % this.baseColorPalette.length];
                    chosenColorHSL = { h: (tracerBaseColor.h + 0.4) % 1, s: 0.08, l: 0.95 }; 
                    finalColor.setHSL(chosenColorHSL.h, chosenColorHSL.s, chosenColorHSL.l + (Math.random()-0.5)*0.015); alphas[i] = 0.01 + Math.random() * 0.20;
                    sizes[i] = 3.0 + Math.random() * 2.5;
                } else if (isCoreParticle[i]) {
                    chosenColorHSL = this.coreColorPalette[this.currentCoreColorIndex % this.coreColorPalette.length];
                    const coreLuminosity = chosenColorHSL.l + (Math.random() - 0.5) * 0.005;
                    finalColor.setHSL(chosenColorHSL.h, chosenColorHSL.s, coreLuminosity); alphas[i] = 0.5 + Math.random() * 0.3;
                    sizes[i] = 0.7 + Math.random() * 2.0;
                } else { 
                    chosenColorHSL = this.baseColorPalette[this.currentBaseColorIndex % this.baseColorPalette.length];
                    finalColor.setHSL(chosenColorHSL.h, chosenColorHSL.s, chosenColorHSL.l + (Math.random()-0.5)*0.015); alphas[i] = 0.01 + Math.random() * 0.20;
                    sizes[i] = 0.7 + Math.random() * 2.0;
                }
                colors[i3] = finalColor.r; colors[i3 + 1] = finalColor.g; colors[i3 + 2] = finalColor.b;
                targetColors[i3] = finalColor.r; targetColors[i3+1] = finalColor.g; targetColors[i3+2] = finalColor.b;
                
                const speedFactor = (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) ? (0.005 + Math.random() * 0.02) : (0.015 + Math.random() * 0.08); 
                 if (r > 0.01) { velocities[i3] = positions[i3] / r * speedFactor * 0.015; velocities[i3 + 1] = positions[i3 + 1] / r * speedFactor * 0.015; velocities[i3 + 2] = positions[i3 + 2] / r * speedFactor * 0.015;} 
                 else { velocities[i3] = (Math.random() - 0.5) * 0.0015; velocities[i3+1] = (Math.random() - 0.5) * 0.0015; velocities[i3+2] = (Math.random() - 0.5) * 0.0015;}
                velocities[i3] += (Math.random() - 0.5) * 0.01; velocities[i3 + 1] += (Math.random() - 0.5) * 0.01; velocities[i3 + 2] += (Math.random() - 0.5) * 0.01;
                lifetimes[i] = (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) ? (15 + Math.random() * 10) : (7 + Math.random() * 15); 
            }

            update(currentFrequencyData, currentTimeDomainData, deltaTime) { 
                 if (!this.analyser || !this.points) return;
                const now = Date.now();
                this.analyser.getByteFrequencyData(currentFrequencyData);
                this.analyser.getByteTimeDomainData(currentTimeDomainData);

                let sumAmplitudes = 0;
                for (let i = 0; i < currentTimeDomainData.length; i++) { sumAmplitudes += Math.abs(currentTimeDomainData[i] - 128); }
                const averageVolume = Math.min(1, (sumAmplitudes / currentTimeDomainData.length) / 40);
                
                const bass = (currentFrequencyData[Math.floor(this.bufferLength * 0.005)] + currentFrequencyData[Math.floor(this.bufferLength * 0.025)]) / 2 / 255;
                const mids = (currentFrequencyData[Math.floor(this.bufferLength * 0.12)] + currentFrequencyData[Math.floor(this.bufferLength * 0.22)]) / 2 / 255;
                const highs = (currentFrequencyData[Math.floor(this.bufferLength * 0.35)]+ currentFrequencyData[Math.floor(this.bufferLength * 0.50)]) / 2 / 255;

                const effectiveRotationSpeed = this.config.rotationSpeedFactor / 0.0012;
                this.particlesObject.rotation.x += this.baseRotationSpeed.x * effectiveRotationSpeed * deltaTime * (0.08 + averageVolume * 0.25);
                this.particlesObject.rotation.y += this.baseRotationSpeed.y * effectiveRotationSpeed * deltaTime * (0.08 + averageVolume * 0.5);
                this.particlesObject.rotation.z += this.baseRotationSpeed.z * effectiveRotationSpeed * deltaTime * (0.08 + averageVolume * 0.25);
                const pulseCycle = now * 0.001 * (0.5 + this.config.pulseSpeedFactor * 50);
                const easedVolume = (Math.sin(pulseCycle - Math.PI / 2) + 1) / 2 * averageVolume;
                const targetExpansionFactor = 0.20 + easedVolume * this.config.pulseIntensity;
                this.currentExpansionFactor = this.currentExpansionFactor === undefined ? 1 : this.currentExpansionFactor;
                this.currentExpansionFactor = THREE.MathUtils.lerp(this.currentExpansionFactor, targetExpansionFactor, this.config.pulseSpeedFactor);
                
                const coreTargetColor = this.coreColorPalette[this.currentCoreColorIndex % this.coreColorPalette.length]; 
                const heartLuminosity = Math.min(0.80, coreTargetColor.l * (0.3 + averageVolume * 0.7) + bass * this.config.coreBrightness);
                this.nebulaHeart.material.color.setHSL(coreTargetColor.h, coreTargetColor.s * 0.75, heartLuminosity);
                this.nebulaHeart.material.emissive.setHSL(coreTargetColor.h, coreTargetColor.s * 0.75, heartLuminosity * 0.4);
                this.nebulaHeart.material.opacity = THREE.MathUtils.lerp(this.nebulaHeart.material.opacity, 0.02 + bass * 0.20 + averageVolume * 0.10, 0.035);
                const heartScale = 0.6 + averageVolume * 1.0 + bass * 0.7;
                this.nebulaHeart.scale.set(heartScale, heartScale, heartScale);

                const colorChangeInterval = 11000 + Math.random()*2500;
                if (now - this.lastColorChangeTime > colorChangeInterval) {
                    this.targetBaseColorIndex = (this.currentBaseColorIndex + 1 + Math.floor(Math.random()*(this.baseColorPalette.length-1))) % this.baseColorPalette.length;
                    if (this.targetBaseColorIndex === this.currentBaseColorIndex && this.baseColorPalette.length > 1) { this.targetBaseColorIndex = (this.targetBaseColorIndex + 1) % this.baseColorPalette.length;}
                    this.colorTransitionProgress = 0; this.lastColorChangeTime = now;
                }
                if (this.colorTransitionProgress < 1) { this.colorTransitionProgress = Math.min(1, this.colorTransitionProgress + deltaTime * this.config.outerColorSpeed); } else { this.currentBaseColorIndex = this.targetBaseColorIndex; }
                
                const coreColorChangeInterval = 2500 + Math.random() * 800;
                if (now - this.lastCoreColorChangeTime > coreColorChangeInterval) {
                    this.targetCoreColorIndex = (this.currentCoreColorIndex + 1) % this.coreColorPalette.length;
                    this.coreColorTransitionProgress = 0; this.lastCoreColorChangeTime = now;
                }
                 if (this.coreColorTransitionProgress < 1) { this.coreColorTransitionProgress = Math.min(1, this.coreColorTransitionProgress + deltaTime * this.config.coreColorSpeed); } else { this.currentCoreColorIndex = this.targetCoreColorIndex; }

                if (this.isMajestic) { 
                    const coronaColorChangeInterval = 7000 + Math.random() * 2000; 
                    if (now - (this.lastCoronaColorChangeTime || 0) > coronaColorChangeInterval) {
                        this.currentCoronaColorIndex = (this.currentCoronaColorIndex + 1) % MAJESTIC_CORONA_COLORS_HSL.length;
                        this.lastCoronaColorChangeTime = now;
                    }
                }

                const { positions, colors, alphas, sizes, velocities, lifetimes, initialDistances, isCoreParticle, isTracerParticle, isCoronaParticle } = this.particleAttributes;
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3; lifetimes[i] -= deltaTime;
                    if (lifetimes[i] <= 0) { 
                        let forceCoreOnRespawn = false; if (averageVolume > 0.05) { forceCoreOnRespawn = Math.random() < (averageVolume * 0.45); } 
                        this._spawnParticle(i, forceCoreOnRespawn); continue; 
                    }
                    
                    velocities[i3] = THREE.MathUtils.lerp(velocities[i3], (Math.random() - 0.5) * 0.006 * (1 + bass*2.5), 0.035);
                    velocities[i3+1] = THREE.MathUtils.lerp(velocities[i3+1], (Math.random() - 0.5) * 0.006 * (1 + bass*2.5), 0.035);
                    velocities[i3+2] = THREE.MathUtils.lerp(velocities[i3+2], (Math.random() - 0.5) * 0.006 * (1 + bass*2.5), 0.035);
                    
                    positions[i3] += velocities[i3] * deltaTime * (1 + averageVolume * 28); 
                    positions[i3 + 1] += velocities[i3 + 1] * deltaTime * (1 + averageVolume * 28); 
                    positions[i3 + 2] += velocities[i3 + 2] * deltaTime * (1 + averageVolume * 28);
                    
                     const currentDist = Math.sqrt(positions[i3]**2 + positions[i3+1]**2 + positions[i3+2]**2);
                    let expansionLimitFactor = 1.0;
                    if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                        expansionLimitFactor = 1.1; 
                    } else if (isCoreParticle[i]) {
                        expansionLimitFactor = 1.0;
                    } else if (isTracerParticle[i]) {
                        expansionLimitFactor = 0.95;
                    } else { 
                        expansionLimitFactor = 0.88;
                    }

                    if (currentDist > 0.01) { 
                        const desiredDist = initialDistances[i] * this.currentExpansionFactor * expansionLimitFactor; 
                        const scaleToApply = THREE.MathUtils.lerp(1, desiredDist / currentDist, 0.018); 
                        positions[i3] *= scaleToApply; positions[i3+1] *= scaleToApply; positions[i3+2] *= scaleToApply;
                    }
                    
                    let sourceColorHSL, targetColorHSL, transitionProg; 
                    let currentParticleColor = new THREE.Color(colors[i3], colors[i3+1], colors[i3+2]); 
                    let finalTargetColor = new THREE.Color();

                    if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                        const coronaBaseColor = MAJESTIC_CORONA_COLORS_HSL[this.currentCoronaColorIndex % MAJESTIC_CORONA_COLORS_HSL.length];
                        finalTargetColor.setHSL(
                            coronaBaseColor.h,
                            coronaBaseColor.s,
                            coronaBaseColor.l * (0.7 + averageVolume * 0.5 + highs * 0.3) 
                        );
                    } else if(isTracerParticle[i]) { 
                        const tracerBaseColor = this.baseColorPalette[this.currentBaseColorIndex % this.baseColorPalette.length];
                        const tracerActualHSL = {h: (tracerBaseColor.h + 0.4 + i*0.0001) % 1, s:0.02 + Math.random()*0.05, l:0.80 + Math.random()*0.1}; 
                        finalTargetColor.setHSL(tracerActualHSL.h, tracerActualHSL.s, tracerActualHSL.l);
                    } else if(isCoreParticle[i]) {
                        sourceColorHSL = this.coreColorPalette[this.currentCoreColorIndex % this.coreColorPalette.length]; 
                        targetColorHSL = this.coreColorPalette[this.targetCoreColorIndex % this.coreColorPalette.length]; 
                        transitionProg = this.coreColorTransitionProgress;
                        const h = THREE.MathUtils.lerp(sourceColorHSL.h, targetColorHSL.h, transitionProg); 
                        const s = THREE.MathUtils.lerp(sourceColorHSL.s, targetColorHSL.s, transitionProg);
                        let l = THREE.MathUtils.lerp(sourceColorHSL.l, targetColorHSL.l, transitionProg); 
                        l = Math.min(0.85 * this.config.coreBrightness, l + averageVolume * this.config.colorIntensityAudio + bass * (this.config.colorIntensityAudio * 0.8)); 
                        finalTargetColor.setHSL(h,s,l);
                    } else { 
                        sourceColorHSL = this.baseColorPalette[this.currentBaseColorIndex % this.baseColorPalette.length]; 
                        targetColorHSL = this.baseColorPalette[this.targetBaseColorIndex % this.baseColorPalette.length]; 
                        transitionProg = this.colorTransitionProgress;
                        const h = THREE.MathUtils.lerp(sourceColorHSL.h, targetColorHSL.h, transitionProg); 
                        const s = THREE.MathUtils.lerp(sourceColorHSL.s, targetColorHSL.s, transitionProg);
                        let l = THREE.MathUtils.lerp(sourceColorHSL.l, targetColorHSL.l, transitionProg); 
                        l = Math.min(0.70, l + averageVolume * (this.config.colorIntensityAudio * 0.8) + mids * (this.config.colorIntensityAudio*0.5));
                        
                        const coreColorForInfluence = this.coreColorPalette[this.currentCoreColorIndex % this.coreColorPalette.length];
                        const coreColorNow = new THREE.Color().setHSL(
                            coreColorForInfluence.h, 
                            coreColorForInfluence.s * 0.7, 
                            Math.min(0.80 * this.config.coreBrightness, coreColorForInfluence.l + averageVolume * (this.config.colorIntensityAudio*0.4))
                        );
                        const coreInfluence = Math.max(0, 1 - (initialDistances[i] / (this.coreRadius * 4.5))) * (0.08 + bass * 0.18) ; 
                        finalTargetColor.setHSL(h,s,l).lerp(coreColorNow, coreInfluence);
                    }
                    colors[i3] = THREE.MathUtils.lerp(currentParticleColor.r, finalTargetColor.r, 0.028); 
                    colors[i3 + 1] = THREE.MathUtils.lerp(currentParticleColor.g, finalTargetColor.g, 0.028); 
                    colors[i3 + 2] = THREE.MathUtils.lerp(currentParticleColor.b, finalTargetColor.b, 0.028);
                    
                    let targetSize;
                    if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                        targetSize = (3.0 + averageVolume * 4.0 + highs * 3.0) * (0.5 + Math.random() * 0.5); 
                        targetSize = Math.max(1.0, Math.min(targetSize, 15.0));
                    } else {
                        targetSize = (isTracerParticle[i] ? 4.0 : 2.2) + averageVolume * 6.5 + bass * 5.5 + highs * 4.0; 
                        targetSize *= (0.25 + Math.random() * 0.45);
                        let maxParticleSizeGeneral = isTracerParticle[i] ? 9.0 : 16.0; if (isCoreParticle[i]) { maxParticleSizeGeneral = 12.0; } 
                        targetSize = Math.max(0.08, Math.min(targetSize, maxParticleSizeGeneral));
                    }
                    sizes[i] = THREE.MathUtils.lerp(sizes[i], targetSize, 0.018);
                    
                    const lifeRatio = Math.max(0, lifetimes[i] / ( (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) ? (15 + Math.random() * 10) : (7 + Math.random() * 15) ) ); 
                    let targetAlpha;
                    if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                        targetAlpha = (0.35 + averageVolume * 0.5 + highs * 0.25) * Math.sin(lifeRatio * Math.PI * 0.8 + 0.1); 
                    } else if (isCoreParticle[i]) { 
                        targetAlpha = (0.4 + averageVolume * 0.6) * (0.65 + bass * 0.35); 
                    } else if (isTracerParticle[i]) { 
                        targetAlpha = Math.sin(lifeRatio * Math.PI) * (0.25 + highs * 0.7); 
                    } else { 
                        targetAlpha = (0.015 + averageVolume * 0.985) * Math.sin(lifeRatio * Math.PI); 
                    }
                    targetAlpha = Math.min(1.0, Math.max(0.0005, targetAlpha)); alphas[i] = THREE.MathUtils.lerp(alphas[i], targetAlpha, 0.028);
                }
                this.geometry.attributes.position.needsUpdate = true; this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true; this.geometry.attributes.alpha.needsUpdate = true;
            }

            dispose() {
                 if (this.particlesObject) {
                    if (this.nebulaHeart) this.particlesObject.remove(this.nebulaHeart);
                    this.scene.remove(this.particlesObject);
                    if (this.points) {
                        if (this.points.geometry) this.points.geometry.dispose();
                        if (this.points.material) { 
                           if (this.points.material.map) this.points.material.map.dispose();
                           this.points.material.dispose();
                        }
                    }
                    if (this.nebulaHeart) { 
                        if (this.nebulaHeart.geometry) this.nebulaHeart.geometry.dispose();
                        if (this.nebulaHeart.material) this.nebulaHeart.material.dispose();
                    }
                    this.particlesObject = null; this.points = null; this.nebulaHeart = null;
                }
            }
            // DENTRO DEL CONSTRUCTOR de RadioNebula, al final
           
        // Esta es la llave de cierre del constructor
        }

        // --- L√ìGICA DE LA PLAYLIST ---

        // REEMPLAZA TODAS TUS FUNCIONES DE PLAYLIST CON ESTE BLOQUE
        // --- L√ìGICA DE LA PLAYLIST (Versi√≥n Unificada y Corregida) ---

        function initPlaylist() {
            playlistAudio.addEventListener('ended', playNextTrack);
            
            const volumeSlider2D = document.getElementById('playlist-volume');
            if (volumeSlider2D) {
                volumeSlider2D.addEventListener('input', (e) => {
                    userPlaylistVolume = parseFloat(e.target.value);
                    playlistAudio.volume = userPlaylistVolume;
                });
            }
            
            const volumeSlider3D = document.getElementById('pulsarVolume');
            const volumeValue3D = document.getElementById('pulsarVolumeValue');
            if (volumeSlider3D) {
                volumeSlider3D.addEventListener('input', (e) => {
                    pulsarVolumeMultiplier = parseFloat(e.target.value);
                    volumeValue3D.textContent = pulsarVolumeMultiplier.toFixed(1);
                    
                    // Actualiza el volumen de todos los p√∫lsares activos en tiempo real
                    for (const pulsarId in gestorDePulsares.activos) {
                        const pulsar = gestorDePulsares.activos[pulsarId];
                        if (pulsar && pulsar.preAmpGain) {
                            pulsar.preAmpGain.gain.setValueAtTime(pulsarVolumeMultiplier, audioListener.context.currentTime);
                        }
                    }
                });
            }

            document.getElementById('btn-repeat').addEventListener('click', toggleRepeat);
            document.getElementById('btn-shuffle').addEventListener('click', toggleShuffle);
            document.getElementById('tagua-radio-item').addEventListener('click', () => togglePlay('radio'));
        }

        // Esta es la √∫nica versi√≥n de la funci√≥n que necesitas
        function addTrackToPlaylist(name, url) {
            const trackId = url; // Usamos la URL como ID √∫nico para evitar duplicados
            if (playlist.some(track => track.id === trackId)) return;

            playlist.push({ id: trackId, name, url });
            renderPlaylist();
        }

        function renderPlaylist() {
            const listElement = document.getElementById('playlist-list');
            const radioItem = document.getElementById('tagua-radio-item');

            // Actualiza el estado visual del item de la Radio
            const isRadioActive = (currentTrackId === 'radio' && !playlistAudio.paused);
            radioItem.classList.toggle('active', isRadioActive);
            radioItem.querySelector('.play-indicator').innerHTML = isRadioActive ? '‚ùö‚ùö' : '‚ñ∂';

            // Renderiza la lista de p√∫lsares descubiertos
            listElement.innerHTML = '';
            if (playlist.length === 0) {
                 listElement.innerHTML = `<li class="playlist-item-empty">A√∫n no has descubierto p√∫lsares.</li>`;
                 return;
            }

            playlist.forEach(track => {
                const item = document.createElement('li');
                item.className = 'playlist-item';
                
                const isActive = (currentTrackId === track.id && !playlistAudio.paused);
                item.classList.toggle('active', isActive);
                
                const playIndicator = isActive ? '‚ùö‚ùö' : '‚ñ∂';
                item.innerHTML = `<span class="play-indicator">${playIndicator}</span> ${track.name}`;
                
                item.addEventListener('click', () => togglePlay(track.id));
                listElement.appendChild(item);
            });
        }

        function togglePlay(trackId) {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            if (trackId === currentTrackId) {
                if (playlistAudio.paused) {
                    playlistAudio.play();
                } else {
                    playlistAudio.pause();
                }
                renderPlaylist();
                return;
            }

            currentTrackId = trackId;
            let trackToPlay;

            if (trackId === 'radio') {
                trackToPlay = { name: "Radio Tagua Tagua (Stream)", url: TAGUA_TAGUA_STREAM_URL, isStream: true };
            } else {
                trackToPlay = playlist.find(t => t.id === trackId);
            }

            if (!trackToPlay) return;

            playlistAudio.src = trackToPlay.url;
            playlistAudio.loop = !trackToPlay.isStream && isRepeatOn && !isShuffleOn;
            playlistAudio.volume = userPlaylistVolume;
            playlistAudio.play().catch(e => console.error("Error al reproducir:", e));

            document.getElementById('current-track-name').textContent = trackToPlay.name;
            renderPlaylist();
        }

        function playNextTrack() {
            if (currentTrackId === 'radio' || playlist.length === 0) return;

            const currentIndex = playlist.findIndex(t => t.id === currentTrackId);
            if (currentIndex === -1) return;

            let nextIndex;
            if (isShuffleOn) {
                do {
                    nextIndex = Math.floor(Math.random() * playlist.length);
                } while (playlist.length > 1 && nextIndex === currentIndex);
            } else {
                if (currentIndex === playlist.length - 1 && !isRepeatOn) {
                    stopPlaylist();
                    return;
                }
                nextIndex = (currentIndex + 1) % playlist.length;
            }

            const nextTrack = playlist[nextIndex];
            if (nextTrack) {
                togglePlay(nextTrack.id);
            }
        }

        function stopPlaylist() {
            playlistAudio.pause();
            playlistAudio.src = "";
            currentTrackId = null;
            document.getElementById('current-track-name').textContent = "Silencio...";
            renderPlaylist();
        }

        function toggleRepeat() {
            isRepeatOn = !isRepeatOn;
            const btn = document.getElementById('btn-repeat');
            btn.classList.toggle('active', isRepeatOn);

            if (isRepeatOn && isShuffleOn) {
                isShuffleOn = false;
                document.getElementById('btn-shuffle').classList.remove('active');
            }
            if (currentTrackId !== 'radio' && !playlistAudio.paused) {
                playlistAudio.loop = isRepeatOn;
            }
        }

        function toggleShuffle() {
            isShuffleOn = !isShuffleOn;
            const btn = document.getElementById('btn-shuffle');
            btn.classList.toggle('active', isShuffleOn);

            if (isShuffleOn && isRepeatOn) {
                isRepeatOn = false;
                document.getElementById('btn-repeat').classList.remove('active');
                playlistAudio.loop = false;
            }
        }

        function handlePlaylistFade() {
            if (playlistAudio.paused || !currentTrackId) return;

            let nearestDistance = Infinity;
            if (gestorDePulsares.pulsarAudible && gestorDePulsares.pulsarAudible.id !== "tagua_tagua_matriz") {
                // Aseg√∫rate que la posici√≥n din√°mica del p√∫lsar se usa aqu√≠
                nearestDistance = avatarObject.position.distanceTo(gestorDePulsares.pulsarAudible.nebula.particlesObject.position);
            }
            
            let fadeMultiplier = 1.0;
            if (nearestDistance < FADE_START_DISTANCE) {
                fadeMultiplier = (nearestDistance - FADE_END_DISTANCE) / (FADE_START_DISTANCE - FADE_END_DISTANCE);
                fadeMultiplier = Math.max(0, Math.min(1, fadeMultiplier));
            }
            
            playlistAudio.volume = userPlaylistVolume * fadeMultiplier;
        }

        // La funci√≥n initAudioControls ya no es necesaria, su l√≥gica est√° integrada arriba.

        function createSharperCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;  // Mayor resoluci√≥n para m√°s nitidez
            canvas.height = 128;
            
            const context = canvas.getContext('2d');
            
            // Fondo transparente
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 2;
            
            // Degradado radial con borde m√°s definido
            const gradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.7, 'rgba(255,255,255,0.9)'); // Mayor opacidad hasta m√°s lejos
            gradient.addColorStop(0.9, 'rgba(255,255,255,0.3)'); // Ca√≠da m√°s r√°pida al final
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            // Dibujar c√≠rculo con degradado
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
            context.fillStyle = gradient;
            context.fill();
            
            // A√±adir un resplandor central para m√°s brillo
            const innerGradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius * 0.5
            );
            innerGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
            innerGradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.beginPath();
            context.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2, false);
            context.fillStyle = innerGradient;
            context.fill();
            
            // Crear textura
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

        // A√±ade esta funci√≥n al inicio del archivo (despu√©s de las variables principales)
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            
            const context = canvas.getContext('2d');
            
            // Fondo transparente
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar c√≠rculo con degradado radial para bordes suaves
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 2;  // -2 para dejar un poco de margen
            
            // Crear degradado radial
            const gradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.8, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            // Dibujar c√≠rculo con el degradado
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
            context.fillStyle = gradient;
            context.fill();
            
            // Crear textura
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
            
        // Funci√≥n para crear una textura circular con bordes m√°s n√≠tidos
        function createSharperCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            
            const context = canvas.getContext('2d');
            
            // Fondo transparente
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 2;
            
            // Degradado radial con borde m√°s definido
            const gradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.7, 'rgba(255,255,255,0.9)');
            gradient.addColorStop(0.9, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
            context.fillStyle = gradient;
            context.fill();
            
            // A√±adir un resplandor central para m√°s brillo
            const innerGradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius * 0.5
            );
            innerGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
            innerGradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.beginPath();
            context.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2, false);
            context.fillStyle = innerGradient;
            context.fill();
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

        // --- Variables para controles t√°ctiles ---


        let touchControlsContainer, joystickContainer, joystickKnob, buttonUp, buttonDown;

        // Para control de c√°mara t√°ctil (arrastre)
        let touchCameraInitialPos = { x: 0, y: 0 };
        let touchIdentifierCamera = null; // Identificador del dedo que controla la c√°mara
        let touchIdentifierJoystick = null; // Identificador del dedo que controla el joystick

        // Para "pinch-to-zoom"
        let initialPinchDistance = null;
        let touchIdentifierPinch1 = null;
        let touchIdentifierPinch2 = null;
        const pinchZoomSensitivity = 0.05; // Ajusta la sensibilidad del zoom


        // Objetos para la c√°mara
        let avatarObject;
        let cameraTarget = new THREE.Vector3();
        let cameraOffset = new THREE.Vector3(0, 10, 20);
        let currentViewMode = 'thirdPerson';
        
        // Variables de control del mouse
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let mouseSensitivity = 0.003;
        
        let socket = null; // Variable para nuestra conexi√≥n WebSocket
        // Variables MIDI
        let midiAccess = null;
        let activeInputs = new Set();
        let midiStatusElement = document.getElementById('midiStatus');
        let coordsElement = document.getElementById('coordinates');
        
        // Variables de red
        let username = "Explorador" + Math.floor(Math.random() * 1000);
        let otherPlayers = {};

        // A√ëADIR ESTE BLOQUE
        // ----------------------------------------------------
        const miBibliotecaMusical = [
            // ¬°IMPORTANTE! Reemplaza estas URLs con las URLs reales de tus archivos MP3
            "https://files.catbox.moe/kmzejt.flac", // Hay corazon solo piano
            "https://files.catbox.moe/sge1i6.flac", //radio tagua con canto en junio
            "https://files.catbox.moe/m4h5se.flac", //he atrapado una galaxia con voz
            "https://files.catbox.moe/vk6oe3.flac",
            "https://files.catbox.moe/103wdw.mp3", //Corazon se lleva la tormenta
            "https://files.catbox.moe/q95jbe.flac" //Trascendencia2
        ];

        let gestorDePulsares = {
            activos: {},       // Almacenar√° todas las instancias de pulsares
            pulsarAudible: null, // Guardar√° la ID del √∫nico pulsar que puede sonar
            // Par√°metros de gesti√≥n de audio
            zonaDeCarga: 800,  // Distancia a la que empezamos a cargar el audio
            zonaAudible: 300   // Distancia a la que el pulsar es candidato para sonar
        };
        
        // A√ëADIR ESTE BLOQUE COMPLETO DE PALETAS DE COLORES
        // -------------------------------------------------------------------
        const MAJESTIC_NEBULA_COLORS_HSL = [
            { h: 0.80, s: 0.9, l: 0.60, name: "Magenta Profundo" },
            { h: 0.52, s: 0.9, l: 0.55, name: "Cian El√©ctrico" },
            { h: 0.95, s: 0.8, l: 0.65, name: "Rosa C√≥smico" },
            { h: 0.70, s: 0.85,l: 0.50, name: "Violeta Intenso" },
            { h: 0.35, s: 0.7, l: 0.50, name: "Verde Esmeralda" },
            { h: 0.05, s: 0.9, l: 0.60, name: "Naranja √çgneo" },
        ];
        const CORE_PULSATING_COLORS_HSL = [
            { h: 0.0,  s: 0.0, l: 0.80, name: "Blanco Estelar" },
            { h: 0.83, s: 0.90, l: 0.55, name: "Fucsia Radiante" },
            { h: 0.93, s: 0.90, l: 0.62, name: "Rosa El√©ctrico" },
            { h: 0.50, s: 0.85,l: 0.60, name: "Calipso Luminoso" },
            { h: 0.10, s: 0.90, l: 0.53, name: "Oro Brillante" },
        ];
        const MAJESTIC_CORONA_COLORS_HSL = [
            { h: 0.12, s: 1.0, l: 0.75, name: "Oro Solar" },
            { h: 0.08, s: 0.9, l: 0.80, name: "√Åmbar Brillante" },
            { h: 0.0,  s: 0.0, l: 0.95, name: "Luz Estelar Pura" }
        ];
        const TAGUA_TAGUA_BASE_COLORS_HSL = [
            { h: 0.95, s: 0.9, l: 0.65, name: "Rosa C√≥smico Intenso" },
            { h: 0.85, s: 0.88,l: 0.60, name: "Fucsia Vibrante" },
            { h: 0.50, s: 0.85,l: 0.60, name: "Calipso Luminoso" },
            { h: 0.0,  s: 0.9, l: 0.55, name: "Rojo Nebular" },
            { h: 0.90, s: 0.8, l: 0.70, name: "Magenta Suave" }
        ];
        const TAGUA_TAGUA_CORE_COLORS_HSL = [
            { h: 0.93, s: 0.95, l: 0.70, name: "Rosa El√©ctrico Nuclear" },
            { h: 0.0, s: 1.0, l: 0.65, name: "Rojo Coraz√≥n Ardiente" },
            { h: 0.52, s: 0.9, l: 0.65, name: "Cian Estelar" }
        ];
        // -------------------------------------------------------------------

        // Configuraci√≥n f√≠sica mejorada de galaxias
        const GALAXY_CONFIG = {
            particleCount: 8000,        // M√°s part√≠culas para mejor efecto
            maxSize: 80,               // Mayor tama√±o m√°ximo
            coreIntensity: 1.5,        // M√°s brillo en el n√∫cleo
            expansionRate: 0.025,      // Velocidad de expansi√≥n
            rotationSpeed: 0.0008,     // Rotaci√≥n
            fadeRate: 0.002,           // Desvanecimiento
            spiralFactor: 3.5,         // Factor espiral m√°s pronunciado
            armCount: 5,               // Brazos
            armWidth: 0.4,             // Ancho de brazos
            viewingDistance: 30,       // Distancia de visualizaci√≥n
            interactionDistance: 2.0,  // Distancia para mezcla de colores entre part√≠culas
            sphereQuality: 8,          // Calidad de las esferas (segmentos)
            mixingIntensity: 0.3       // Intensidad de la mezcla de colores (0-1)
        };
        // Configuraci√≥n mejorada para galaxias de p√≠xeles
        const GALAXY_PIXEL_CONFIG = {
            particleCount: 10000,        // M√°s part√≠culas para mayor riqueza visual
            size: 0.5,                  // Tama√±o de los p√≠xeles
            spiralFactor: 4.5,          // Factor espiral m√°s pronunciado
            armCount: 4,                // N√∫mero de brazos de la galaxia
            colorVariety: [
                // Paleta de colores inspirada en nebulosas y galaxias reales
                {name: "Azul Profundo", hue: 0.6, sat: 0.8, light: 0.4},
                {name: "Violeta C√≥smico", hue: 0.75, sat: 0.7, light: 0.45},
                {name: "Turquesa Espacial", hue: 0.55, sat: 0.6, light: 0.5},
                {name: "Rosa Magenta", hue: 0.9, sat: 0.7, light: 0.5},
                {name: "Verde Esmeralda", hue: 0.4, sat: 0.6, light: 0.45},
                {name: "Naranja C√°lido", hue: 0.08, sat: 0.8, light: 0.5},
            ],
            mixingIntensity: 0.4,       // Intensidad de mezcla de colores
            expansionTime: 5000,        // Tiempo de expansi√≥n de la galaxia
            rotationSpeed: 0.005,       // Velocidad de rotaci√≥n
            lifetime: 30000             // Tiempo de vida de la galaxia
        };
        const GALAXY_PULSAR_CONFIG = {
            
            baseSize: 80,
            pulseIntensity: 4.5,
            pulseSpeedFactor: 0.012,
            rotationSpeedFactor: 0.0015,
            coreBrightness: 0.5,
            generalOpacity: 0.5,
            colorIntensityAudio: 0.35,
            coreColorSpeed: 0.20,
            outerColorSpeed: 0.12
            
        };

         // A√ëADE ESTE NUEVO OBJETO DE CONFIGURACI√ìN
         const TAGUA_TAGUA_CONFIG = {
            ...GALAXY_PULSAR_CONFIG, // Copia toda la configuraci√≥n del p√∫lsar MP3
            baseSize: 160,
            pulseIntensity: 4.5,
            pulseSpeedFactor: 0.012,
            rotationSpeedFactor: 0.0015,
            coreBrightness: 0.5,
            generalOpacity: 0.5,
            colorIntensityAudio: 0.35,
            coreColorSpeed: 0.20,
            outerColorSpeed: 0.12,    // Un n√∫cleo m√°s brillante para que destaque
        };
        
        // Clase para part√≠cula individual
        // 1. SOLUCI√ìN PARA EL CONGELAMIENTO DE ANIMACI√ìN
        // 1. SOLUCI√ìN PARA EL CONGELAMIENTO DE ANIMACI√ìN
        // El problema probablemente est√° en la gesti√≥n de la memoria y los objetos
        // Modifica la clase PixelGalaxy para garantizar una limpieza adecuada

        // ---------- Clase PixelGalaxy (actualizada) ------------
        class PixelGalaxy {
            constructor(id, initialPosition, avatarMesh) {                this.id = id;
                this.position = initialPosition.clone();
                this.creationTime = Date.now();
                this.geometry = new THREE.BufferGeometry();
                this.isFadingOut = false;
                this.fadeOutStartTime = 0;
                this.lastUpdateTime = Date.now();
                this.lastNoteTime = Date.now();
                this.isDisposed = false;
                this.avatarMesh = avatarMesh;
                this.pulsePhase = 0;
                this.armRotation = 0; // Controla la rotaci√≥n global de los brazos
                this.activeNotes = {};
                this.fullyExpanded = false; // Flag para controlar si ya se expandi√≥ completamente

                // Sistema de transiciones fluidas
                this.baseExpansionSize = 25; // Tama√±o base configurado por el slider
                this.targetExpansion = 25;   // Tama√±o objetivo (afectado por MIDI y slider)
                this.currentExpansion = 25;  // Tama√±o actual interpolado
                this.expansionTransitionSpeed = 0.008; // Velocidad de transici√≥n
                this.minExpansion = 15;      // Tama√±o m√≠nimo (velocidad alta)
                this.maxExpansion = 50;      // Tama√±o m√°ximo (velocidad baja)
                this.midiScaleFactor = 1.0;  // Factor de escala MIDI (0.6-1.4)

                // Nuevo: Color predominante para toda la galaxia
                const colorSchemes = [
                    { name: "Azul Nebulosa", baseHue: 0.6, variation: 0.03 },
                    { name: "P√∫rpura Espacial", baseHue: 0.75, variation: 0.03 },
                    { name: "Verde C√≥smico", baseHue: 0.35, variation: 0.04 },
                    { name: "Rojo Estelar", baseHue: 0.0, variation: 0.03 },
                    { name: "√Åmbar Solar", baseHue: 0.12, variation: 0.03 },
                    { name: "Turquesa Profundo", baseHue: 0.48, variation: 0.03 }
                ];
                
                this.colorScheme = colorSchemes[Math.floor(Math.random() * colorSchemes.length)];

                // Obtener configuraci√≥n personalizada si existe
                let customSettings = {};
                try {
                    const savedSettings = localStorage.getItem('musicosmosGalaxySettings');
                    if (savedSettings) {
                        customSettings = JSON.parse(savedSettings);
                    }
                } catch (e) {
                    console.error('Error al cargar configuraci√≥n de galaxia:', e);
                }

                // Configuraci√≥n combinada
                this.config = {
                    particleCount: 7000,
                    baseSize: 0.3,
                    expansionSpeed: 0.0008,
                    spiralSpeed: 0.0008,
                    armRotationSpeed: 0.00015,
                    pulseSpeed: 0.02,
                    // Valores que pueden ser personalizados
                    maxExpansion: customSettings.size || 25,
                    particleAffectedRatio: (customSettings.particleCount || 12) / 100,
                    colorMixFactor: (customSettings.colorMixing || 50) / 100,
                    expansionTime: customSettings.expansionTime || 4000,
                    inactivityTime: customSettings.fadeoutTime || 20000,
                    // Otros valores
                    lifeTime: 25000,
                    fadeOutTime: 5000,
                    verticalScale: 0.9,
                    responseSpeed: 0.3,
                    // Usar un √∫nico esquema de color predominante
                    baseHue: this.colorScheme.baseHue,
                    colorVariation: this.colorScheme.variation,
                    // Historial de notas para transici√≥n crom√°tica
                    noteHistory: [],
                    maxHistoryLength: 10
                };

                // Inicializar los valores del sistema de transiciones
                this.baseExpansionSize = this.config.maxExpansion;
                this.targetExpansion = this.config.maxExpansion;
                this.currentExpansion = this.config.maxExpansion;

                this.createGalaxy();
                this.createNebulaCore(this.avatarMesh);
            }

            // M√©todo para actualizar la configuraci√≥n cuando cambia el slider
            updateConfig(newConfig) {
                // Actualizar la configuraci√≥n
                for (const key in newConfig) {
                    if (this.config.hasOwnProperty(key)) {
                        this.config[key] = newConfig[key];
                    }
                }
                
                // IMPORTANTE: Actualizar el tama√±o base cuando cambia el slider
                if (newConfig.maxExpansion !== undefined) {
                    this.baseExpansionSize = newConfig.maxExpansion;
                    
                    // Recalcular el tama√±o objetivo manteniendo el factor de escala MIDI
                    this.adjustTargetExpansion();
                }
            }
            
            // Nuevo m√©todo para ajustar el tama√±o objetivo teniendo en cuenta 
            // tanto el tama√±o base (slider) como el factor de escala MIDI
            adjustTargetExpansion() {
                // Calcular nuevo tama√±o objetivo basado en el tama√±o base y el factor MIDI actual
                this.targetExpansion = this.baseExpansionSize * this.midiScaleFactor;
                
                // Mantener dentro de l√≠mites razonables
                this.targetExpansion = Math.max(this.minExpansion, 
                                    Math.min(this.maxExpansion, this.targetExpansion));
            }

            createGalaxy() {
                const particleCount = this.config.particleCount;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const nebulaParams = new Float32Array(particleCount * 4);
                
                // Hue base para toda la galaxia (color predominante)
                const baseHue = this.config.baseHue;
                
                for (let i = 0; i < particleCount; i++) {
                    // Generar un radio aleatorio con sesgo y un √°ngulo base aleatorio
                    const distFromCenter = Math.pow(Math.random(), 0.5) * this.config.maxExpansion;
                    const baseAngle = Math.random() * Math.PI * 2;
                    const speedVar = Math.random();
                    const phaseOffset = Math.random() * Math.PI * 2;
                    
                    nebulaParams[i * 4] = distFromCenter;
                    nebulaParams[i * 4 + 1] = baseAngle;
                    nebulaParams[i * 4 + 2] = speedVar;
                    nebulaParams[i * 4 + 3] = phaseOffset;
                    
                    // Posici√≥n inicial concentrada
                    positions[i * 3] = (Math.random() - 0.5) * 0.2;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                    
                    // Peque√±a variaci√≥n sutil en el color (dentro del mismo tono)
                    const hueVar = (Math.random() - 0.5) * this.config.colorVariation;
                    const saturation = 0.7 + Math.random() * 0.3; // Alta saturaci√≥n
                    const lightness = 0.4 + Math.random() * 0.2; // Brillo moderado
                    
                    // Aplicar color con peque√±a variaci√≥n pero mismo tono base
                    const color = new THREE.Color().setHSL(
                        (baseHue + hueVar) % 1.0, 
                        saturation, 
                        lightness
                    );
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = this.config.baseSize * (0.6 + Math.random() * 0.6);
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                this.nebulaParams = nebulaParams;
                
                // Usar textura circular n√≠tida
                const circleTexture = createSharperCircleTexture();
                const material = new THREE.PointsMaterial({
                    size: this.config.baseSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    map: circleTexture,
                    alphaTest: 0.05
                });
                
                this.pixelObject = new THREE.Points(this.geometry, material);
                this.pixelObject.position.copy(this.position);
                scene.add(this.pixelObject);
            }

            createNebulaCore(avatarMesh) {
                if (!avatarMesh) return;
                
                // Shaders para efectos de glow mejorados
                const glowVertexShader = `
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
                `;
                
                const glowFragmentShader = `
                uniform vec3 glowColor;
                uniform float pulseIntensity;
                uniform float timeFactor;
                
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                void main() {
                    // Calcular intensidad basada en √°ngulo de visi√≥n
                    float intensity = pow(0.7 - dot(normalize(vViewPosition), vNormal), 2.0);
                    // A√±adir efecto de pulso
                    intensity *= 1.0 + 0.3 * sin(timeFactor);
                    // Aplicar intensidad de pulso global
                    intensity *= pulseIntensity;
                    
                    gl_FragColor = vec4(glowColor, 1.0) * intensity;
                }
                `;
                
                // Guardar material original
                this.originalAvatarMaterial = avatarMesh.material.clone();                
                // Crear shader personalizado para el avatar
                const avatarUniforms = {
                    glowColor: { value: new THREE.Color(0x4488ff) },
                    pulseIntensity: { value: 1.0 },
                    timeFactor: { value: 0.0 }
                };
                
                const avatarMaterial = new THREE.ShaderMaterial({
                    uniforms: avatarUniforms,
                    vertexShader: glowVertexShader,
                    fragmentShader: glowFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.FrontSide
                });
                
                avatarMesh.material = avatarMaterial; // <-- L√çNEA CORRECTA// <-- 4. MODIFICA ESTA L√çNEA.material = avatarMaterial;
                this.avatarUniforms = avatarUniforms;
                
                // Inner glow mejorado con shaders
                const innerGlowGeometry = new THREE.SphereGeometry(1.05, 24, 24);
                const innerGlowUniforms = {
                    glowColor: { value: new THREE.Color(0xccffff) },
                    pulseIntensity: { value: 0.8 },
                    timeFactor: { value: 0.0 }
                };
                
                const innerGlowMaterial = new THREE.ShaderMaterial({
                    uniforms: innerGlowUniforms,
                    vertexShader: glowVertexShader,
                    fragmentShader: glowFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                this.innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
                this.innerGlowUniforms = innerGlowUniforms;
                avatarMesh.add(this.innerGlow); // <-- 5. MODIFICA ESTA L√çNEA                
                // Outer glow expansivo con shader
                const outerGlowGeometry = new THREE.SphereGeometry(this.config.maxExpansion / 10, 24, 24);
                const outerGlowUniforms = {
                    glowColor: { value: new THREE.Color(0x3366ff) },
                    pulseIntensity: { value: 0.4 },
                    timeFactor: { value: 0.0 }
                };
                
                const outerGlowMaterial = new THREE.ShaderMaterial({
                    uniforms: outerGlowUniforms,
                    vertexShader: glowVertexShader,
                    fragmentShader: glowFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                
                this.outerGlowEffect = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
                this.outerGlowUniforms = outerGlowMaterial.uniforms;
                avatarMesh.add(this.outerGlowEffect); // <-- 6. MODIFICA ESTA L√çNEA                
                // Luz central sutil
                this.coreLight = new THREE.PointLight(0xffffff, 1.0, 15);
                this.coreLight.position.set(0, 0, 0);
                avatarMesh.add(this.coreLight); // <-- 7. MODIFICA ESTA L√çNEA
            }

            // A√±ade esta mejora al m√©todo pulseCore en la clase PixelGalaxy
            pulseCore(note, velocity) {
                if (!this.innerGlow || !this.outerGlowEffect || !this.coreLight) return;
                
                const now = Date.now();
                this.lastNoteTime = now;
                
                // Mapeo de nota MIDI a color (0-127 -> 0-1 en hue)
                const noteHue = (note % 12) / 12;
                const octave = Math.floor(note / 12) - 1;
                
                // Registrar o actualizar nota en activeNotes
                if (!this.activeNotes[note]) {
                    // Nueva nota
                    this.activeNotes[note] = {
                        velocity: velocity,
                        startTime: now,
                        duration: 0,
                        lastUpdateTime: now,
                        color: new THREE.Color().setHSL(
                            noteHue, 
                            0.85, 
                            0.55 + (octave / 8) * 0.25
                        )
                    };
                } else {
                    // MODIFICADO: Si la nota ya existe, actualizar su velocidad
                    // pero mantener otros par√°metros para una mejor experiencia
                    const previousUpdateTime = this.activeNotes[note].lastUpdateTime;
                    this.activeNotes[note].velocity = velocity;
                    this.activeNotes[note].lastUpdateTime = now;
                    
                    // Solo actualizar la duraci√≥n acumulada si es una nueva pulsaci√≥n
                    // no si es un cambio de volumen continuo
                    if (now - previousUpdateTime > 500) { // Umbral para diferenciar nuevo toque vs cambio de CC
                        this.activeNotes[note].duration += now - previousUpdateTime;
                    }
                }
                
                // Calcular color basado en la nota
                const noteColor = new THREE.Color().setHSL(
                    noteHue, 
                    0.85, 
                    0.55 + (octave / 8) * 0.25
                );
                
                const intensity = 0.7 + (velocity / 127) * 1.3;
                
                // Actualizar uniforms del shader del avatar
                if (this.avatarUniforms) {
                    this.avatarUniforms.glowColor.value = noteColor;
                    this.avatarUniforms.pulseIntensity.value = intensity;
                    this.avatarUniforms.timeFactor.value = now * 0.003;
                }
                
                // Inner glow: mezcla con blanco usando uniforms
                if (this.innerGlowUniforms) {
                    const mixedColor = new THREE.Color(0xffffff).lerp(noteColor, 0.4);
                    this.innerGlowUniforms.glowColor.value = mixedColor;
                    this.innerGlowUniforms.pulseIntensity.value = 0.2 + (velocity / 127) * 0.2;
                    this.innerGlowUniforms.timeFactor.value = now * 0.003;
                }
                
                // Outer glow con uniforms
                if (this.outerGlowUniforms) {
                    this.outerGlowUniforms.glowColor.value = noteColor;
                    this.outerGlowUniforms.pulseIntensity.value = 0.2 + (velocity / 127) * 0.2;
                    this.outerGlowUniforms.timeFactor.value = now * 0.002;
                }
                
                // Luz central
                if (this.coreLight) {
                    this.coreLight.color = noteColor;
                    this.coreLight.intensity = 0.8 + intensity * 0.4;
                    this.coreLight.distance = 10 + (velocity / 127) * 10;
                }
                
                // A√ëADIDO: Actualizar tambi√©n el factor de escala MIDI basado en la velocidad
                // para mantener consistencia con los cambios de volumen
                const velocityNormalized = velocity / 127;
                const inversedVelocity = 1 - velocityNormalized;
                this.midiScaleFactor = 0.6 + inversedVelocity * 0.8;
                this.adjustTargetExpansion();
                
                // Actualizar variable de control
                this.updateDominantNote();
            }

            // Agregar m√©todo para encontrar la nota dominante
            updateDominantNote() {
                const now = Date.now();
                let maxDuration = 0;
                let mostPlayedNote = null;
                
                // Buscar nota sostenida m√°s tiempo o tocada m√°s veces
                for (const noteId in this.activeNotes) {
                    const note = this.activeNotes[noteId];
                    
                    // Calcular duraci√≥n acumulada
                    const noteDuration = note.duration + (now - note.lastUpdateTime);
                    
                    if (noteDuration > maxDuration) {
                        maxDuration = noteDuration;
                        mostPlayedNote = noteId;
                    }
                }
                
                // Si hay una nota dominante que supera un umbral (3 segundos)
                const dominanceThreshold = 3000; // 3 segundos
                if (maxDuration > dominanceThreshold && mostPlayedNote) {
                    this.dominantNote = parseInt(mostPlayedNote);
                    this.dominantNoteIntensity = Math.min(1, maxDuration / 10000); // M√°ximo en 10 segundos
                } else {
                    this.dominantNoteIntensity = this.dominantNoteIntensity ? 
                        Math.max(0, this.dominantNoteIntensity - 0.01) : 0; // Disminuir gradualmente
                }
            }

            addParticles(note, velocity) {
                if (!this.pixelObject || !this.pixelObject.geometry || this.isDisposed) return;
                
                // Si estaba desvaneci√©ndose, cancelar el desvanecimiento
                if (this.isFadingOut) {
                    this.isFadingOut = false;
                    if (this.pixelObject.material) {
                        this.pixelObject.material.opacity = 0.9; // Restaurar opacidad
                    }
                }
                
                // Activar efectos del n√∫cleo seg√∫n nota MIDI
                this.pulseCore(note, velocity);
                this.lastNoteTime = Date.now();
                
                // Mapeo de nota a tono de color
                const noteHue = (note % 12) / 12;
                const octave = Math.floor(note / 12) - 1;
                const noteColor = new THREE.Color().setHSL(
                    noteHue, 
                    0.85, 
                    0.55 + (octave / 8) * 0.25
                );
                
                // MODIFICADO: Relaci√≥n invertida entre velocidad y tama√±o
                // Usando factor de escala MIDI en lugar de reemplazar directamente maxExpansion
                const velocityNormalized = velocity / 127;
                const inversedVelocity = 1 - velocityNormalized;
                
                // Calcular factor de escala entre 0.6 (velocidad alta) y 1.4 (velocidad baja)
                // Esto permite que el slider mantenga su funci√≥n de control de tama√±o base
                this.midiScaleFactor = 0.6 + inversedVelocity * 0.8;
                
                // Actualizar el tama√±o objetivo basado en el tama√±o base y el factor MIDI
                this.adjustTargetExpansion();
                
                const positions = this.geometry.attributes.position;
                const colors = this.geometry.attributes.color;
                
                // Mayor cantidad de part√≠culas para respuesta m√°s r√°pida
                // Usar ratio personalizado y velocidad
                const transformCount = Math.floor(positions.count * this.config.particleAffectedRatio * velocityNormalized);
                
                // Transformar un subconjunto de part√≠culas
                for (let i = 0; i < transformCount; i++) {
                    // Elegir part√≠cula aleatoria
                    const idx = Math.floor(Math.random() * positions.count);
                    
                    // Transformar color gradualmente
                    const currentColor = new THREE.Color(
                        colors.array[idx * 3],
                        colors.array[idx * 3 + 1],
                        colors.array[idx * 3 + 2]
                    );
                    
                    // Mezcla m√°s agresiva hacia el nuevo color para respuesta m√°s r√°pida
                    const baseFactor = this.config.colorMixFactor;
                    const mixFactor = baseFactor + velocityNormalized * (baseFactor * 0.8);
                    const newColor = currentColor.lerp(noteColor, mixFactor);
                    
                    colors.array[idx * 3] = newColor.r;
                    colors.array[idx * 3 + 1] = newColor.g;
                    colors.array[idx * 3 + 2] = newColor.b;
                }
                
                // Marcar colores para actualizaci√≥n
                colors.needsUpdate = true;
                
                // Extender la vida de la galaxia
                this.creationTime = Math.min(this.creationTime, Date.now() - 5000); // Mantener expansi√≥n
            }

            update() {
                if (this.isDisposed || !this.pixelObject) return false;
                
                const now = Date.now();
                const deltaTime = now - this.lastUpdateTime;
                this.lastUpdateTime = now;
                
                if (deltaTime > 1000) return true;
                
                // Actualizar factor de tiempo para shaders
                if (this.avatarUniforms) {
                    this.avatarUniforms.timeFactor.value = now * 0.003;
                }
                if (this.innerGlowUniforms) {
                    this.innerGlowUniforms.timeFactor.value = now * 0.003;
                }
                if (this.outerGlowUniforms) {
                    this.outerGlowUniforms.timeFactor.value = now * 0.002;
                }
                
                const age = now - this.creationTime;
                const timeSinceLastNote = now - this.lastNoteTime;
                
                // MODIFICADO: Transici√≥n suave del tama√±o de expansi√≥n
                if (this.currentExpansion !== this.targetExpansion) {
                    // Factor que controla la velocidad de transici√≥n
                    const lerpFactor = Math.min(1.0, this.expansionTransitionSpeed * deltaTime);
                    
                    // Interpolaci√≥n lineal hacia el tama√±o objetivo
                    this.currentExpansion += (this.targetExpansion - this.currentExpansion) * lerpFactor;
                    
                    // Si estamos muy cerca del objetivo, finalizar la transici√≥n
                    if (Math.abs(this.currentExpansion - this.targetExpansion) < 0.01) {
                        this.currentExpansion = this.targetExpansion;
                    }
                }
                
                // Usar tiempo de expansi√≥n personalizado
                let normalizedAge = Math.min(1, age / this.config.expansionTime);
                
                // Si ya se expandi√≥ completamente una vez, mantenerla expandida
                if (normalizedAge >= 1) {
                    this.fullyExpanded = true;
                }
                
                // Si est√° completamente expandida, mantener la expansi√≥n
                if (this.fullyExpanded) {
                    normalizedAge = 1;
                }
                
                // Incrementar el pulso y la rotaci√≥n global de los brazos
                this.pulsePhase += this.config.pulseSpeed * deltaTime / 1000;
                this.armRotation += this.config.armRotationSpeed * deltaTime;
                const pulseValue = 0.5 + Math.sin(this.pulsePhase) * 0.5;
                
                // MODIFICADO: Usar currentExpansion en lugar de config.maxExpansion
                const maxScale = this.currentExpansion / 20;
                const currentScale = Math.min(maxScale, normalizedAge * maxScale);
                const positions = this.geometry.attributes.position;
                const sizes = this.geometry.attributes.size;
                
                // Actualizar cada part√≠cula para lograr un efecto espiral animado
                for (let i = 0; i < positions.count; i++) {
                    const dist = this.nebulaParams[i * 4] * currentScale;
                    const baseAngle = this.nebulaParams[i * 4 + 1];
                    const speedVar = this.nebulaParams[i * 4 + 2];
                    const phaseVar = this.nebulaParams[i * 4 + 3];
                    
                    // Calcular rotaci√≥n diferencial y sumar la rotaci√≥n global (se resta para invertir sentido)
                    const rotationIncrement = this.config.spiralSpeed * deltaTime * (0.5 + speedVar);
                    const angle = baseAngle + rotationIncrement - this.armRotation + Math.sin(this.pulsePhase * 0.2 + phaseVar * 10) * 0.1;
                    
                    // Onda radial
                    const wavePhase = this.pulsePhase * 0.3 + phaseVar * Math.PI * 2;
                    const waveMagnitude = 0.25 * speedVar * dist;
                    const orbitRadius = dist * (0.7 + Math.sin(wavePhase) * 0.3);
                    
                    positions.array[i * 3] = Math.cos(angle) * orbitRadius + Math.cos(wavePhase * 1.5) * waveMagnitude;
                    positions.array[i * 3 + 2] = Math.sin(angle) * orbitRadius + Math.sin(wavePhase * 1.5) * waveMagnitude;
                    
                    // Componente Y para dar volumen
                    const yOffset = speedVar * currentScale * this.config.verticalScale;
                    const yWave = Math.sin(wavePhase + angle) * waveMagnitude * 0.8;
                    positions.array[i * 3 + 1] = yOffset + yWave;
                    
                    // Tama√±o con pulso
                    const pulseFactor = 1 + pulseValue * 0.1 * (0.5 + phaseVar);
                    sizes.array[i] = this.config.baseSize * (0.5 + normalizedAge * 0.5) * pulseFactor;
                }
                
                positions.needsUpdate = true;
                sizes.needsUpdate = true;
                
                // Manejo del fade out - usar tiempo de inactividad personalizado
                if (this.isFadingOut) {
                    const fadeOutDuration = this.config.fadeOutTime;
                    const timeSinceFade = now - this.fadeOutStartTime;
                    const opacity = Math.max(0, 1 - (timeSinceFade / fadeOutDuration));
                    
                    if (this.pixelObject && this.pixelObject.material) {
                        this.pixelObject.material.opacity = opacity;
                        
                        // Solo eliminar despu√©s de un tiempo mucho mayor sin interacci√≥n
                        if (opacity <= 0 && timeSinceLastNote > 30000) {
                            scene.remove(this.pixelObject);
                            this.dispose();
                            return false;
                        }
                    }
                } else if (timeSinceLastNote > this.config.inactivityTime) {  // Usar tiempo personalizado
                    this.isFadingOut = true;
                    this.fadeOutStartTime = now;
                }
                
                return true;
            }

            removeNote(note) {
                if (this.isDisposed) return;
                delete this.activeNotes[note];
                if (Object.keys(this.activeNotes).length === 0 && Date.now() - this.lastNoteTime > 15000) {
                    if (!this.isFadingOut) {
                        this.isFadingOut = true;
                        this.fadeOutStartTime = Date.now();
                    }
                }
            }

            dispose() {
                if (this.isDisposed) return;
                this.isDisposed = true;
                
                // Desvanecimiento gradual del halo del avatar
                const startTime = Date.now();
                const fadeDuration = 2000; // 2 segundos de desvanecimiento
                
                const fadeOutAvatarGlow = () => {
                    const now = Date.now();
                    const elapsed = now - startTime;
                    const progress = Math.min(1, elapsed / fadeDuration);
                    
                    // Reducir gradualmente la intensidad del shader del avatar
                    if (this.avatarUniforms && this.avatarUniforms.pulseIntensity) {
                        this.avatarUniforms.pulseIntensity.value = 1.0 * (1 - progress);
                    }
                    
                    // Reducir la intensidad del inner glow
                    if (this.innerGlowUniforms && this.innerGlowUniforms.pulseIntensity) {
                        this.innerGlowUniforms.pulseIntensity.value = 0.8 * (1 - progress);
                    }
                    
                    // Reducir la intensidad del outer glow
                    if (this.outerGlowUniforms && this.outerGlowUniforms.pulseIntensity) {
                        this.outerGlowUniforms.pulseIntensity.value = 0.4 * (1 - progress);
                    }
                    
                    // Reducir la intensidad de la luz
                    if (this.coreLight) {
                        this.coreLight.intensity = 1.0 * (1 - progress);
                    }
                    
                    if (progress < 1) {
                        // Continuar el desvanecimiento
                        requestAnimationFrame(fadeOutAvatarGlow);
                    } else {
                    // Completar la limpieza una vez finalizado el desvanecimiento
                        this.completeDispose();
                    }
                };
                
                // Iniciar el desvanecimiento
                fadeOutAvatarGlow();
            }
            
            // M√©todo para completar la limpieza despu√©s del desvanecimiento
            completeDispose() {
                if (this.originalAvatarMaterial && this.avatarMesh) {
                    this.avatarMesh.material = this.originalAvatarMaterial;
                    this.originalAvatarMaterial = null;
                }
                
                if (this.innerGlow && avatarObject) {
                    this.avatarMesh.remove(this.innerGlow);
                    this.innerGlow.material.dispose();
                    this.innerGlow.geometry.dispose();
                    this.innerGlow = null;
                }
                
                if (this.outerGlowEffect && this.avatarMesh) {
                    this.avatarMesh.remove(this.outerGlowEffect);
                    this.outerGlowEffect.material.dispose();
                    this.outerGlowEffect.geometry.dispose();
                    this.outerGlowEffect = null;
                }
                
                if (this.coreLight && this.avatarMesh) {
                    this.avatarMesh.remove(this.coreLight);
                    this.coreLight = null;
                }
                
                if (this.pixelObject) {
                    scene.remove(this.pixelObject);
                    if (this.pixelObject.geometry) this.pixelObject.geometry.dispose();
                    if (this.pixelObject.material) {
                        if (this.pixelObject.material.map) this.pixelObject.material.map.dispose();
                        this.pixelObject.material.dispose();
                    }
                    this.pixelObject = null;
                }
                
                this.geometry = null;
                this.nebulaParams = null;
                this.avatarUniforms = null;
                this.innerGlowUniforms = null;
                this.outerGlowUniforms = null;
            }
        }

        // Funci√≥n para convertir n√∫mero de nota MIDI a frecuencia en Hz
        function midiToFrequency(midiNote) {
            if (midiNote < 0 || midiNote > 127) return null; // Nota inv√°lida
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }
        
        // Clase Galaxy para manejar conjuntos de part√≠culas
        // Modificar el m√©todo addNote en la clase Galaxy para usar PixelGalaxy
       // ---------- Clase Galaxy (actualizada) ------------
        class Galaxy {
            
            constructor(id, initialPosition, isLocal = false) {
                this.id = id;
                this.position = initialPosition.clone();
                this.pixelGalaxy = null;
                this.activeNotes = new Map();
                this.energy = 0;
                this.lastNoteTime = Date.now();
                this.isDisposed = false;
                this.positionalAudio = null; 
                this.activeAudioNotes = {}; 
                this.isLocal = isLocal;

                // --- INICIO DE LA CORRECCI√ìN ---

                // 1. Crear el emisor de audio 3D para TODAS las galaxias
                if (audioListener) {
                    this.positionalAudio = new THREE.PositionalAudio(audioListener);
                    this.positionalAudio.setRefDistance(20); 
                    this.positionalAudio.setRolloffFactor(1.5); 
                    this.positionalAudio.setMaxDistance(200); 

                    this.positionalAudio.panningModel = 'HRTF'; // A√±ade esta l√≠nea
                } else {
                    console.error("AudioListener no est√° inicializado al crear Galaxy!");
                }

                if (this.isLocal) {
                    // 2. Si es LOCAL, usamos el avatar global
                    this.avatarMesh = avatarObject;
                    // ¬°LA L√çNEA QUE FALTABA! Conectamos el audio 3D al avatar local.
                    if (this.positionalAudio) {
                        this.avatarMesh.add(this.positionalAudio);
                    }

                } else {
                    // 3. Si es REMOTO, creamos un nuevo avatar
                    const geometry = new THREE.SphereGeometry(1, 16, 12);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: 0x4488ff,
                        emissive: 0x112244,
                        transparent: true,
                        opacity: 0.6,
                        shininess: 30
                    });
                    this.avatarMesh = new THREE.Mesh(geometry, material);
                    this.avatarMesh.position.copy(this.position);
                    scene.add(this.avatarMesh);
                    
                    this.targetPosition = this.position.clone();
                    this.interpolationFactor = 0.1; 

                    // Conectamos el audio 3D al avatar remoto
                    if (this.positionalAudio) {
                        this.avatarMesh.add(this.positionalAudio);
                    }
                }
                
                // --- FIN DE LA CORRECCI√ìN ---
            }

            addNote(note, velocity) {
                if (this.isDisposed) return;
                this.activeNotes.set(note, { velocity: velocity, time: Date.now() });
                this.energy = Math.min(1.0, this.energy + (velocity / 127) * 0.2);
                this.lastNoteTime = Date.now();
                if (!this.pixelGalaxy) {
                this.pixelGalaxy = new PixelGalaxy(this.id, this.position, this.avatarMesh);
                }
                if (this.pixelGalaxy) {
                this.pixelGalaxy.addParticles(note, velocity);
                }
            }

            removeNote(note) {
                if (this.isDisposed) return;
                this.activeNotes.delete(note);
                if (this.activeNotes.size === 0 && Date.now() - this.lastNoteTime > 10000) {
                if (this.pixelGalaxy && !this.pixelGalaxy.isFadingOut) {
                    this.pixelGalaxy.isFadingOut = true;
                    this.pixelGalaxy.fadeOutStartTime = Date.now();
                }
                }
            }

            update() {
                if (this.isDisposed) return;
                if (this.pixelGalaxy) {
                const result = this.pixelGalaxy.update();
                if (!result) {
                    this.pixelGalaxy = null;
                }
                }
                const now = Date.now();
                if (now - this.lastNoteTime > 2000) {
                this.energy = Math.max(0, this.energy - 0.005);
                }
            }

            updatePosition(newPos) {
                if (this.isDisposed) return;
                this.position.copy(newPos);
                if (this.pixelGalaxy && this.pixelGalaxy.pixelObject) {
                this.pixelGalaxy.pixelObject.position.copy(newPos);
                }
                // --- 4. A√ëADE ESTE BLOQUE ---
                // Mueve el avatar (esfera) junto con las part√≠culas
               // if (this.avatarMesh) {
               //     this.avatarMesh.position.copy(newPos);
               // }
            }
            // --- NUEVO M√âTODO: playRemoteNote ---
           // --- NUEVO M√âTODO: playNote (reemplaza a playRemoteNote) ---
           playNote(note, velocity) {
                // No tocamos para nosotros mismos si somos el jugador local (el AlienSynth ya lo hace)
                if (this.isLocal) return;
                
                if (!this.positionalAudio || !audioContext) return; 

                if (this.activeAudioNotes[note]) {
                    return;
                }

                try {
                    const frequency = midiToFrequency(note);
                    if (!frequency) return; 

                    const oscillator = audioContext.createOscillator();
                    oscillator.type = 'sine'; 
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

                    const gainNode = audioContext.createGain();
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime); 

                    oscillator.connect(gainNode);
                    
                    // Conectamos a .gain (el input del PositionalAudio)
                    gainNode.connect(this.positionalAudio.gain); 

                    // --- ¬°L√çNEAS A A√ëADIR PARA FADE IN! ---
                    const targetVolume = (velocity / 127) * 0.7; // Volumen basado en velocity
                    const attackTime = 0.05; // Duraci√≥n del fade-in (en segundos)
                    gainNode.gain.linearRampToValueAtTime(targetVolume, audioContext.currentTime + attackTime); // Subir volumen suavemente
                    // --- FIN L√çNEAS A A√ëADIR ---

                   

                    oscillator.start();
                    this.activeAudioNotes[note] = { oscillator, gainNode };

                } catch (e) {
                    console.error(`Error al tocar nota remota ${note}:`, e);
                }
            }
            // --- FIN playNote ---

            // --- NUEVO M√âTODO: stopNote (reemplaza a stopRemoteNote) ---
            stopNote(note) {
                // No aplica para el jugador local
                if (this.isLocal) return;

                if (!this.activeAudioNotes[note] || !audioContext) return; 

                try {
                    const { oscillator, gainNode } = this.activeAudioNotes[note];
                    const releaseTime = 0.3; 
                    const now = audioContext.currentTime;

                  // --- ¬°NUEVAS L√çNEAS PARA FADE OUT! ---
                    gainNode.gain.cancelScheduledValues(now); // Cancelar rampas previas
                    gainNode.gain.setValueAtTime(gainNode.gain.value, now); // Asegurar valor actual
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + releaseTime); // Bajar a casi silencio

                    // Detener el oscilador DESPU√âS de que termine el fade out
                    oscillator.stop(now + releaseTime + 0.05); // Un peque√±o margen extra
                    // --- FIN NUEVAS L√çNEAS --- 

                    setTimeout(() => {
                        try {
                            oscillator.disconnect();
                            gainNode.disconnect();
                        } catch(e) { /* Ignorar */ }
                    }, (releaseTime + 0.1) * 1000); 

                    delete this.activeAudioNotes[note];

                } catch (e) {
                    console.error(`Error al detener nota remota ${note}:`, e);
                }
            }
            // --- FIN stopNote ---
            // --- FIN stopRemoteNote ---



            dispose() {
                if (this.isDisposed) return;
                this.isDisposed = true;
                // --- LIMPIEZA DE AUDIO ---
                if (!this.isLocal) {
                    // Detener todas las notas de audio activas inmediatamente
                    for (const note in this.activeAudioNotes) {
                        try {
                            const { oscillator, gainNode } = this.activeAudioNotes[note];
                            oscillator.stop();
                            oscillator.disconnect();
                            gainNode.disconnect();
                        } catch (e) { /* Ignorar errores si ya estaba desconectado */ }
                    }
                    this.activeAudioNotes = {};

                    // Quitar el PositionalAudio del avatar
                    if (this.positionalAudio && this.avatarMesh) {
                        this.avatarMesh.remove(this.positionalAudio);
                        // No necesitas desconectar positionalAudio expl√≠citamente si se elimina del grafo
                    }
                    this.positionalAudio = null; // Liberar referencia
                }
                // --- FIN LIMPIEZA AUDIO ---
                if (this.pixelGalaxy) {
                this.pixelGalaxy.dispose();
                this.pixelGalaxy = null;
                }// --- 5. A√ëADE ESTE BLOQUE ---
                // Si no es local, destruimos el avatar que creamos
                if (!this.isLocal && this.avatarMesh) {
                    scene.remove(this.avatarMesh);
                    this.avatarMesh.geometry.dispose();
                    this.avatarMesh.material.dispose();
                }
                this.avatarMesh = null;
                // --- FIN DEL BLOQUE ---
               
                this.activeNotes.clear();
            }
            }

        

        // Sistema de hipervelocidad para Musicosmos

        // Pega esta funci√≥n completa en tu script (antes de la funci√≥n init)

        function initStaticTaguaTaguaRadio() {
            console.log("Inicializando Radio Tagua Tagua est√°tica...");

            // 1. Creamos el elemento de audio para el streaming
            radioTaguaTaguaStream = new Audio(TAGUA_TAGUA_STREAM_URL);
            radioTaguaTaguaStream.crossOrigin = "anonymous";
            radioTaguaTaguaStream.loop = true;

            // --- INICIO DE LA CORRECCI√ìN ---
            // 1. Declaramos la variable 'source' aqu√≠ arriba
            let sourceNode = null; 
            // --- FIN DE LA CORRECCI√ìN ---

            // 2. Creamos su propio analizador de audio
            if (audioContext) {
                analyserNodeTaguaTagua = audioContext.createAnalyser();
                analyserNodeTaguaTagua.fftSize = 512;
                analyserNodeTaguaTagua.smoothingTimeConstant = 0.75;

                // --- INICIO DE LA CORRECCI√ìN ---
                // 2. Asignamos el nodo creado
                sourceNode = audioContext.createMediaElementSource(radioTaguaTaguaStream); 
                sourceNode.connect(analyserNodeTaguaTagua);
                // --- FIN DE LA CORRECCI√ìN ---
                
                // La l√≠nea de "leak" 2D ya la hab√≠amos quitado, lo cual es correcto.
            }

            // 3. Creamos la instancia de la nebulosa con sus caracter√≠sticas √∫nicas
            radioTaguaTaguaNebula = new RadioNebula(
                scene,
                TAGUA_TAGUA_NEBULA_POS,
                analyserNodeTaguaTagua,
                TAGUA_TAGUA_CONFIG, 
                'tagua_tagua',      
                true                
            );

            // 4. A√±adimos el audio posicional para que el sonido venga de la nebulosa
            const positionalAudio = new THREE.PositionalAudio(audioListener);
            positionalAudio.setRefDistance(40);
            positionalAudio.setRolloffFactor(1);
            positionalAudio.setMaxDistance(3000); 
            
            if (analyserNodeTaguaTagua) {
                positionalAudio.setNodeSource(analyserNodeTaguaTagua);
            }
            radioTaguaTaguaNebula.particlesObject.add(positionalAudio);
            
            // 5. Preparamos el audio para la reproducci√≥n
            radioTaguaTaguaStream.load();

            // 6. La registramos en el gestor de p√∫lsares para que el sistema la controle
            const pulsarId = "tagua_tagua_matriz";
            gestorDePulsares.activos[pulsarId] = {
                id: pulsarId,
                nebula: radioTaguaTaguaNebula,
                audio: radioTaguaTaguaStream,
                analyser: analyserNodeTaguaTagua,
                positionalAudio: positionalAudio,
                url: TAGUA_TAGUA_STREAM_URL,
                tiempoGuardado: 0,
                
                // --- INICIO DE LA CORRECCI√ìN ---
                // 3. Guardamos el nodo 'source' que creamos
                mediaSource: sourceNode, 
                // 4. Marcamos como "ya cargada" (¬°ESTA ES LA L√çNEA M√ÅS IMPORTANTE!)
                isLoaded: true,          
                // --- FIN DE LA CORRECCI√ìN ---
                
                isPlaying: false
            };
        }

        // --- Variables para P√∫lsar en Vivo (Micr√≥fono/L√≠nea) ---
        

        // --- INICIO DE LA L√ìGICA DE FORJA DE P√öLSARES ---

        /**
         * Inicializa los listeners para los botones de la Forja de P√∫lsares.
         * DEBES LLAMAR A ESTA FUNCI√ìN DENTRO DE TU FUNCI√ìN init()
         */
         function initForgeControls() {
            // Bot√≥n P√∫lsar MP3
            const pulsarButton = document.getElementById('createPersonalPulsarButton');
            if (pulsarButton) pulsarButton.addEventListener('click', forjarPulsarPersonal);

            // Bot√≥n Radio Tagua Tagua
            const taguaButton = document.getElementById('createTaguaPulsarButton');
            if (taguaButton) taguaButton.addEventListener('click', forjarRadioTaguaTagua);

            // --- NUEVO: Bot√≥n Escanear ---
            const scanButton = document.getElementById('scanAudioDevicesBtn');
            if (scanButton) scanButton.addEventListener('click', populateAudioInputDevices);

            // Botones P√∫lsar en Vivo
            const startLiveButton = document.getElementById('startLivePulsar');
            const clearLiveButton = document.getElementById('clearLivePulsars');
            
            if (startLiveButton) startLiveButton.addEventListener('click', startLivePulsar);
            
            // Bot√≥n limpiar
            if (clearLiveButton) {
                clearLiveButton.addEventListener('click', () => {
                    let count = 0;
                    for (const id in gestorDePulsares.activos) {
                        if (gestorDePulsares.activos[id].type === 'live') {
                            if(gestorDePulsares.activos[id].nebula) gestorDePulsares.activos[id].nebula.dispose();
                            if (gestorDePulsares.activos[id].mediaStream) {
                                gestorDePulsares.activos[id].mediaStream.getTracks().forEach(t => t.stop());
                            }
                            delete gestorDePulsares.activos[id];
                            count++;
                        }
                    }
                    const statusEl = document.getElementById('livePulsarStatus');
                    if(statusEl) statusEl.textContent = `${count} p√∫lsares en vivo eliminados.`;
                });
            }

            // Radio button coordenadas
            const placeCoordsRadio = document.getElementById('placeCoords');
            if (placeCoordsRadio) {
                placeCoordsRadio.addEventListener('change', () => {
                    if (placeCoordsRadio.checked) {
                        document.getElementById('forgeX').value = avatarObject.position.x.toFixed(0);
                        document.getElementById('forgeY').value = avatarObject.position.y.toFixed(0);
                        document.getElementById('forgeZ').value = avatarObject.position.z.toFixed(0);
                    }
                });
            }
        }

        /**
         * Obtiene la posici√≥n de forja deseada, ya sea frente al avatar o
         * desde los campos de coordenadas.
         * @returns {THREE.Vector3} La posici√≥n calculada para el nuevo p√∫lsar.
         */
         function getForgePosition() {
            const isFront = document.getElementById('placeFront').checked;
            
            if (isFront) {
                // --- CORRECCI√ìN: Usar vector de direcci√≥n real del avatar ---
                const DISTANCIA_FRENTE = 50.0; 
                
                // Obtenemos la direcci√≥n exacta hacia donde mira la esfera/avatar
                const direction = new THREE.Vector3();
                avatarObject.getWorldDirection(direction);
                
                // Multiplicamos por la distancia y sumamos a la posici√≥n actual
                const position = avatarObject.position.clone().add(direction.multiplyScalar(DISTANCIA_FRENTE));
                
                return position;
                
            } else {
                // --- CORRECCI√ìN: Leer inputs manualmente ---
                const xVal = document.getElementById('forgeX').value;
                const yVal = document.getElementById('forgeY').value;
                const zVal = document.getElementById('forgeZ').value;

                // Convertir a float
                const x = parseFloat(xVal);
                const y = parseFloat(yVal);
                const z = parseFloat(zVal);
                
                // Validar que sean n√∫meros reales
                if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    console.warn("Coordenadas inv√°lidas, usando posici√≥n del avatar.");
                    return avatarObject.position.clone();
                }
                
                return new THREE.Vector3(x, y, z);
            }
        }

        /**
         * Rellena el <select> con los dispositivos de entrada de audio (micr√≥fonos, etc.)
         * DEBES LLAMAR A ESTA FUNCI√ìN DENTRO DE TU FUNCI√ìN init()
         */
        async function populateAudioInputDevices() {
            const selector = document.getElementById('audioInputDevice');
            if (!selector) return;
            
            try {
                // Pedir permiso gen√©rico para poder listar dispositivos
                // Asegurarse de que el contexto de audio est√© activo
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                await navigator.mediaDevices.getUserMedia({ audio: true });

                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                
                selector.innerHTML = ''; // Limpiar opciones
                
                if (audioInputs.length === 0) {
                    selector.innerHTML = '<option value="">No se encontraron entradas de audio</option>';
                    return;
                }
                
                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Dispositivo ${selector.options.length + 1}`;
                    selector.appendChild(option);
                });

            } catch (err) {
                console.error("Error al enumerar dispositivos de audio:", err);
                selector.innerHTML = '<option value="">Error al obtener dispositivos</option>';
                const statusEl = document.getElementById('livePulsarStatus');
                if (statusEl) {
                    statusEl.textContent = "Error: Se necesita permiso de micr√≥fono.";
                    statusEl.className = 'forge-status error';
                }
            }
        }

        /**
         * Inicia el P√∫lsar en Vivo usando la entrada de audio seleccionada.
        
         async function startLivePulsar() {
            const deviceId = document.getElementById('audioInputDevice').value;
            const statusEl = document.getElementById('livePulsarStatus');
            
            if (!deviceId) {
                statusEl.textContent = "Error: Selecciona un dispositivo primero.";
                statusEl.className = 'forge-status error';
                return;
            }

            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            try {
                // Obtenemos un stream NUEVO para esta instancia
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: { exact: deviceId },
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                // Crear nodos de audio locales para esta instancia
                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.75;
                
                source.connect(analyser);

                // --- CORRECCI√ìN IMPORTANTE: Inicializar los arrays de datos ---
                liveFrequencyData = new Uint8Array(analyser.frequencyBinCount);
                liveTimeData = new Uint8Array(analyser.fftSize);
                // -----------------------------------------------------------

                const position = getForgePosition();

                // Crear la nebulosa
                const nebula = new RadioNebula(scene, position, analyser, GALAXY_PULSAR_CONFIG, 'live', false);
                
                // ID √∫nico
                const pulsarId = `live_${Date.now()}_${Math.floor(Math.random()*1000)}`;

                // Asignamos el ID a la nebulosa para poder borrarla luego
                nebula.pulsarWrapperId = pulsarId; 

                // Guardar una referencia global para la animaci√≥n espec√≠fica de 'live'
                livePulsarInstance = nebula;
                livePulsarAnalyser = analyser;
                livePulsarStream = stream;
                livePulsarSource = source;

                // Guardar en el gestor global
                gestorDePulsares.activos[pulsarId] = {
                    id: pulsarId,
                    type: 'live',
                    nebula: nebula,
                    analyser: analyser,
                    mediaStream: stream,
                    audioSource: source,
                    isLoaded: true,
                    isPlaying: true
                };

                statusEl.textContent = `P√∫lsar creado en X:${position.x.toFixed(0)} Z:${position.z.toFixed(0)}`;
                statusEl.className = 'forge-status';

            } catch (err) {
                console.error("Error al iniciar p√∫lsar:", err);
                statusEl.textContent = "Error: Permiso denegado o dispositivo ocupado.";
                statusEl.className = 'forge-status error';
            }
        }

        /**
         * Detiene el P√∫lsar en Vivo y libera los recursos.
         */
        function stopLivePulsar() {
            const statusEl = document.getElementById('livePulsarStatus');

            if (livePulsarInstance) {
                livePulsarInstance.dispose();
                livePulsarInstance = null;
            }
            if (livePulsarSource) {
                livePulsarSource.disconnect();
                livePulsarSource = null;
            }
            if (livePulsarStream) {
                livePulsarStream.getTracks().forEach(track => track.stop());
                livePulsarStream = null;
            }
            
            livePulsarAnalyser = null;
            liveFrequencyData = null;
            liveTimeData = null;

            if (statusEl) {
                statusEl.textContent = "P√∫lsar en Vivo detenido.";
                statusEl.className = 'forge-status';
            }
            const startBtn = document.getElementById('startLivePulsar');
            const stopBtn = document.getElementById('stopLivePulsar');
            if (startBtn) startBtn.disabled = false;
            if (stopBtn) stopBtn.disabled = true;
        }

        /**
         * Maneja el clic en "Forjar P√∫lsar Personal (MP3)".
         */
        function forjarPulsarPersonal() {
            const fileInput = document.getElementById('newPulsarFileInput');
            const nameInput = document.getElementById('newPulsarName');
            const statusEl = document.getElementById('forgePulsarStatus');

            if (!fileInput.files || fileInput.files.length === 0) {
                statusEl.textContent = "Error: Debes seleccionar un archivo de audio.";
                statusEl.className = 'forge-status error';
                return;
            }
            
            const nombre = nameInput.value.trim() || "P√∫lsar Personal";
            const file = fileInput.files[0];
            const url = URL.createObjectURL(file);
            
            const position = getForgePosition(); // ¬°Obtenemos la posici√≥n!

            crearNuevoPulsar(nombre, url, position, 'mp3', false);

            statusEl.textContent = `¬°√âxito! P√∫lsar "${nombre}" forjado en ${position.x.toFixed(0)}, ${position.y.toFixed(0)}, ${position.z.toFixed(0)}`;
            statusEl.className = 'forge-status';
            
            nameInput.value = '';
            fileInput.value = '';
        }

        /**
         * Maneja el clic en "Forjar Radio Tagua Tagua".
         */
        function forjarRadioTaguaTagua() {
            const statusEl = document.getElementById('forgeRadioStatus');
            
            const nombre = "Radio Tagua Tagua";
            const url = TAGUA_TAGUA_STREAM_URL; // Variable global que ya tienes
            const tipo = 'tagua_tagua'; // Para que obtenga los colores majestuosos
            const esMajestuoso = true;
            
            if (!url) {
                 statusEl.textContent = "Error: La variable TAGUA_TAGUA_STREAM_URL no est√° definida.";
                statusEl.className = 'forge-status error';
                return;
            }

            const position = getForgePosition(); // ¬°Obtenemos la posici√≥n!

            crearNuevoPulsar(nombre, url, position, tipo, esMajestuoso);

            statusEl.textContent = `¬°√âxito! Radio Tagua Tagua forjada en ${position.x.toFixed(0)}, ${position.y.toFixed(0)}, ${position.z.toFixed(0)}`;
            statusEl.className = 'forge-status';
        }

        /**
         * Funci√≥n central que crea la nebulosa y la registra en el gestor de p√∫lsares.
         * (Esta funci√≥n es para fuentes basadas en URL: MP3 o Stream)
         */
        function crearNuevoPulsar(nombre, url, position, tipo, esMajestuoso) {
            
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const audioElement = new Audio();
            audioElement.crossOrigin = "anonymous";
            audioElement.loop = true;
            
            const analyserNode = audioContext.createAnalyser();
            analyserNode.fftSize = 512;
            analyserNode.smoothingTimeConstant = 0.75;
            
            const positionalAudio = new THREE.PositionalAudio(audioListener);
            positionalAudio.setRefDistance(40);
            positionalAudio.setRolloffFactor(1.0);
            positionalAudio.setMaxDistance(3000); 

            const config = esMajestuoso ? TAGUA_TAGUA_CONFIG : GALAXY_PULSAR_CONFIG;
            const radioNebula = new RadioNebula(scene, position, analyserNode, config, tipo, esMajestuoso);
            
            radioNebula.particlesObject.add(positionalAudio);

            const pulsarId = `user_${tipo}_${Date.now()}`;
            
            gestorDePulsares.activos[pulsarId] = {
                id: pulsarId,
                nebula: radioNebula,
                audio: audioElement,      
                analyser: analyserNode,   
                positionalAudio: positionalAudio, 
                url: url,                 
                tiempoGuardado: 0,
                mediaSource: null,      
                isLoaded: false,        
                isPlaying: false
            };
            
            console.log(`P√∫lsar forjado con ID: ${pulsarId}`, gestorDePulsares.activos[pulsarId]);

            // A√±adir a la playlist 2D
            addTrackToPlaylist(nombre, url);
        }

        // --- FIN DE LA L√ìGICA DE FORJA DE P√öLSARES ---

        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            scene.fog = new THREE.FogExp2(0x000011, 0.0004); // Niebla m√°s sutil
            
            // A√±adir efecto de bloom para mejor apariencia
            const renderScene = new THREE.Scene();
            
            // Configurar c√°mara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            audioListener = new THREE.AudioListener();
            audioContext = audioListener.context;

            camera.add(audioListener);
            camera.position.set(0, 10, 20);
            
            // Crear renderer
            // Crear renderer
            // Crear renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Crear el efecto est√©reo DESPU√âS de haber creado el renderer



            // Iluminaci√≥n ambiental
            const ambientLight = new THREE.AmbientLight(0x101020);
            scene.add(ambientLight);

            // Luz direccional principal
            const directionalLight = new THREE.DirectionalLight(0x3333ff, 0.4);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Luz complementaria
            const backLight = new THREE.DirectionalLight(0x5544ee, 0.2);
            backLight.position.set(-1, -1, -1);
            scene.add(backLight);

            // Crear plano cartesiano con cuadr√≠cula
            gridHelper = new THREE.GridHelper(1000, 100, 0x333366, 0x222244);
            scene.add(gridHelper);

            // Crear avatar para representar al usuario
            createAvatar();

            initTabs(); // <--- A√ëADE ESTA LLAMADA
            initPlaylist(); // <--- A√ëADE ESTA LLAMADA
            //initAudioControls(); // <--- A√ëADE ESTA LLAMADA
            initMIDI();
            initForgeControls();         // <--- A√ëADE ESTA L√çNEA


// Todo bien hasta aqu√≠


            
            // Crear fondo estelar
            //createStarBackground(); - 
            proceduralGenerator = new ProceduralGenerator(scene);
            hyperspaceEffect = new HyperspaceEffect(scene, camera);


            // Crear galaxia personal
            galaxies[username] = new Galaxy(username, avatarObject.position.clone(), true); // true = es Local

            // Event listeners
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown); // <--- CAMBIO AQU√ç
            window.addEventListener('keyup', onKeyUp);   // <--- CAMBIO AQU√ç
            // Mejorado: Ahora usamos mousedown en el documento, pero verificamos si fue en el men√∫
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('wheel', onMouseWheel);

            // Dentro de tu funci√≥n init()
            isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);

            // Tambi√©n obt√©n las referencias a los elementos del DOM para los controles
            touchControlsContainer = document.getElementById('touch-controls');
            joystickContainer = document.getElementById('joystick-container');
            joystickKnob = document.getElementById('joystick-knob');
            buttonUp = document.getElementById('button-up');
            buttonDown = document.getElementById('button-down');

            if (isTouchDevice) {
                console.log("Touch device detected. Initializing touch controls.");
                if (touchControlsContainer) touchControlsContainer.style.display = 'block';
                document.body.classList.add('touch-active'); // Para CSS opcional
                initTouchControls();
            } else {
                console.log("Non-touch device detected.");
            }

            

            
            // Prevenir que los clics en el men√∫ cierren el arrastre
            document.getElementById('settingsMenu').addEventListener('mousedown', function(event) {
                event.stopPropagation(); // Evita que el evento llegue al documento
            });
            
            // Ocultar las instrucciones despu√©s de 20 segundos
            setTimeout(() => {
                const infoElement = document.getElementById('info');
                if (infoElement) {
                    infoElement.classList.add('fade-out');
                    
                    // Opcional: remover completamente el elemento despu√©s de la transici√≥n
                    setTimeout(() => {
                        infoElement.style.display = 'none';
                    }, 2100); // Un poco m√°s que el tiempo de transici√≥n
                }
            }, 8000);

            
            // Listener para los botones
            document.getElementById('btnSettings').addEventListener('click', function(event) {
                event.stopPropagation(); // Evita que el clic se propague al documento
                toggleSettingsMenu();
            });           
            document.getElementById('btnTeleport').addEventListener('click', toggleTeleportPanel);
            document.getElementById('btnGoToCoords').addEventListener('click', teleportToCoords);
            document.getElementById('btnPerspective').addEventListener('click', cycleViewMode);
            
            //document.getElementById('btnFirstPerson').addEventListener('click', () => setViewMode('firstPerson'));
            //document.getElementById('btnThirdPerson').addEventListener('click', () => setViewMode('thirdPerson'));
            //document.getElementById('btnBirdEye').addEventListener('click', () => setViewMode('birdEye'));
            
            document.getElementById('connectButton').addEventListener('click', connectToNetwork);
            document.getElementById('usernameInput').value = username;

            // Inicializar coordenadas de teletransporte con posici√≥n actual
            updateTeleportCoords();
            
            initStaticTaguaTaguaRadio(); // <--- A√ëADE ESTA L√çNEA

            // Iniciar animaci√≥n
            animate();

            // A√ëADIR ESTAS L√çNEAS EN init()
            // ----------------------------------------------------
            nebulaRadarElement = document.getElementById('nebulaRadar');
            radarArrowElement = document.getElementById('radarArrow');
            radarDotElement = document.getElementById('radarDot');
            // En el radar de pulsar10.html hab√≠a dos puntos. Por ahora solo usaremos uno.
            // Ocultamos el segundo por si lo usamos despu√©s para la radio.
            const radarDotTaguaTagua = document.getElementById('radarDotTaguaTagua');
            if(radarDotTaguaTagua) radarDotTaguaTagua.style.display = 'none';

                    // A√ëADIMOS LA CONFIGURACI√ìN DE CAPAS PARA LA C√ÅMARA
            camera.layers.enableAll(); // Nos aseguramos de que la c√°mara vea todas las capas...
            camera.layers.disable(CLICKABLE_LAYER); // ...excepto nuestra capa especial para clics.
            // ----------------------------------------------------
        }

        // Llama a esta funci√≥n desde tu init() principal:
        // if (isTouchDevice) {
        //     console.log("Touch device detected. Initializing touch controls.");
        //     touchControlsContainer.style.display = 'block'; // Mostrar contenedor de controles
        //     document.body.classList.add('touch-active'); // Para deshabilitar scroll del navegador
        //     initTouchControls();
        // } else {
        //     console.log("Non-touch device detected.");
        // }

        function initTouchControls() {
            // Joystick de Movimiento (Izquierda)
            joystickKnob.addEventListener('touchstart', handleJoystickStart, { passive: false });
            document.addEventListener('touchmove', handleJoystickMove, { passive: false });
            document.addEventListener('touchend', handleJoystickEnd, { passive: false });
            document.addEventListener('touchcancel', handleJoystickEnd, { passive: false });

            // Joystick de rotaci√≥n
            const joystickKnobRotation = document.getElementById('joystick-knob-rotation');
            joystickKnobRotation.addEventListener('touchstart', handleRotationJoystickStart, { passive: false });
            document.addEventListener('touchmove', handleRotationJoystickMove, { passive: false });
            document.addEventListener('touchend', handleRotationJoystickEnd, { passive: false });
            document.addEventListener('touchcancel', handleRotationJoystickEnd, { passive: false });
            
            // --> A√ëADIDO: L√≥gica para el bot√≥n de hipervelocidad
            const buttonHyperspace = document.getElementById('button-hyperspace');
            buttonHyperspace.addEventListener('touchstart', () => {
                hyperspaceModeActive = !hyperspaceModeActive; // Alterna el estado
                if (hyperspaceEffect) {
                    hyperspaceEffect.toggleHyperspace(hyperspaceModeActive);
                }
                // Alterna la clase 'active' para el feedback visual
                buttonHyperspace.classList.toggle('active', hyperspaceModeActive);
            }, { passive: true });


            // Control de c√°mara t√°ctil (arrastre y pinch-to-zoom) - Se mantiene igual
            renderer.domElement.addEventListener('touchstart', handleTouchCameraAndPinchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouchCameraAndPinchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleTouchCameraAndPinchEnd, { passive: false });
            renderer.domElement.addEventListener('touchcancel', handleTouchCameraAndPinchEnd, { passive: false });
        }

        function handleJoystickStart(event) {
            event.preventDefault();
            // L√≥gica original de inicio de movimiento (sin doble toque)
            if (event.target === joystickKnob && touchIdentifierJoystick === null) {
                joystickActive = true;
                touchIdentifierJoystick = event.changedTouches[0].identifier;
                const touch = event.changedTouches[0];
                joystickInitialPos.x = touch.clientX;
                joystickInitialPos.y = touch.clientY;
                joystickKnob.style.backgroundColor = 'rgba(120, 120, 180, 0.9)';
            }
        }


        function handleJoystickMove(event) {
            if (!joystickActive || touchIdentifierJoystick === null) return;
            event.preventDefault();

            let touch = null;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === touchIdentifierJoystick) {
                    touch = event.changedTouches[i];
                    break;
                }
            }
            if (!touch) return; 

            const deltaX = touch.clientX - joystickInitialPos.x;
            const deltaY = touch.clientY - joystickInitialPos.y;
            let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX);

            let knobX = deltaX;
            let knobY = deltaY;

            if (distance > joystickMaxDistance) {
                knobX = Math.cos(angle) * joystickMaxDistance;
                knobY = Math.sin(angle) * joystickMaxDistance;
            }
            
            joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;

            const threshold = joystickMaxDistance * 0.2; 
            
            // --> INVERSI√ìN CORREGIDA AQU√ç
            // Hacemos que coincida con el comportamiento de las teclas W/S en tercera persona
            moveBackward = knobY < -threshold;   // Arriba en el joystick ahora es 'moveBackward'
            moveForward = knobY > threshold;    // Abajo en el joystick ahora es 'moveForward'
            
            moveLeft = knobX < -threshold;      
            moveRight = knobX > threshold;     
        }

        function handleJoystickEnd(event) {
            if (touchIdentifierJoystick === null) return;

            let touchEndedOnJoystick = false;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === touchIdentifierJoystick) {
                    touchEndedOnJoystick = true;
                    break;
                }
            }

            if (touchEndedOnJoystick) {
                joystickActive = false;
                touchIdentifierJoystick = null; // Liberar identificador
                joystickKnob.style.transform = `translate(0px, 0px)`; // Reset visual
                joystickKnob.style.backgroundColor = 'rgba(100, 100, 150, 0.7)';
                
                // Resetear variables de movimiento (CONECTA ESTO CON TUS VARIABLES)
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;
            }
        }

        function handleTouchCameraAndPinchStart(event) {
            // Ignorar si el toque es en los controles del joystick o botones
            if (event.target === joystickKnob || event.target === buttonUp || event.target === buttonDown ||
                (joystickContainer && joystickContainer.contains(event.target)) ||
                (document.getElementById('action-buttons-container') && document.getElementById('action-buttons-container').contains(event.target))
            ) {
                return;
            }
            event.preventDefault();

            if (event.touches.length === 1 && touchIdentifierCamera === null && touchIdentifierJoystick !== event.touches[0].identifier) {
                // Inicio de arrastre con un dedo para c√°mara
                isDragging = true; // Reutilizar la bandera del rat√≥n
                const touch = event.touches[0];
                touchIdentifierCamera = touch.identifier;
                touchCameraInitialPos.x = touch.clientX;
                touchCameraInitialPos.y = touch.clientY;
                document.body.classList.add('dragging'); // Opcional, para feedback visual
                initialPinchDistance = null; // Resetear pinch
                touchIdentifierPinch1 = null;
                touchIdentifierPinch2 = null;

            } else if (event.touches.length === 2) {
                // Inicio de gesto de "pinch" con dos dedos
                isDragging = false; // Detener el arrastre de c√°mara si estaba activo
                touchIdentifierCamera = null; // Liberar el dedo de la c√°mara

                touchIdentifierPinch1 = event.touches[0].identifier;
                touchIdentifierPinch2 = event.touches[1].identifier;
                initialPinchDistance = getPinchDistance(event.touches);
                document.body.classList.add('dragging'); // Opcional
            }
        }

        // --- A√ëADIDO: Funciones para el Joystick de Rotaci√≥n y Elevaci√≥n (Derecha) ---

        function handleRotationJoystickStart(event) {
            event.preventDefault();
            const joystickKnobRotation = document.getElementById('joystick-knob-rotation');
            if (event.target === joystickKnobRotation && touchIdentifierRotationJoystick === null) {
                rotationJoystickActive = true;
                touchIdentifierRotationJoystick = event.changedTouches[0].identifier;
                const touch = event.changedTouches[0];
                rotationJoystickInitialPos.x = touch.clientX;
                rotationJoystickInitialPos.y = touch.clientY;
                joystickKnobRotation.style.backgroundColor = 'rgba(120, 120, 180, 0.9)';
            }
        }

        function handleRotationJoystickMove(event) {
            if (!rotationJoystickActive || touchIdentifierRotationJoystick === null) return;
            event.preventDefault();

            let touch = null;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === touchIdentifierRotationJoystick) {
                    touch = event.changedTouches[i];
                    break;
                }
            }
            if (!touch) return;

            const joystickKnobRotation = document.getElementById('joystick-knob-rotation');
            const deltaX = touch.clientX - rotationJoystickInitialPos.x;
            const deltaY = touch.clientY - rotationJoystickInitialPos.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX);

            let knobX = deltaX;
            let knobY = deltaY;

            if (distance > joystickMaxDistance) {
                knobX = Math.cos(angle) * joystickMaxDistance;
                knobY = Math.sin(angle) * joystickMaxDistance;
            }
            
            joystickKnobRotation.style.transform = `translate(${knobX}px, ${knobY}px)`;

            const threshold = joystickMaxDistance * 0.2;
            
            moveUp = knobY < -threshold;
            moveDown = knobY > threshold;
            
            // --> INVERSI√ìN CORREGIDA AQU√ç
            rotateCameraRight = knobX < -threshold; // Mover a la izquierda ahora rota a la DERECHA
            rotateCameraLeft = knobX > threshold;  // Mover a la derecha ahora rota a la IZQUIERDA
        }

        function handleRotationJoystickEnd(event) {
            if (touchIdentifierRotationJoystick === null) return;

            let touchEndedOnJoystick = false;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === touchIdentifierRotationJoystick) {
                    touchEndedOnJoystick = true;
                    break;
                }
            }

            if (touchEndedOnJoystick) {
                const joystickKnobRotation = document.getElementById('joystick-knob-rotation');
                rotationJoystickActive = false;
                touchIdentifierRotationJoystick = null;
                joystickKnobRotation.style.transform = `translate(0px, 0px)`;
                joystickKnobRotation.style.backgroundColor = 'rgba(100, 100, 150, 0.7)';
                
                // Resetear variables de rotaci√≥n y elevaci√≥n
                moveUp = false;
                moveDown = false;
                rotateCameraLeft = false;
                rotateCameraRight = false;
            }
        }

        function handleTouchCameraAndPinchMove(event) {
            if (!isDragging && initialPinchDistance === null) return; // Ninguna acci√≥n t√°ctil activa
            event.preventDefault();

            if (isDragging && touchIdentifierCamera !== null && event.touches.length === 1) {
                // Mover c√°mara con un dedo
                let touch = null;
                for (let i = 0; i < event.changedTouches.length; i++) {
                    if (event.changedTouches[i].identifier === touchIdentifierCamera) {
                        touch = event.changedTouches[i];
                        break;
                    }
                }
                if (!touch) return;

                const deltaX = touch.clientX - touchCameraInitialPos.x;
                const deltaY = touch.clientY - touchCameraInitialPos.y;

                // CONECTA ESTO CON TUS VARIABLES DE ROTACI√ìN DE C√ÅMARA
                // Ejemplo basado en tu c√≥digo `index - copia.html`:
                yawAngle -= deltaX * mouseSensitivity * 1.5; // Aumentar sensibilidad para t√°ctil
                pitchAngle -= deltaY * mouseSensitivity * 1.5;
                pitchAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchAngle)); // Limitar pitch

                touchCameraInitialPos.x = touch.clientX;
                touchCameraInitialPos.y = touch.clientY;

                // Llama a tu funci√≥n que actualiza la posici√≥n/rotaci√≥n de la c√°mara
                // updateCameraPosition(); // Ya se llama en animate()

            } else if (initialPinchDistance !== null && event.touches.length === 2) {
                // Mover "pinch-to-zoom" con dos dedos
                // Asegurarse de que los dedos son los mismos que iniciaron el gesto
                let t1 = null, t2 = null;
                for(let i=0; i < event.touches.length; i++) {
                    if(event.touches[i].identifier === touchIdentifierPinch1) t1 = event.touches[i];
                    if(event.touches[i].identifier === touchIdentifierPinch2) t2 = event.touches[i];
                }

                if (t1 && t2) {
                    const currentPinchDistance = getPinchDistance(event.touches);
                    const deltaDistance = currentPinchDistance - initialPinchDistance;

                    // CONECTA ESTO CON TU VARIABLE DE ZOOM O DISTANCIA DE C√ÅMARA
                    // Ejemplo basado en tu c√≥digo `index - copia.html` (cameraOffset.z o cameraOffset.y):
                    if (currentViewMode === 'thirdPerson') {
                        cameraOffset.z -= deltaDistance * pinchZoomSensitivity;
                        cameraOffset.z = Math.max(5, Math.min(30, cameraOffset.z)); // Usa tus l√≠mites
                    } else if (currentViewMode === 'birdEye') {
                        cameraOffset.y -= deltaDistance * pinchZoomSensitivity; // En vista de p√°jaro, el zoom puede afectar la altura
                        cameraOffset.y = Math.max(10, Math.min(50, cameraOffset.y)); // Usa tus l√≠mites
                    } else if (currentViewMode === 'firstPerson') {
                        // En primera persona, el pinch podr√≠a controlar el FOV de la c√°mara
                        // camera.fov -= deltaDistance * pinchZoomSensitivity * 0.1;
                        // camera.fov = Math.max(30, Math.min(100, camera.fov));
                        // camera.updateProjectionMatrix();
                        // O simplemente no hacer nada con el zoom en primera persona.
                    }
                    // Llama a tu funci√≥n que actualiza la posici√≥n/rotaci√≥n de la c√°mara
                    // updateCameraPosition(); // Ya se llama en animate()
                    initialPinchDistance = currentPinchDistance; // Actualizar para el siguiente movimiento
                }
            }
        }

        function handleTouchCameraAndPinchEnd(event) {
            // Comprobar si el dedo que controlaba la c√°mara se ha levantado
            let cameraTouchEnded = false;
            if (touchIdentifierCamera !== null) {
                for (let i = 0; i < event.changedTouches.length; i++) {
                    if (event.changedTouches[i].identifier === touchIdentifierCamera) {
                        cameraTouchEnded = true;
                        break;
                    }
                }
            }
            if (cameraTouchEnded || (isDragging && event.touches.length === 0)) {
                isDragging = false;
                touchIdentifierCamera = null;
                document.body.classList.remove('dragging');
            }

            // Comprobar si uno de los dedos del pinch se ha levantado
            let pinchTouchEnded = false;
            if (touchIdentifierPinch1 !== null || touchIdentifierPinch2 !== null) {
                for (let i = 0; i < event.changedTouches.length; i++) {
                    if (event.changedTouches[i].identifier === touchIdentifierPinch1 ||
                        event.changedTouches[i].identifier === touchIdentifierPinch2) {
                        pinchTouchEnded = true;
                        break;
                    }
                }
            }
            if (pinchTouchEnded || (initialPinchDistance !== null && event.touches.length < 2)) {
                initialPinchDistance = null;
                touchIdentifierPinch1 = null;
                touchIdentifierPinch2 = null;
                if (!isDragging) { // Solo quitar 'dragging' si no hay otra acci√≥n activa
                    document.body.classList.remove('dragging');
                }
            }
            // Si no quedan dedos en la pantalla, asegurarse de resetear todo
            if (event.touches.length === 0) {
                isDragging = false;
                touchIdentifierCamera = null;
                initialPinchDistance = null;
                touchIdentifierPinch1 = null;
                touchIdentifierPinch2 = null;
                document.body.classList.remove('dragging');
            }
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Crear avatar para representar al usuario
        function createAvatar() {
            // Cambiar la geometr√≠a de cono a esfera
            // El radio de la esfera ser√≠a aproximadamente 1 para mantener un tama√±o similar
            const geometry = new THREE.SphereGeometry(1, 16, 12); // Esfera con 16 segmentos horizontales y 12 verticales
            
            // Mantener el mismo material con las propiedades existentes
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x4488ff,
                emissive: 0x112244,
                transparent: true,
                opacity: 0.6,
                shininess: 30,
                flatShading: false
            });
            
            avatarObject = new THREE.Mesh(geometry, material);
            avatarObject.position.set(0, 0, 0);
            
            // No necesitamos rotar la esfera en el eje X como hac√≠amos con el cono
            // ya que una esfera es sim√©trica en todos los ejes
            // avatarObject.rotation.x = Math.PI / 2; // Esta l√≠nea se elimina
            
            avatarObject.castShadow = true;
            scene.add(avatarObject);
            
            // A√±adir un peque√±o punto de luz al avatar (mantener igual)
            const avatarLight = new THREE.PointLight(0x4488ff, 0.7, 10);
            avatarLight.position.set(0, 0, 0);
            avatarObject.add(avatarLight);
            
            // Actualizar posici√≥n inicial de la c√°mara
            updateCameraPosition();
        }

        // Crear fondo estelar mejorado
        function createStarBackground() {
            // Estrellas lejanas m√°s numerosas
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: false
            });
            
            const starsVertices = [];
            for (let i = 0; i < 20000; i++) {
                const x = THREE.MathUtils.randFloatSpread(2000);
                const y = THREE.MathUtils.randFloatSpread(2000);
                const z = THREE.MathUtils.randFloatSpread(2000);
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
            
            // Nebulosas distantes mejoradas
            for (let i = 0; i < 12; i++) {
                createNebula();
            }
        }
        // Almacenar las nebulosas para animaci√≥n
        const nebulaeObjects = [];
        // Crear una nebulosa con mejor apariencia
        function createNebula() {
            const geometry = new THREE.BufferGeometry();
            const particles = 3000;  // M√°s part√≠culas para mejor densidad
            
            const positions = new Float32Array(particles * 3);
            const colors = new Float32Array(particles * 3);
            const sizes = new Float32Array(particles);
            
            // M√°s variedad de colores de nebulosas
            const nebulaTypes = [
                {hue: 0.6, sat: 0.7, name: "Azul"},        // Azul
                {hue: 0.3, sat: 0.5, name: "Verde"},       // Verde
                {hue: 0.05, sat: 0.8, name: "Naranja"},    // Naranja
                {hue: 0.75, sat: 0.6, name: "P√∫rpura"},    // P√∫rpura
                {hue: 0.95, sat: 0.7, name: "Rosa"},       // Rosa
                {hue: 0.15, sat: 0.65, name: "√Åmbar"},     // √Åmbar
                {hue: 0.52, sat: 0.5, name: "Turquesa"}    // Turquesa
            ];
            
            const selectedType = nebulaTypes[Math.floor(Math.random() * nebulaTypes.length)];
            const color = new THREE.Color();
            color.setHSL(selectedType.hue, selectedType.sat, 0.5);
            
            // Posici√≥n aleatoria de la nebulosa
            const position = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(1200),
                THREE.MathUtils.randFloatSpread(1200),
                THREE.MathUtils.randFloatSpread(1200)
            );
            
            // Crear nebulosa m√°s grande
            const nebulaSize = 80 + Math.random() * 150;
            
            // Definir forma m√°s natural
            for (let i = 0; i < particles; i++) {
                // Distribuci√≥n gaussiana para forma m√°s realista
                let radius = Math.random();
                radius = Math.pow(radius, 1.5) * nebulaSize; // Distribuci√≥n que favorece el centro
                
                // Forma esf√©rica con aplastamiento
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                // Distorsi√≥n para crear forma de nebulosa
                const distortion = 0.6 + Math.random() * 0.8;
                
                // Coordenadas en polares
                const x = radius * Math.sin(phi) * Math.cos(theta) * distortion;
                const y = radius * Math.sin(phi) * Math.sin(theta) * 0.5; // Aplanar en Y
                const z = radius * Math.cos(phi) * distortion;
                
                // Posiciones
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Color con variaci√≥n sutil
                const hue = selectedType.hue + (Math.random() - 0.5) * 0.1;
                const c = new THREE.Color().setHSL(hue, selectedType.sat, 0.5 + Math.random() * 0.2);
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
                
                // Tama√±os variables
                sizes[i] = 2 + Math.pow(Math.random(), 2) * 12;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Material con mejor mezcla
            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.25,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const nebula = new THREE.Points(geometry, material);
            
            // Posici√≥n global de la nebulosa
            nebula.position.copy(position);
            
            // Par√°metros de rotaci√≥n y movimiento √∫nicos para cada nebulosa
            const nebulaData = {
                object: nebula,
                // Rotaci√≥n lenta y aleatoria en cada eje
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.002,
                    y: (Math.random() - 0.5) * 0.002,
                    z: (Math.random() - 0.5) * 0.002
                },
                // Movimiento en elipse lento
                movementPath: {
                    center: position.clone(),
                    amplitude: {
                        x: 20 + Math.random() * 50,
                        y: 20 + Math.random() * 50,
                        z: 20 + Math.random() * 50
                    },
                    phase: {
                        x: Math.random() * Math.PI * 2,
                        y: Math.random() * Math.PI * 2,
                        z: Math.random() * Math.PI * 2
                    },
                    speed: {
                        x: (Math.random() - 0.5) * 0.005,
                        y: (Math.random() - 0.5) * 0.005,
                        z: (Math.random() - 0.5) * 0.005
                    }
                }
            };
            
            // A√±adir a la escena
            scene.add(nebula);
            
            // Almacenar para animaci√≥n
            nebulaeObjects.push(nebulaData);
        }

        // Modificar la funci√≥n animate para animar las nebulosas
        function animateNebulae() {
            const time = Date.now() * 0.001; // Tiempo muy lento para movimiento suave
            
            nebulaeObjects.forEach(nebulaData => {
                const { object, rotationSpeed, movementPath } = nebulaData;
                
                // Rotaci√≥n
                object.rotation.x += rotationSpeed.x;
                object.rotation.y += rotationSpeed.y;
                object.rotation.z += rotationSpeed.z;
                
                // Movimiento en elipse
                object.position.x = movementPath.center.x + 
                    Math.sin(time * movementPath.speed.x + movementPath.phase.x) * movementPath.amplitude.x;
                
                object.position.y = movementPath.center.y + 
                    Math.cos(time * movementPath.speed.y + movementPath.phase.y) * movementPath.amplitude.y;
                
                object.position.z = movementPath.center.z + 
                    Math.sin(time * movementPath.speed.z + movementPath.phase.z) * movementPath.amplitude.z;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        
        
        
        // 1. INTERCAMBIAR LA ASIGNACI√ìN DE TECLAS EN LA FUNCI√ìN onKeyDown

        function onKeyDown(event) {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // L√≥gica de control 3D (con prioridad m√°xima)
            if (event.code === 'Digit3' || event.code === 'Numpad3') {
                isStereoMode = !isStereoMode;
                console.log("Modo Cross-Eyed:", isStereoMode ? "Activado" : "Desactivado");
                if (!isStereoMode) resetStereoStateToNormal(); // (opcional, pero ayuda)
                return; // importante para que no siga procesando esta tecla
                }

            if (isStereoMode) {
                if (event.code === 'Digit9' || event.code === 'Numpad9') {
                    // Aumentamos la separaci√≥n sin un l√≠mite superior estricto
                    eyeSeparation += 0.01; 
                    console.log("Separaci√≥n de Ojos:", eyeSeparation.toFixed(4));
                    return; 
                }
                if (event.code === 'Digit0' || event.code === 'Numpad0') {
                    // Eliminamos el tope de '0.01' para permitir valores negativos
                    eyeSeparation -= 0.01;
                    console.log("Separaci√≥n de Ojos:", eyeSeparation.toFixed(4));
                    return;
                }
            

            }


            // Comprobaci√≥n del sintetizador (ahora est√° despu√©s de los controles 3D)
            if (window.alienSynth && window.alienSynth.isKeyInhibited(event.key.toLowerCase())) {
                return;
            }


            // A√ëADIDO: Verificamos si estamos en modo √≥rbita
            if (isOrbitingNebula) {
                
                // --- L√≥gica de controles MIENTRAS se est√° en √≥rbita ---
                const orbitSpeedIncrement = 0.002; // Velocidad de movimiento en la √≥rbita
                const distanceChangeSpeed = 0.8;   // Velocidad para acercarse/alejarse

                switch (event.code) {
                    case 'KeyW':
                        orbitDistance -= ORBIT_ZOOM_SPEED;
                        // A√±adimos los l√≠mites para que no se acerque o aleje infinitamente
                        orbitDistance = Math.max(MIN_ORBIT_DISTANCE, Math.min(MAX_ORBIT_DISTANCE, orbitDistance));
                        break;
                    case 'KeyS':
                        orbitDistance += ORBIT_ZOOM_SPEED;
                        // Repetimos los mismos l√≠mites aqu√≠
                        orbitDistance = Math.max(MIN_ORBIT_DISTANCE, Math.min(MAX_ORBIT_DISTANCE, orbitDistance));
                        break;
                    case 'KeyA':
                        // Aumentamos la velocidad orbital hacia la izquierda
                        playerOrbitSpeed = orbitSpeedIncrement;
                        break;
                    case 'KeyD':
                        // Aumentamos la velocidad orbital hacia la derecha
                        playerOrbitSpeed = -orbitSpeedIncrement;
                        break;
                    case 'Space':
                        // Activamos el hipersalto (que acelerar√° todo en 'animate')
                        hyperspaceModeActive = true;
                        break;
                    case 'KeyC': // La tecla C para entrar en √≥rbita ya est√° manejada, la dejamos por si acaso
                        if (event.shiftKey) { 
                            isOrbitingNebula = false;
                            orbitingNebulaInstance = null;
                            if (galaxies[username] && galaxies[username].pixelGalaxy) {
                                galaxies[username].pixelGalaxy.pixelObject.visible = true;
                            }
                        }            
                        break;
                    // Dentro del switch del modo √≥rbita, por ejemplo, despu√©s del case 'KeyC'
                    case 'KeyV':
                        cycleViewMode();
                        break;

                    
                    // --- FIN DEL BLOQUE A A√ëADIR ---


                    // --- ¬°NUEVAS L√çNEAS AQU√ç! ---
                    case 'Digit1': // Tecla '1'
                        if (currentOrbitType !== 'fixed') {
                            console.log("Cambiando a modo de √≥rbita 'fija'.");
                            currentOrbitType = 'fixed';
                            // Opcional: Si quieres que la c√°mara se reinicie al frente del avatar en modo fijo:
                            // pitchAngle = 0;
                            // yawAngle = avatarObject.rotation.y;
                        }
                        break;
                    case 'Digit2': // Tecla '2'
                        if (currentOrbitType !== 'comet') {
                            console.log("Cambiando a modo de √≥rbita 'cometa'.");
                            currentOrbitType = 'comet';
                        }
                        break;
                    
                        
                        
                }

            } else {
                // --- L√≥gica de controles en VUELO LIBRE (tu c√≥digo original) ---
                switch (event.code) {
                    case 'KeyW':
                        if (currentViewMode === 'thirdPerson') { moveBackward = true; } else { moveForward = true; }
                        break;
                    case 'KeyS':
                        if (currentViewMode === 'thirdPerson') { moveForward = true; } else { moveBackward = true; }
                        break;
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'KeyD':
                        moveRight = true;
                        break;
                    case 'KeyZ':
                        moveUp = true;
                        break;
                    case 'KeyX':
                        moveDown = true;
                        break;
                    case 'KeyT':
                        toggleTeleportPanel();
                        break;
                    case 'KeyV':
                        if (!(window.alienSynth && window.alienSynth.isKeyInhibited('p'))) { cycleViewMode(); }
                        break;
                    case 'KeyQ':
                        rotateCameraLeft = true;
                        break;
                    case 'KeyE':
                        rotateCameraRight = true;
                        break;
                    case 'Space':
                        hyperspaceModeActive = true;
                        if (hyperspaceEffect) { hyperspaceEffect.toggleHyperspace(true); }
                        break;
                    case 'KeyC':
                        if (event.shiftKey) {
                            isOrbitingNebula = false;
                            orbitingNebulaInstance = null;
                            if (galaxies[username] && galaxies[username].pixelGalaxy) {
                                galaxies[username].pixelGalaxy.pixelObject.visible = true;
                            }
                        } else {
                            if (!isOrbitingNebula) {
                                const RANGO_DE_INTERACCION_ORBITA = 400;
                                let pulsarMasCercano = null;
                                let distanciaMinima = Infinity;

                                for (const pulsarId in gestorDePulsares.activos) {
                                    const pulsar = gestorDePulsares.activos[pulsarId];
                                    if (!pulsar.nebula.particlesObject.visible) continue;
                                    const distancia = avatarObject.position.distanceTo(pulsar.nebula.particlesObject.position);
                                    if (distancia < distanciaMinima) {
                                        distanciaMinima = distancia;
                                        pulsarMasCercano = pulsar;
                                    }
                                }

                                if (pulsarMasCercano && distanciaMinima < RANGO_DE_INTERACCION_ORBITA) {
                                    console.log("Iniciando √≥rbita alrededor de:", pulsarMasCercano.id);
                                    isOrbitingNebula = true;
                                    orbitingNebulaInstance = pulsarMasCercano;
                                    orbitDistance = distanciaMinima;
                                    
                                    const dirToPulsar = new THREE.Vector3().subVectors(orbitingNebulaInstance.nebula.initialStaticPosition, avatarObject.position);
                                    orbitAngle = Math.atan2(dirToPulsar.z, dirToPulsar.x);

                                    if (galaxies[username] && galaxies[username].pixelGalaxy) {
                                        galaxies[username].pixelGalaxy.pixelObject.visible = false;
                                    }
                                }
                            }
                        }
                        break;
                }
            }
        }
            
        

        // REEMPLAZA TU onKeyUp ENTERA CON ESTA VERSI√ìN
            function onKeyUp(event) {
                // Si estamos en √≥rbita, manejamos las teclas de √≥rbita
                if (isOrbitingNebula) {
                    switch (event.code) {
                        case 'KeyA':
                        case 'KeyD':
                            // Al soltar A o D, la velocidad orbital vuelve a cero
                            playerOrbitSpeed = 0.0;
                            break;
                        case 'Space':
                            // Desactivamos el hipersalto
                            hyperspaceModeActive  = false;
                            break;
                    }
                } else {
                    // L√≥gica de VUELO LIBRE (tu c√≥digo original)
                    switch (event.code) {
                        case 'KeyW':
                            if (currentViewMode === 'thirdPerson') { moveBackward = false; } else { moveForward = false; }
                            break;
                        case 'KeyS':
                            if (currentViewMode === 'thirdPerson') { moveForward = false; } else { moveBackward = false; }
                            break;
                        case 'KeyA':
                            moveLeft = false;
                            break;
                        case 'KeyD':
                            moveRight = false;
                            break;
                        case 'KeyZ':
                            moveUp = false;
                            break;
                        case 'KeyX':
                            moveDown = false;
                            break;
                        case 'KeyQ':
                            rotateCameraLeft = false;
                            break;
                        case 'KeyE':
                            rotateCameraRight = false;
                            break;
                        case 'Space':
                            hyperspaceModeActive = false;
                            if (hyperspaceEffect) { hyperspaceEffect.toggleHyperspace(false); }
                            break;
                    }
                }
            }
        
        // MEJORADO: Control del mouse para mejor navegaci√≥n
        function onMouseDown(event) {
            console.log("--- INICIO DEL CLIC ---"); // Chivato 1: Para saber que la funci√≥n se ejecuta.

            if (audioContext && audioContext.state === 'suspended') {
           audioContext.resume();
    }
                // Mantenemos las verificaciones de siempre
            if (isTouchDevice && joystickActive) return;
            if (isTouchDevice && isDragging && touchIdentifierCamera !== null) return;
            if (isClickOnMenu(event)) return;
            if (event.button !== 0) return;

            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };

            // --- L√ìGICA DE DETECCI√ìN CORRECTA ---
            mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
            mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.layers.set(CLICKABLE_LAYER); // <-- A√ëADE ESTA L√çNEA

            raycaster.setFromCamera(mousePosition, camera);

            // 1. Creamos la lista de blancos buscando en gestorDePulsares.activos
            const clickableTargets = [];
            for (const pulsarId in gestorDePulsares.activos) {
                const pulsar = gestorDePulsares.activos[pulsarId];
                // Asegurarnos de que el pulsar y su blanco invisible existan
                if (pulsar && pulsar.nebula && pulsar.nebula.nebulaClickTarget) {
                    clickableTargets.push(pulsar.nebula.nebulaClickTarget);
                }
            }

            // Chivato 2: Para saber cu√°ntos p√∫lsares est√° intentando detectar.
             console.log("P√∫lsares encontrados para hacer clic:", clickableTargets.length);


            // Si hay blancos que comprobar, lanzamos el rayo
            if (clickableTargets.length > 0) {
                const intersects = raycaster.intersectObjects(clickableTargets);

                if (intersects.length > 0) {
                    console.log("¬°√âXITO! El rayo ha chocado con un objeto:", intersects[0].object);

                    // ¬°Click sobre un p√∫lsar!
                    const clickedTarget = intersects[0].object;
                    // Usamos la referencia que guardamos para saber qu√© p√∫lsar es
                    draggedPulsar = clickedTarget.parentNebula;

                    if (draggedPulsar) {
                                        // Chivato 4: Confirma que hemos "agarrado" el p√∫lsar.
                        console.log("P√∫lsar 'agarrado' exitosamente:", draggedPulsar);

                        draggedPulsar.isBeingDragged = true;
                        draggedPulsar.momentumVelocity.set(0, 0, 0);
                    }
        } else {
            console.log("FALLO: El rayo fue lanzado, pero no choc√≥ con ning√∫n blanco.");
        }
    } else {
        console.log("AVISO: No hay p√∫lsares activos en la lista de clicables.");
    }
     console.log("--- FIN DEL CLIC ---");
}
        
        function isClickOnMenu(event) {
            // Verificar si el clic fue dentro del men√∫ de configuraci√≥n
            const settingsMenu = document.getElementById('settingsMenu');
            if (settingsMenu.style.display === 'block') {
                const rect = settingsMenu.getBoundingClientRect();
                if (event.clientX >= rect.left && event.clientX <= rect.right &&
                    event.clientY >= rect.top && event.clientY <= rect.bottom) {
                    return true;
                }
            }
            return false;
        }
        
        function onMouseUp(event) {
            // Verificaciones para controles t√°ctiles
            if (isTouchDevice && joystickActive) return;
            if (isTouchDevice && isDragging && touchIdentifierCamera !== null) return;

            // L√≥gica para soltar el p√∫lsar
            if (draggedPulsar) {
                draggedPulsar.isBeingDragged = false;
                draggedPulsar = null;
            }

            // Desactivamos el arrastre general
            isDragging = false;
        }
        
        function onMouseMove(event) {
            // Mantenemos las verificaciones para dispositivos t√°ctiles
            if (isTouchDevice && (joystickActive || touchIdentifierCamera !== null)) return;

            // Solo hacemos algo si el bot√≥n del rat√≥n est√° presionado
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                if (isOrbitingNebula) {
                // --- ¬°REEMPLAZA ESTE BLOQUE COMPLETO! ---
                if (currentOrbitType === 'fixed') {
                    // MODO FIJO: El rat√≥n controla la rotaci√≥n de la C√ÅMARA
                    yawAngle -= deltaX * mouseSensitivity;
                    pitchAngle -= deltaY * mouseSensitivity * 0.5;
                    const LIMIT = 1.56; 
                    pitchAngle = Math.max(-LIMIT, Math.min(LIMIT, pitchAngle));
                    
                    avatarObject.rotation.y = yawAngle;
            } else { // currentOrbitType === 'comet'
                // MODO COMETA: El rat√≥n controla directamente el √ÅNGULO de la √ìRBITA
                const orbitMouseSensitivity = 0.005;
                orbitAngle -= deltaX * orbitMouseSensitivity;
            }
            // --- FIN DEL REEMPLAZO ---


                } else {
                    // --- MODO VUELO LIBRE: El comportamiento se mantiene como lo ten√≠as ---
                    yawAngle -= deltaX * mouseSensitivity;
                    pitchAngle -= deltaY * mouseSensitivity * 0.5;
                    pitchAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchAngle));
                    avatarObject.rotation.y = yawAngle;
                }

                // Actualizamos la posici√≥n previa del rat√≥n para el siguiente fotograma
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }

            // Actualizamos la posici√≥n de la c√°mara solo en vuelo libre,
            // ya que en modo √≥rbita se calcula dentro de animate().
            if (!isOrbitingNebula) {
                updateCameraPosition();
            }
        }





        
        function onMouseWheel(event) {
            const zoomSpeed = 0.5;
            const delta = Math.sign(event.deltaY) * zoomSpeed;
            
            // A√ëADIDO: Si estamos orbitando, la rueda cambia la distancia de la √≥rbita
            if (isOrbitingNebula) {
                orbitDistance += delta * 5; // Aumentamos el multiplicador para que se sienta m√°s r√°pido
                // A√±adimos l√≠mites para no alejarse o acercarse demasiado
                orbitDistance = Math.max(MIN_ORBIT_DISTANCE, Math.min(MAX_ORBIT_DISTANCE, orbitDistance));
            } else {
                // L√≥gica de VUELO LIBRE (tu c√≥digo original)
                if (currentViewMode === 'thirdPerson') {
                    cameraOffset.z += delta;
                    cameraOffset.z = Math.max(5, Math.min(30, cameraOffset.z));
                } else if (currentViewMode === 'birdEye') {
                    cameraOffset.y += delta;
                    cameraOffset.y = Math.max(10, Math.min(50, cameraOffset.y));
                }
            }

            // Ya no llamamos a updateCameraPosition() aqu√≠, se maneja en el bucle animate
        }

        
        function updateCameraPosition() {
            switch (currentViewMode) {
                case 'firstPerson':
                    // Primera persona: c√°mara en la posici√≥n del avatar
                    camera.position.copy(avatarObject.position);
                    camera.position.y += 1.7; // Altura de los ojos
                    
                    // Mirar en la direcci√≥n que apunta el avatar con inclinaci√≥n
                    camera.quaternion.setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    break;
                    
                case 'thirdPerson':
                    // Tercera persona: c√°mara detr√°s y arriba del avatar
                    const offsetVector = new THREE.Vector3(
                        -Math.sin(yawAngle) * Math.cos(pitchAngle) * cameraOffset.z,
                        cameraOffset.y + Math.sin(pitchAngle) * cameraOffset.z,
                        -Math.cos(yawAngle) * Math.cos(pitchAngle) * cameraOffset.z
                    );
                    
                    camera.position.copy(avatarObject.position).add(offsetVector);
                    
                    // Mirar hacia el avatar con inclinaci√≥n
                    cameraTarget.copy(avatarObject.position);
                    cameraTarget.y += 1; // Mirar un poco arriba del centro del avatar
                    camera.lookAt(cameraTarget);
                    break;
                    
                case 'birdEye':
                    // MODIFICADO: Vista de p√°jaro con soporte para rotaci√≥n
                    // Posicionar la c√°mara en alto sobre el avatar pero permitiendo rotaci√≥n
                    const birdEyeHeight = cameraOffset.y;
                    const birdEyeRadius = cameraOffset.z * 0.5; // Reducido para estar m√°s centrado
                    
                    // Usar la rotaci√≥n horizontal (yawAngle) para girar alrededor del avatar
                    camera.position.copy(avatarObject.position);
                    camera.position.y += birdEyeHeight;
                    camera.position.x += Math.sin(yawAngle) * birdEyeRadius;
                    camera.position.z += Math.cos(yawAngle) * birdEyeRadius;
                    
                    // Usar pitchAngle para ajustar la inclinaci√≥n (limitada para vista de p√°jaro)
                    const birdEyePitch = Math.max(-Math.PI/2, Math.min(-Math.PI/6, pitchAngle));
                    
                    // Calcular el punto de mira con base en la rotaci√≥n
                    cameraTarget.copy(avatarObject.position);
                    // Ajustar el punto de mira para que mire "adelante" del avatar seg√∫n la rotaci√≥n
                    cameraTarget.x += Math.sin(yawAngle) * 5 * Math.sin(birdEyePitch + Math.PI/2);
                    cameraTarget.z += Math.cos(yawAngle) * 5 * Math.sin(birdEyePitch + Math.PI/2);
                    // Ajustar altura del punto de mira seg√∫n inclinaci√≥n
                    cameraTarget.y += Math.cos(birdEyePitch + Math.PI/2) * 5;
                    
                    camera.lookAt(cameraTarget);
                    break;
            }
        }


        
        function cycleViewMode() {
            switch (currentViewMode) {
                case 'firstPerson':
                    setViewMode('thirdPerson');
                    break;
                case 'thirdPerson':
                    setViewMode('birdEye');
                    break;
                case 'birdEye':
                    setViewMode('firstPerson');
                    break;
            }
        }
        
        function setViewMode(mode) {
            currentViewMode = mode;
            
            switch (mode) {
                case 'firstPerson':
                    avatarObject.visible = false;
                    // No reset pitchAngle
                    break;
                case 'thirdPerson':
                    avatarObject.visible = true;
                    cameraOffset.set(0, 10, 20);
                    // No reset pitchAngle
                    break;
                case 'birdEye':
                    avatarObject.visible = true;
                    cameraOffset.set(0, 30, 5);
                    // Ajustar pitchAngle para vista de p√°jaro (mira hacia abajo)
                    pitchAngle = -1.4; // Menos que -1.57 (90 grados)
            break;
    }
    
    updateCameraPosition();
}
        // A√ëADIR ESTA NUEVA FUNCI√ìN PARA EL RADAR
        // -------------------------------------------------------------------
        function updateNebulaRadar() {
            if (!nebulaRadarElement) return;

            // El radar apuntar√° al pulsar que orbitamos, o si no, al que est√° sonando.
            const targetPulsar = orbitingNebulaInstance || gestorDePulsares.pulsarAudible;

            if (!targetPulsar) {
                if(radarArrowElement) radarArrowElement.style.opacity = '0';
                if(radarDotElement) radarDotElement.style.opacity = '0';
                return;
            }

            // El resto de la funci√≥n es igual, pero ahora usa 'targetPulsar'
            const radarRadius = nebulaRadarElement.offsetWidth / 2;
            const dotRadius = radarDotElement.offsetWidth / 2;
            const nebulaPos = targetPulsar.nebula.initialStaticPosition;
            const nebulaDirWorld = new THREE.Vector3().subVectors(nebulaPos, avatarObject.position);
            const cameraInverseMatrix = new THREE.Matrix4().copy(camera.matrixWorldInverse);
            const nebulaDirCameraSpace = nebulaDirWorld.clone().applyMatrix4(cameraInverseMatrix);
            const angleToTarget = Math.atan2(nebulaDirCameraSpace.x, -nebulaDirCameraSpace.z);

            radarArrowElement.style.opacity = '1';
            radarArrowElement.style.transform = `rotate(${angleToTarget}rad)`;
            
            const distOnRadarPlane = Math.sqrt(nebulaDirCameraSpace.x * nebulaDirCameraSpace.x + nebulaDirCameraSpace.z * nebulaDirCameraSpace.z);
            const maxDistForDotInside = radarRadius - dotRadius - 2;

            let dotX, dotY;
            if (nebulaDirCameraSpace.z > 0 || distOnRadarPlane > maxDistForDotInside * 1.5) {
                dotX = Math.sin(angleToTarget) * maxDistForDotInside;
                dotY = -Math.cos(angleToTarget) * maxDistForDotInside;
                radarDotElement.style.opacity = '0.8';
            } else {
                const screenX = (nebulaDirCameraSpace.x / -nebulaDirCameraSpace.z) * radarRadius * 1.2;
                const screenY = (nebulaDirCameraSpace.y / -nebulaDirCameraSpace.z) * radarRadius * 1.2;
                const distFromCenter = Math.sqrt(screenX * screenX + screenY * screenY);
                if (distFromCenter > maxDistForDotInside) {
                    const scale = maxDistForDotInside / distFromCenter;
                    dotX = screenX * scale;
                    dotY = screenY * scale;
                } else {
                    dotX = screenX;
                    dotY = screenY;
                }
                radarDotElement.style.opacity = '1';
            }
            radarDotElement.style.transform = `translate(${dotX}px, ${dotY}px)`;
        }


        function gestionarAudioYAnimacionPulsares(deltaTime) {
            const RANGO_DE_VISIBILIDAD = 4000;
            const FADE_DURATION = 1500;
            const time = Date.now() * 0.001; 

            let pulsarMasCercanoAudible = null;
            let distanciaMinima = Infinity;

            // --- PRIMERA PASADA: GESTIONAR ESTADOS ---
            for (const pulsarId in gestorDePulsares.activos) {
                const pulsar = gestorDePulsares.activos[pulsarId];
                if (!pulsar || !pulsar.nebula) continue;

                pulsar.nebula.updateOrbitalPosition(time);

                const distancia = avatarObject.position.distanceTo(pulsar.nebula.particlesObject.position);

                // Gesti√≥n de visibilidad y descarga
                if (distancia > gestorDePulsares.zonaDeCarga) {
                    if (pulsar.isLoaded && pulsar.type !== 'live') { // NO descargar si es live (mic)
                        pulsar.tiempoGuardado = pulsar.audio.currentTime;
                        pulsar.audio.pause();
                        pulsar.audio.src = '';
                        pulsar.isLoaded = false;
                        pulsar.isPlaying = false;
                    }
                    pulsar.nebula.particlesObject.visible = (distancia <= RANGO_DE_VISIBILIDAD);
                    continue;
                }
                
                pulsar.nebula.particlesObject.visible = true;

                // Carga de audio (Solo para MP3/Radio, no para Live)
                if (!pulsar.isLoaded && pulsar.type !== 'live') {
                    pulsar.audio.src = pulsar.url;
                    try {
                        // ... Configuraci√≥n de nodos de audio est√°ndar ...
                        if (!pulsar.positionalAudio) pulsar.positionalAudio = new THREE.PositionalAudio(audioListener);
                        pulsar.positionalAudio.setRefDistance(40);
                        pulsar.positionalAudio.setMaxDistance(3000);

                        const preAmpGain = audioListener.context.createGain();
                        preAmpGain.gain.setValueAtTime(pulsarVolumeMultiplier, audioListener.context.currentTime);
                        pulsar.preAmpGain = preAmpGain;

                        if (!pulsar.mediaSource) pulsar.mediaSource = audioListener.context.createMediaElementSource(pulsar.audio);
                        
                        pulsar.mediaSource.disconnect();
                        pulsar.mediaSource.connect(preAmpGain);
                        preAmpGain.connect(pulsar.analyser);
                        pulsar.positionalAudio.setNodeSource(pulsar.analyser);
                    } catch (e) { console.error("Error audio:", e); }
                    pulsar.isLoaded = true;
                }
                
                // Actualizaci√≥n visual (com√∫n para todos)
                let freqData = new Uint8Array(pulsar.analyser.frequencyBinCount);
                // Para 'live', el analyser siempre est√° activo si el stream est√° activo
                if (pulsar.isLoaded || pulsar.type === 'live') {
                    pulsar.analyser.getByteFrequencyData(freqData);
                }
                pulsar.nebula.update(freqData, new Uint8Array(pulsar.analyser.fftSize), deltaTime);

                // Candidato a sonar (Solo MP3/Radio, el Live no compite por .play())
                if (distancia <= gestorDePulsares.zonaAudible && pulsar.type !== 'live') {
                    if (distancia < distanciaMinima) {
                        distanciaMinima = distancia;
                        pulsarMasCercanoAudible = pulsar;
                    }
                }
            }

            // --- SEGUNDA PASADA: REPRODUCCI√ìN (SOLO MP3/RADIO) ---
            if (gestorDePulsares.pulsarAudible !== pulsarMasCercanoAudible) {
                // Fade out anterior
                if (gestorDePulsares.pulsarAudible && gestorDePulsares.pulsarAudible.type !== 'live') {
                    const pulsarAnterior = gestorDePulsares.pulsarAudible;
                    pulsarAnterior.tiempoGuardado = pulsarAnterior.audio.currentTime;
                    fadeOutAudio(pulsarAnterior.audio, FADE_DURATION);
                    pulsarAnterior.isPlaying = false;
                }

                // Fade in nuevo
                if (pulsarMasCercanoAudible && pulsarMasCercanoAudible.type !== 'live') {
                    if (pulsarMasCercanoAudible.tiempoGuardado > 0) {
                        pulsarMasCercanoAudible.audio.currentTime = pulsarMasCercanoAudible.tiempoGuardado;
                    }
                    // PROTECCI√ìN CONTRA EL ERROR DE PLAY
                    if (pulsarMasCercanoAudible.audio && typeof pulsarMasCercanoAudible.audio.play === 'function') {
                        pulsarMasCercanoAudible.audio.play().catch(e => console.error("Error play:", e));
                        fadeInAudio(pulsarMasCercanoAudible.audio, FADE_DURATION, 1.0);
                        pulsarMasCercanoAudible.isPlaying = true;
                    }
                }
                
                gestorDePulsares.pulsarAudible = pulsarMasCercanoAudible;
            }
        }

        // hasta aqui perfecto andr√©s

        // --- NUEVAS FUNCIONES PARA FADE-IN Y FADE-OUT DE AUDIO ---

        /**
         * Aumenta gradualmente el volumen de un elemento de audio.
         * @param {HTMLAudioElement} audioElement - El elemento de audio a modificar.
         * @param {number} duration - La duraci√≥n del fade en milisegundos.
         * @param {number} targetVolume - El volumen final (entre 0.0 y 1.0).
         */
         function fadeInAudio(audioElement, duration, targetVolume) {
            // Si ya hay un fade en curso, lo cancelamos para empezar uno nuevo.
            if (audioElement.fadeInterval) {
                clearInterval(audioElement.fadeInterval);
            }

            audioElement.volume = 0;
            const stepTime = 50; // ms por cada paso de volumen
            const volumeStep = targetVolume / (duration / stepTime);

            audioElement.fadeInterval = setInterval(() => {
                if (audioElement.volume < targetVolume) {
                    audioElement.volume = Math.min(targetVolume, audioElement.volume + volumeStep);
                } else {
                    audioElement.volume = targetVolume;
                    clearInterval(audioElement.fadeInterval);
                    audioElement.fadeInterval = null;
                }
            }, stepTime);
        }

        /**
         * Disminuye gradualmente el volumen de un elemento de audio y lo pausa al final.
         * @param {HTMLAudioElement} audioElement - El elemento de audio a modificar.
         * @param {number} duration - La duraci√≥n del fade en milisegundos.
         */
        function fadeOutAudio(audioElement, duration) {
            // Si ya hay un fade en curso, lo cancelamos.
            if (audioElement.fadeInterval) {
                clearInterval(audioElement.fadeInterval);
            }

            const initialVolume = audioElement.volume;
            const stepTime = 50; // ms por cada paso
            const volumeStep = initialVolume / (duration / stepTime);

            audioElement.fadeInterval = setInterval(() => {
                if (audioElement.volume > 0) {
                    audioElement.volume = Math.max(0, audioElement.volume - volumeStep);
                } else {
                    audioElement.volume = 0;
                    clearInterval(audioElement.fadeInterval);
                    audioElement.fadeInterval = null;
                    audioElement.pause(); // Pausamos el audio solo cuando el volumen llega a cero.
                }
            }, stepTime);
        }

        function resetStereoStateToNormal() {
            const w = window.innerWidth, h = window.innerHeight;
            renderer.setScissorTest(false);
            renderer.setViewport(0, 0, w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            }

// -------------------------------------------------------------------                  
        // CORRECCI√ìN EN LA FUNCI√ìN ANIMATE PARA ASEGURAR UNA ANIMACI√ìN FLUIDA
        // REEMPLAZAR TU FUNCI√ìN ANIMATE ACTUAL POR ESTA VERSI√ìN COMPLETA
        // -------------------------------------------------------------------
        // REEMPLAZA TU animate ENTERA CON ESTA VERSI√ìN
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const time = clock.elapsedTime; // <--- ¬°A√ëADE ESTA L√çNEA!

            // El c√°lculo de velocidad y direcci√≥n se queda como lo tienes
            const speed = 0.2;
            const direction = new THREE.Vector3(-Math.sin(yawAngle), 0, -Math.cos(yawAngle));
            let currentSpeedFactor = 1.0;
            // El efecto visual de hipersalto solo en vuelo libre o en modo cometa
            if (hyperspaceEffect && (hyperspaceModeActive || currentOrbitType === 'comet')) {
                currentSpeedFactor = hyperspaceEffect.update(direction);
            }

            const adjustedSpeed = speed * currentSpeedFactor;

            // --- L√ìGICA DE CONTROL PRINCIPAL: √ìRBITA VS. VUELO LIBRE ---
            if (isOrbitingNebula && orbitingNebulaInstance) {
                // Si estamos orbitando un p√∫lsar
                const targetPulsarPos = orbitingNebulaInstance.nebula.particlesObject.position; // Usar la posici√≥n din√°mica del p√∫lsar

                if (currentOrbitType === 'fixed') {
                    // --- MODO √ìRBITA FIJA (el antiguo, con c√°mara libre) ---

            // 1. El avatar se posiciona en el c√≠rculo de √≥rbita
            const newAvatarX = targetPulsarPos.x + orbitDistance * Math.cos(orbitAngle);
            const newAvatarZ = targetPulsarPos.z + orbitDistance * Math.sin(orbitAngle);
            // Suavizamos el movimiento del avatar hacia la posici√≥n orbital deseada
            avatarObject.position.lerp(new THREE.Vector3(newAvatarX, avatarObject.position.y, newAvatarZ), 0.05);

            // 2. El avatar SIEMPRE mira al p√∫lsar en este modo
            avatarObject.lookAt(targetPulsarPos);

            // 3. La √≥rbita avanza lentamente por s√≠ misma (ORBIT_SPEED)
            // y se ajusta con A/D (playerOrbitSpeed)
            orbitAngle += (ORBIT_SPEED + playerOrbitSpeed) * deltaTime * 100 * (hyperspaceModeActive ? 8.0 : 1.0);

            // 4. Permitir rotaci√≥n de la c√°mara con Q/E en modo fijo
            if (rotateCameraLeft) { yawAngle -= cameraRotationSpeed; }
            if (rotateCameraRight) { yawAngle += cameraRotationSpeed; }

            // --- L√ìGICA DE C√ÅMARA ESPEC√çFICA PARA MODO √ìRBITA FIJA ---
            // La c√°mara se posiciona relativa al avatar, pero su rotaci√≥n es independiente
            switch (currentViewMode) {
                case 'firstPerson':
                    camera.position.copy(avatarObject.position);
                    camera.position.y += 1.7; // Altura de los ojos
                    camera.quaternion.setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    break;

                case 'thirdPerson':
                    // Calcular offset de la c√°mara basado en yawAngle (rotaci√≥n horizontal) y pitchAngle (inclinaci√≥n vertical)
                    // Esto recrea el efecto de "inercia" al mover el rat√≥n o con Q/E
                    const tempQuaternionThird = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    // El offset se aplica en la direcci√≥n de la c√°mara, no del avatar
                    const offsetVectorThird = new THREE.Vector3(0, cameraOffset.y, cameraOffset.z).applyQuaternion(tempQuaternionThird);
                    camera.position.copy(avatarObject.position).add(offsetVectorThird);
                    camera.quaternion.copy(tempQuaternionThird); // La c√°mara mira en la direcci√≥n de yaw/pitch
                    break;

                case 'birdEye':
                    // Calcular offset de la c√°mara basado en yawAngle y pitchAngle
                    const tempQuaternionBird = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    // El offset se aplica en la direcci√≥n de la c√°mara
                    const birdEyeOffset = new THREE.Vector3(0, cameraOffset.y, cameraOffset.z * 0.5).applyQuaternion(tempQuaternionBird); // cameraOffset.z * 0.5 para estar m√°s centrado
                    camera.position.copy(avatarObject.position).add(birdEyeOffset);
                    camera.quaternion.copy(tempQuaternionBird); // La c√°mara mira en la direcci√≥n de yaw/pitch
                    break;
            }

            // Aseg√∫rate de que el efecto de hipersalto se desactive en este modo si estaba activo
            if (hyperspaceEffect) {
                hyperspaceEffect.toggleHyperspace(false); // Desactivar si se estaba usando en modo cometa
            }

        } else { // currentOrbitType === 'comet'
            // --- MODO √ìRBITA COMETA (el nuevo, el que te gusta) ---

            // 1. Aplicar controles de jugador a la √≥rbita
            const hyperspaceOrbitFactor = hyperspaceModeActive ? 8.0 : 1.0;
            orbitAngle += (ORBIT_SPEED + playerOrbitSpeed) * deltaTime * 100 * hyperspaceOrbitFactor;

            // Limitar la distancia de la √≥rbita para seguridad
            orbitDistance = Math.max(MIN_ORBIT_DISTANCE, Math.min(MAX_ORBIT_DISTANCE, orbitDistance));

            // 2. Calcular la nueva posici√≥n del AVATAR (con lerp para suavizar)
            const newAvatarX = targetPulsarPos.x + orbitDistance * Math.cos(orbitAngle);
            const newAvatarZ = targetPulsarPos.z + orbitDistance * Math.sin(orbitAngle);
            avatarObject.position.lerp(new THREE.Vector3(newAvatarX, avatarObject.position.y, newAvatarZ), 0.05);

            // 3. El avatar siempre mira al p√∫lsar en este modo
            avatarObject.lookAt(targetPulsarPos);

            // 4. L√≥gica de C√ÅMARA ORBITAL MANUAL (para que siempre mire al p√∫lsar)
            // La c√°mara se posiciona para mirar al p√∫lsar desde la perspectiva del avatar.
            switch (currentViewMode) {
                case 'firstPerson':
                    camera.position.copy(avatarObject.position);
                    camera.position.y += 1.7; // Altura de los ojos
                    camera.lookAt(targetPulsarPos);
                    break;

                case 'thirdPerson':
                    const dirToAvatar = new THREE.Vector3().subVectors(avatarObject.position, targetPulsarPos).normalize();
                    const offsetBehind = dirToAvatar.multiplyScalar(cameraOffset.z);
                    camera.position.copy(avatarObject.position).add(offsetBehind);
                    camera.position.y += cameraOffset.y / 2;
                    camera.lookAt(targetPulsarPos);
                    break;

                case 'birdEye':
                    camera.position.copy(avatarObject.position);
                    camera.position.y += cameraOffset.y;
                    camera.lookAt(targetPulsarPos);
                    break;
            }
            // Aseg√∫rate de que el efecto de hipersalto est√© activo si corresponde
            if (hyperspaceEffect) {
                hyperspaceEffect.update(avatarObject.getWorldDirection(new THREE.Vector3()));
            }
        }
    } else {
        // --- MODO VUELO LIBRE (tu c√≥digo original) ---
        const frontVector = direction.clone().normalize().multiplyScalar(adjustedSpeed);
        const rightVector = new THREE.Vector3(frontVector.z, 0, -frontVector.x);

        if (moveForward) avatarObject.position.add(frontVector);
        if (moveBackward) avatarObject.position.sub(frontVector);
        if (moveLeft) avatarObject.position.sub(rightVector);
        if (moveRight) avatarObject.position.add(rightVector);
        if (moveUp) avatarObject.position.y += adjustedSpeed;
        if (moveDown) avatarObject.position.y -= adjustedSpeed;

        // En vuelo libre, Q y E rotan el yawAngle del avatar
        if (rotateCameraLeft) { yawAngle -= cameraRotationSpeed; }
        if (rotateCameraRight) { yawAngle += cameraRotationSpeed; }

        // La c√°mara sigue al avatar normalmente
        updateCameraPosition();

        // Aseg√∫rate de que el efecto de hipersalto est√© activo si corresponde en vuelo libre
        if (hyperspaceEffect) {
            hyperspaceEffect.update(avatarObject.getWorldDirection(new THREE.Vector3()));
        }
    }

            // --- El resto de tus funciones de actualizaci√≥n ---
            updateCoordinatesDisplay();
            gestionarAudioYAnimacionPulsares(deltaTime);
            handlePlaylistFade(); // <--- A√ëADE ESTA LLAMADA
            // --- ¬°NUEVO BLOQUE PARA ACTUALIZAR EL P√öLSAR EN VIVO! ---
            if (livePulsarInstance && livePulsarAnalyser) {
                try {
                    // Actualizamos la posici√≥n orbital del p√∫lsar en vivo
                    // (Necesitamos 'time' del inicio de animate)
                    livePulsarInstance.updateOrbitalPosition(time); 

                    // Obtenemos los datos del analizador en vivo
                    livePulsarAnalyser.getByteFrequencyData(liveFrequencyData);
                    livePulsarAnalyser.getByteTimeDomainData(liveTimeData);

                    // Actualizamos la nebulosa con los datos del micr√≥fono
                    livePulsarInstance.update(liveFrequencyData, liveTimeData, deltaTime);
                } catch (e) {
                    console.error("Error al actualizar el P√∫lsar en Vivo:", e);
                    stopLivePulsar(); // Detener si hay un error
                }
            }
            // --- FIN DEL NUEVO BLOQUE ---

            updateNebulaRadar();

            // Actualizamos TODAS las galaxias
            for (const id in galaxies) {
                if (id === username) {
                    // Esta es nuestra galaxia, la movemos con el avatar
                    galaxies[id].updatePosition(avatarObject.position.clone());
                }

                // Llamamos a .update() para TODAS, para que se animen
                // y la galaxia de los otros jugadores se mueva.
                const galaxy = galaxies[id];
                if (galaxy && typeof galaxy.update === 'function') {
                    galaxy.update();
                }
            }

            // --- INICIO DEL BLOQUE A A√ëADIR ---
            // Actualizamos TODAS las galaxias (local y remotas)
            for (const id in galaxies) {
                const galaxy = galaxies[id];
                if (galaxy) {
                    // La posici√≥n ya se actualiza a trav√©s de 'updatePosition'
                    // cuando llega un mensaje 'move' del servidor (para remotos)
                    // o directamente aqu√≠ para el local.

                    if (id === username) {
                        // Actualizamos la posici√≥n de NUESTRA galaxia local
                        galaxy.updatePosition(avatarObject.position.clone());
                    } else {
                    // --- INICIO INTERPOLACI√ìN PARA REMOTOS ---
                    if (galaxy.avatarMesh && !galaxy.isLocal) {
                   
                        // Mueve suavemente la esfera hacia la √∫ltima posici√≥n recibida
                        galaxy.avatarMesh.position.lerp(galaxy.targetPosition, galaxy.interpolationFactor);

                        // Mueve las part√≠culas junto con la esfera interpolada
                        if (galaxy.pixelGalaxy && galaxy.pixelGalaxy.pixelObject) {
                        galaxy.pixelGalaxy.pixelObject.position.copy(galaxy.avatarMesh.position);
                        }
                        // Tambi√©n podr√≠as interpolar la rotaci√≥n aqu√≠ (galaxy.avatarMesh.quaternion.slerp)
                    }
                    // --- FIN INTERPOLACI√ìN ---
                    }

                    // Llamamos a .update() para TODAS para animar las part√≠culas
                    galaxy.update();
                }
            }
            // --- FIN DEL BLOQUE A A√ëADIR ---

            if (proceduralGenerator) {
                proceduralGenerator.update(avatarObject.position);
            }

            updatableSpecialFeatures.forEach(feature => {
                if (feature && typeof feature.update === 'function') {
                    feature.update(deltaTime);
                }
            });

            renderer.render(scene, camera);
            // --- L√ìGICA DE RENDERIZADO (NORMAL O EST√âREO MANUAL) ---
            if (isStereoMode) {
                const width = window.innerWidth;
                const height = window.innerHeight;

                if (isStereoMode) {
                    renderer.setScissorTest(true);

                    // 1. Ajustamos la c√°mara UNA SOLA VEZ para las vistas estrechas
                    camera.aspect = (width / 2) / height;
                    camera.updateProjectionMatrix();

                    // --- VISTA DERECHA (para ojo izquierdo en cross-eye) ---
                    camera.position.x += eyeSeparation / 2;
                    renderer.setScissor(0, 0, width / 2, height);
                    renderer.setViewport(0, 0, width / 2, height);
                    renderer.render(scene, camera);
                    camera.position.x -= eyeSeparation / 2; // Reset

                    // --- VISTA IZQUIERDA (para ojo derecho en cross-eye) ---
                    camera.position.x -= eyeSeparation / 2;
                    renderer.setScissor(width / 2, 0, width / 2, height);
                    renderer.setViewport(width / 2, 0, width / 2, height);
                    renderer.render(scene, camera);
                    camera.position.x += eyeSeparation / 2; // Reset

                    renderer.setScissorTest(false);

                } else {
                    // 2. Nos aseguramos de que la c√°mara tenga el aspect ratio correcto en modo normal
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();

                    renderer.setViewport(0, 0, width, height);
                    renderer.render(scene, camera);
                }
            }


        }

        
        function updateCoordinatesDisplay() {
            const x = avatarObject.position.x.toFixed(2);
            const y = avatarObject.position.y.toFixed(2);
            const z = avatarObject.position.z.toFixed(2);
            coordsElement.textContent = `X: ${x}, Y: ${y}, Z: ${z}`;
        }
        
        function updateTeleportCoords() {
            document.getElementById('teleportX').value = avatarObject.position.x.toFixed(2);
            document.getElementById('teleportY').value = avatarObject.position.y.toFixed(2);
            document.getElementById('teleportZ').value = avatarObject.position.z.toFixed(2);
        }
        
        function toggleTeleportPanel() {
            const panel = document.getElementById('teleportPanel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                updateTeleportCoords();
            }
        }
        
        function teleportToCoords() {
            const x = parseFloat(document.getElementById('teleportX').value);
            const y = parseFloat(document.getElementById('teleportY').value);
            const z = parseFloat(document.getElementById('teleportZ').value);
            
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                avatarObject.position.set(x, y, z);
                updateCameraPosition();
                document.getElementById('teleportPanel').style.display = 'none';
            }
        }

        function toggleSettingsMenu() {
            const menu = document.getElementById('settingsMenu');
            if (menu.style.display === 'block') {
                menu.style.display = 'none';
            } else {
                menu.style.display = 'block';
            }
        }

        
        function connectToNetwork() {
            // --- ¬°A√ëADE ESTE BLOQUE AL INICIO! ---
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
                console.log('AudioContext REANUDADO por el bot√≥n Conectar.');
            }
            // --- FIN DEL BLOQUE A√ëADIDO ---
            const oldUsername = username; // <--- A√ëADIR ESTA L√çNEA
            // Obtenemos el nombre de usuario del input
            const newUsername = document.getElementById('usernameInput').value.trim();
            if (newUsername) {
                username = newUsername;
            }
            // <--- INICIO DEL BLOQUE NUEVO (A√ëADIR TODO ESTO) ---
            if (oldUsername !== username && galaxies[oldUsername]) {
                console.log(`Cambiando nombre de galaxia local de ${oldUsername} a ${username}`);
                
                galaxies[username] = galaxies[oldUsername]; 
                galaxies[username].id = username;           
                delete galaxies[oldUsername];             
            }
            // <--- FIN DEL BLOQUE NUEVO ---

            console.log(`Intentando conectar a ws://localhost:8080 como ${username}`);

            // Conectamos al servidor local que creamos
            socket = new WebSocket('wss://musicosmosonline.com');

            // ---- Definimos los "oyentes" del socket ----

            // 1. Cuando la conexi√≥n se abre
            socket.onopen = () => {
                console.log('¬°Conectado al servidor de Musicosmos!');
                document.getElementById('connectButton').textContent = 'Conectado';
                document.getElementById('connectButton').disabled = true;

                // Empezamos a enviar nuestra posici√≥n 10 veces por segundo
                setInterval(sendPosition, 50);
            };

            // 2. Cuando recibimos un mensaje del servidor
            socket.onmessage = (event) => {
                    
                // --- A√ëADE ESTAS L√çNEAS ---
                //console.log("<-- RECIBIDO:", event.data); 
                const data = JSON.parse(event.data);
               // console.log("    Data parseada:", data);
               // console.log("    Mi username local:", username);
               // console.log("    Comparando data.id (" + data.id + ") === username (" + username + ") ? ", data.id === username);
                // --- FIN L√çNEAS A√ëADIDAS ---TODO BIEN HASTA AQUI!!

                // Ignoramos nuestros propios mensajes (que el servidor nos reenv√≠a)
                if (data.id === username) return; // <-- ¬°ESTA ES LA CORRECCI√ìN!

                // Si no tenemos una galaxia para este jugador, la creamos
                if (!galaxies[data.id]) {
                    console.log('Nuevo jugador detectado:', data.id);
                    // Creamos una galaxia en una posici√≥n inicial (0,0,0), se actualizar√° en un instante
                    galaxies[data.id] = new Galaxy(data.id, new THREE.Vector3(0, 0, 0), false); // false = es Remoto

                    // Actualizamos la lista de jugadores
                    const container = document.getElementById('playersOnline');
                    const playerItem = document.createElement('div');
                    playerItem.className = 'midi-device-item';
                    playerItem.id = `player-item-${data.id}`;
                    playerItem.textContent = `Jugador ${data.id}`; // Podr√≠amos pasar el username aqu√≠
                    container.appendChild(playerItem);
                }

                // --- ESTE ES EL N√öCLEO ---
                // Actualizamos la galaxia del otro jugador bas√°ndonos en el mensaje
                const playerGalaxy = galaxies[data.id];
                if (!playerGalaxy) return;

                switch (data.type) {
                    case 'move': 
                        playerGalaxy.targetPosition.set(data.x, data.y, data.z);
                        
                        // --- NUEVO BLOQUE: Sincronizar apariencia del remoto ---
                        if (data.visuals && playerGalaxy.pixelGalaxy) {
                            // Solo actualizamos si los valores son diferentes para ahorrar recursos
                            const currentConfig = playerGalaxy.pixelGalaxy.config;
                            // Comprobamos si el tama√±o cambi√≥ dr√°sticamente (por ejemplo)
                            if (Math.abs(currentConfig.maxExpansion - data.visuals.size) > 1) {
                                playerGalaxy.pixelGalaxy.updateConfig({
                                    maxExpansion: data.visuals.size,
                                    particleAffectedRatio: data.visuals.pCount / 100,
                                    colorMixFactor: data.visuals.mix / 100,
                                    expansionTime: data.visuals.expTime
                                });
                            }
                        }
                        // -------------------------------------------------------
                        break;
                        case 'note_on':
                        console.log(`%cNOTA RECIBIDA de ${data.id}`, 'color: #00ff00; font-weight: bold;');
                        console.log(`   Nota: ${data.note}, Vel: ${data.velocity}`);

                        const PLAYER_AUDIO_BUBBLE = 200; // Distancia de activaci√≥n

                        if (!playerGalaxy || !playerGalaxy.avatarMesh) {
                             console.log(`   ERROR: No se encontr√≥ la galaxia o el avatar para ${data.id}`);
                             break; // Salir si algo falta
                        }

                        // --- VERIFICACI√ìN DE DISTANCIA ---
                        const miPosicion = avatarObject.position;
                        const otraPosicion = playerGalaxy.avatarMesh.position;
                        const distancia = miPosicion.distanceTo(otraPosicion);
                        console.log(`   Mi Pos: X=${miPosicion.x.toFixed(0)}, Z=${miPosicion.z.toFixed(0)}`);
                        console.log(`   Pos de ${data.id}: X=${otraPosicion.x.toFixed(0)}, Z=${otraPosicion.z.toFixed(0)}`);
                        console.log(`   Distancia calculada: ${distancia.toFixed(1)} unidades`);
                        // --- FIN VERIFICACI√ìN ---

                        // Aplicar efecto visual siempre
                        playerGalaxy.addNote(data.note, data.velocity);

                        // Comprobar si est√° dentro de la burbuja de audio
                        if (distancia <= PLAYER_AUDIO_BUBBLE) {
                            console.log(`   ‚úÖ DENTRO de la burbuja (${PLAYER_AUDIO_BUBBLE}u). Reproduciendo audio 3D.`);
                            playerGalaxy.playNote(data.note, data.velocity);
                        } else {
                            console.log(`   ‚ùå FUERA de la burbuja (${PLAYER_AUDIO_BUBBLE}u). NO se reproduce audio.`);
                            // Opcional: Asegurarnos de detener cualquier nota que pudiera haber quedado sonando
                            // playerGalaxy.stopNote(data.note); // Descomenta si sospechas que las notas no se detienen bien
                        }
                        break; // Fin del case 'note_on'
                    case 'note_off':
                        // --- ¬°A√ëADE ESTAS L√çNEAS AQU√ç! ---
                        console.log(`%c¬°NOTA APAGADA!`, 'color: #ff0000; font-size: 12px;');
                        console.log(`   Jugador: ${data.id}, Nota: ${data.note}`);
                        // --- FIN DE LAS L√çNEAS ---
                        // Apagamos la nota en la galaxia del otro jugador
                        playerGalaxy.removeNote(data.note);
                        playerGalaxy.stopNote(data.note);
                        break;
                    case 'disconnect':
                        // El jugador se fue, eliminamos su galaxia
                        console.log('Jugador desconectado:', data.id);
                        if (playerGalaxy) {
                            playerGalaxy.dispose();
                            delete galaxies[data.id];
                        }
                        const item = document.getElementById(`player-item-${data.id}`);
                        if (item) item.remove();
                        break;
                }
            };

            // 3. Cuando la conexi√≥n se cierra
            socket.onclose = () => {
                console.log('Desconectado del servidor.');
                document.getElementById('connectButton').textContent = 'Conectar';
                document.getElementById('connectButton').disabled = false;
            };

            // 4. Si hay un error
            socket.onerror = (error) => {
                console.error('Error de WebSocket:', error);
                document.getElementById('connectButton').textContent = 'Error';
                document.getElementById('connectButton').disabled = false;
            };
        }

        // Nueva funci√≥n para ENVIAR nuestra posici√≥n
        function sendPosition() {
            if (socket && socket.readyState === WebSocket.OPEN && avatarObject) {
                // Preparamos los datos visuales actuales de tu galaxia
                const myVisuals = {
                    size: galaxySettings.size,
                    pCount: galaxySettings.particleCount,
                    mix: galaxySettings.colorMixing,
                    expTime: galaxySettings.expansionTime
                };

                const data = {
                    type: 'move',
                    id: username,
                    x: avatarObject.position.x,
                    y: avatarObject.position.y,
                    z: avatarObject.position.z,
                    yaw: yawAngle,
                    pitch: pitchAngle,
                    visuals: myVisuals // <--- Enviamos tu configuraci√≥n visual
                };
                socket.send(JSON.stringify(data));
            }
        }

        // Nueva funci√≥n para ENVIAR nuestras notas
        function sendNote(command, note, velocity) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const data = {
                    type: command, // 'note_on' o 'note_off'
                    id: username, // <-- ¬°A√ëADE ESTA L√çNEA!
                    note: note,
                    velocity: velocity
                };
               // console.log("--> ENVIANDO (" + command + "):", JSON.stringify(data));
                socket.send(JSON.stringify(data));
            }
        }
        
       
        
        function updatePlayersList() {
            const container = document.getElementById('playersOnline');
            container.innerHTML = '';
            
            const playerCount = Object.keys(otherPlayers).length + 1;
            container.innerHTML = `<p>Jugadores en l√≠nea: ${playerCount}</p>`;
            
            const localItem = document.createElement('div');
            localItem.className = 'midi-device-item active';
            localItem.textContent = `${username} (T√∫)`;
            container.appendChild(localItem);
            
            for (const playerId in otherPlayers) {
                const playerItem = document.createElement('div');
                playerItem.className = 'midi-device-item';
                playerItem.textContent = playerId;
                container.appendChild(playerItem);
            }
        }

        function initMIDI() {
            if (navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess({ sysex: false })
                    .then(onMIDISuccess, onMIDIFailure);
            } else {
                midiStatusElement.textContent = 'Tu navegador no soporta Web MIDI API';
            }
        }

        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Quitar 'active' de todos los botones y contenidos
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));

                    // A√±adir 'active' al bot√≥n clickeado y a su contenido correspondiente
                    button.classList.add('active');
                    const targetTabId = button.getAttribute('data-tab');
                    document.getElementById(targetTabId).classList.add('active');
                });
            });
        }

        function onMIDISuccess(access) {
            midiAccess = access;
            midiStatusElement.textContent = 'MIDI conectado. Selecciona dispositivos en la configuraci√≥n.';
            
            midiAccess.addEventListener('statechange', updateDeviceList);
            
            updateDeviceList();
        }

        function onMIDIFailure(error) {
            midiStatusElement.textContent = `Error al acceder a MIDI: ${error}`;
        }

        function updateDeviceList() {
            if (!midiAccess) return;
            
            const container = document.getElementById('midiDevicesContainer');
            container.innerHTML = '';
            
            let deviceCount = 0;
            
            midiAccess.inputs.forEach(input => {
                deviceCount++;
                
                const deviceItem = document.createElement('div');
                deviceItem.className = 'midi-device-item';
                deviceItem.dataset.id = input.id;
                
                const deviceName = document.createElement('span');
                deviceName.textContent = input.name || `Dispositivo ${deviceCount}`;
                deviceItem.appendChild(deviceName);
                
                const toggleBtn = document.createElement('div');
                toggleBtn.className = 'toggle-button';
                if (activeInputs.has(input.id)) {
                    toggleBtn.classList.add('active');
                    deviceItem.classList.add('active');
                }
                deviceItem.appendChild(toggleBtn);
                
                // Mejorado: Manejando separadamente el clic en el dispositivo
                deviceItem.addEventListener('click', function(e) {
                    e.stopPropagation(); // Evita que el clic cierre el men√∫
                    toggleMIDIInput(input.id);
                    toggleBtn.classList.toggle('active');
                    deviceItem.classList.toggle('active');
                });
                
                container.appendChild(deviceItem);
            });
            
            if (deviceCount === 0) {
                container.innerHTML = '<p>No se encontraron dispositivos MIDI</p>';
            }
            
            midiStatusElement.textContent = `${deviceCount} dispositivo(s) MIDI encontrado(s). ${activeInputs.size} activo(s).`;
        }
        
        function toggleMIDIInput(inputId) {
            const input = midiAccess.inputs.get(inputId);
            
            if (activeInputs.has(inputId)) {
                input.removeEventListener('midimessage', onMIDIMessage);
                activeInputs.delete(inputId);
                console.log(`Dispositivo MIDI desactivado: ${input.name}`);
            } else {
                input.addEventListener('midimessage', onMIDIMessage);
                activeInputs.add(inputId);
                console.log(`Dispositivo MIDI activado: ${input.name}`);
            }
            
            midiStatusElement.textContent = `${midiAccess.inputs.size} dispositivo(s) MIDI encontrado(s). ${activeInputs.size} activo(s).`;
        }

        // Mejora en la funci√≥n onMIDIMessage para manejar eventos MIDI de manera m√°s robusta
        // Funci√≥n mejorada para procesar mensajes MIDI
        function onMIDIMessage(event) {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            try {
                const status = event.data[0] & 0xF0; 
                const channel = event.data[0] & 0x0F;
                const data1 = event.data[1];
                const data2 = event.data.length > 2 ? event.data[2] : 0;
                
                // Definir constantes de audio aqu√≠ (puedes ajustarlas)
                const attackTime = 0.05;
                const releaseTime = 0.3;
                const waveform = 'sine'; // O la forma de onda que prefieras

                if (status === 0x90 && data2 > 0) {
                    // Note On (tecla presionada)
                    const note = data1;
                    const velocity = data2;
                    
                    if (galaxies[username]) {
                        const galaxy = galaxies[username];

                        // --- INICIO DE LA CORRECCI√ìN (AUDIO 3D LOCAL) ---
                        if (galaxy.positionalAudio && !galaxy.activeAudioNotes[note]) {
                            const frequency = midiToFrequency(note);
                            if (!frequency) return; // Salir si la nota no es v√°lida

                            const oscillator = audioContext.createOscillator();
                            oscillator.type = waveform;
                            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

                            const gainNode = audioContext.createGain();
                            const targetVolume = (velocity / 127) * 0.7; // Volumen basado en la velocidad
                            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(targetVolume, audioContext.currentTime + attackTime);

                            oscillator.connect(gainNode);
                            gainNode.connect(galaxy.positionalAudio.gain); // Conectar al audio 3D local
                            oscillator.start();
                            
                            galaxy.activeAudioNotes[note] = { oscillator, gainNode };
                        }
                        // --- FIN DE LA CORRECCI√ìN ---

                        // Esto ya lo ten√≠as (visuals y red)
                        galaxy.addNote(note, velocity);
                        sendNote('note_on', note, velocity); 
                        
                        const noteName = getNoteNameFromMIDI(note);
                        midiStatusElement.textContent = `Nota: ${noteName} (${note}), Velocidad: ${velocity}`;
                        
                        window.lastActiveNote = note;
                        window.lastActiveVelocity = velocity;
                    }
                } 
                else if ((status === 0x80) || (status === 0x90 && data2 === 0)) {
                    // Note Off (tecla liberada)
                    const note = data1;
                    
                    if (galaxies[username]) {
                        const galaxy = galaxies[username];

                        // --- INICIO DE LA CORRECCI√ìN (DETENER AUDIO 3D LOCAL) ---
                        if (galaxy.activeAudioNotes[note]) {
                            const { oscillator, gainNode } = galaxy.activeAudioNotes[note];
                            const now = audioContext.currentTime;
                            
                            gainNode.gain.cancelScheduledValues(now);
                            gainNode.gain.setValueAtTime(gainNode.gain.value, now); 
                            gainNode.gain.exponentialRampToValueAtTime(0.001, now + releaseTime); 

                            oscillator.stop(now + releaseTime + 0.05); 

                            setTimeout(() => {
                                try {
                                    oscillator.disconnect();
                                    gainNode.disconnect();
                                } catch(e) { /* Ignorar */ }
                            }, (releaseTime + 0.1) * 1000); 

                            delete galaxy.activeAudioNotes[note];
                        }
                        // --- FIN DE LA CORRECCI√ìN ---

                        // Esto ya lo ten√≠as (visuals y red)
                        galaxy.removeNote(note);
                        sendNote('note_off', note, 0);
                        
                        if (note === window.lastActiveNote) {
                            window.lastActiveNote = null;
                        }
                    }
                }
                else if (status === 0xB0) {
                    // Control Change (CC)
                    const controllerNumber = data1;
                    const value = data2;
                    
                    if (controllerNumber === 7 || controllerNumber === 11 || controllerNumber === 1) {
                        processVolumeChange(value);
                    }
                }
            } catch (error) {
                console.error("Error al procesar mensaje MIDI:", error);
            }
        }

        // A√±ade la funci√≥n processVolumeChange pero sin redeclarar variables
        function processVolumeChange(value) {
            // Actualizar el volumen actual (usar window para acceder a variable global)
            window.currentMIDIVolume = value;
            
            // Actualizar visualizaci√≥n
            midiStatusElement.textContent = `Volumen: ${value}`;
            
            // Si hay una galaxia activa, actualizar su tama√±o basado en el volumen
            if (galaxies[username] && galaxies[username].pixelGalaxy) {
                // Calcular el factor de escala inverso (volumen bajo = galaxia grande)
                const volumeNormalized = value / 127;
                const inversedVolume = 1 - volumeNormalized;
                
                // Aplicar el cambio de volumen a trav√©s del factor de escala MIDI
                galaxies[username].pixelGalaxy.midiScaleFactor = 0.6 + inversedVolume * 0.8;
                
                // Ajustar el tama√±o objetivo
                galaxies[username].pixelGalaxy.adjustTargetExpansion();
                
                // Si hay una nota activa, actualizar tambi√©n los efectos visuales
                if (window.lastActiveNote !== null) {
                    // Recrear el efecto visual pero manteniendo la nota y usando el nuevo volumen
                    galaxies[username].pixelGalaxy.pulseCore(window.lastActiveNote, value);
                }
            }
        }

        // Clase mejorada para el sintetizador alien√≠gena
        class AlienSynthKeyboard {
            constructor(listener) { // <-- ¬°Argumento a√±adido!
                // Inicializaci√≥n de variables de estado
                this.isMinimized = false;
                this.isConfigOpen = false;
                this.isRebinding = false;
                this.selectedKey = null;
                this.baseOctave = 7;
                this.currentOctave = 7;
                this.velocity = 78;
                this.attackTime = 0.05;
                this.releaseTime = 0.3;
                this.currentWaveform = 'sine';
                this.currentRootNote = 0; // C por defecto
                this.currentScale = 'chromatic';
                this.activeKeys = new Set();
                this.activeNotes = {};
                this.inhibitKeyP = false; //
                
                // ++ A√ëADE ESTE BLOQUE ++
                // Mapeo de la tecla f√≠sica a su c√≥digo de evento (event.code).
                // Lo definimos aqu√≠ para que sea accesible por toda la clase.
                this.keyToCode = {
                    't': 'KeyT', 'y': 'KeyY', 'u': 'KeyU', 'i': 'KeyI', 'o': 'KeyO', 'p': 'KeyP', '¬¥': 'Quote', '+': 'BracketRight',
                    'g': 'KeyG', 'h': 'KeyH', 'j': 'KeyJ', 'k': 'KeyK', 'l': 'KeyL', '√±': 'Semicolon', '{': 'BracketLeft',
                    'b': 'KeyB', 'n': 'KeyN', 'm': 'KeyM', ',': 'Comma', '.': 'Period', '-': 'Slash'
                }; 
                
                // Cargar configuraci√≥n guardada o usar valores predeterminados
                this.loadSavedConfig();
                
                // Definiciones de escalas musicales
                this.scales = {
                    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
                    major: [0, 2, 4, 5, 7, 9, 11],
                    minor: [0, 2, 3, 5, 7, 8, 10],
                    pentatonic: [0, 2, 4, 7, 9],
                    blues: [0, 3, 5, 6, 7, 10],
                    harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
                    dorian: [0, 2, 3, 5, 7, 9, 10],
                    phrygian: [0, 1, 3, 5, 7, 8, 10],
                    lydian: [0, 2, 4, 6, 7, 9, 11],
                    mixolydian: [0, 2, 4, 5, 7, 9, 10]
                };
                
                // Inicializar Web Audio API
                this.initAudio(listener);
                // Obtener referencias a elementos DOM
                this.keyboardElement = document.getElementById('virtualKeyboard');
                this.headerElement = document.querySelector('.synth-header');
                this.settingsButton = document.getElementById('synthSettings');
                this.closeConfigButton = document.getElementById('closeConfigPanel');
                this.configPanel = document.getElementById('synthConfigPanel');
                this.octaveDown = document.getElementById('octaveDown');
                this.octaveUp = document.getElementById('octaveUp');
                this.currentOctaveDisplay = document.getElementById('currentOctave');
                this.velocitySlider = document.getElementById('virtualVelocity');
                this.volumeDisplay = document.getElementById('displayVolume');
                this.currentNoteDisplay = document.getElementById('currentNote');
                this.currentScaleDisplay = document.getElementById('currentScale');
                this.attackKnob = document.getElementById('knobAttack');
                this.releaseKnob = document.getElementById('knobRelease');
                this.scaleSelector = document.getElementById('scaleSelector');
                this.rootNoteSelector = document.getElementById('rootNoteSelector');
                this.keyBindingStatus = document.getElementById('keyBindingStatus');
                this.resetKeyBindingsButton = document.getElementById('resetKeyBindings');
                this.saveConfigButton = document.getElementById('saveConfig');
                this.synthKeyboardContainer = document.getElementById('synthKeyboard');
                
                // Generar el teclado din√°micamente basado en la escala seleccionada
                this.generateKeyboard();
                
                // Inicializar Event Listeners
                this.initializeEventListeners();
                
                // Inicializar posici√≥n de los knobs
                this.updateKnobPosition('attack', this.attackTime);
                this.updateKnobPosition('release', this.releaseTime);
                
                 // Actualizar visualizaci√≥n
                this.updateScaleDisplay();
            }

            // ++ A√ëADE ESTA FUNCI√ìN COMPLETA A LA CLASE ++
            _createDefaultMapping() {
                const mapping = {};
                const keyChars = Object.keys(this.keyToCode); // ['t', 'y', 'u', ...]
                for (let i = 0; i < keyChars.length; i++) {
                    const char = keyChars[i];
                    mapping[char] = i; // Asigna el √≠ndice: mapping['t'] = 0, mapping['y'] = 1, etc.
                }
                return mapping;
            }
            
            // Cargar configuraci√≥n guardada
            loadSavedConfig() {
                try {
                    const savedConfig = localStorage.getItem('alienSynthConfig');
                    if (savedConfig) {
                        const config = JSON.parse(savedConfig);
                        this.currentScale = config.scale || 'chromatic';
                        this.currentRootNote = config.rootNote || 0;
                        this.currentOctave = config.octave || 4;
                        this.attackTime = config.attack || 0.05;
                        this.releaseTime = config.release || 0.3;
                        this.velocity = config.velocity || 78;
                        
                        // Cargar mapeo de teclas personalizado si existe
                        if (config.keyMapping) {
                            this.customKeyMapping = config.keyMapping;
                        } else {
                            this.customKeyMapping = this._createDefaultMapping();

                        }
                    } else {
                        this.customKeyMapping = this._createDefaultMapping();

                    }
                } catch (e) {
                    console.error('Error al cargar configuraci√≥n del sintetizador:', e);
                    this.customKeyMapping = this._createDefaultMapping();

                }
            }
            
            // Guardar configuraci√≥n actual
            saveConfig() {
                try {
                    const config = {
                        scale: this.currentScale,
                        rootNote: this.currentRootNote,
                        octave: this.currentOctave,
                        attack: this.attackTime,
                        release: this.releaseTime,
                        velocity: this.velocity,
                        keyMapping: this.customKeyMapping
                    };
                    
                    localStorage.setItem('alienSynthConfig', JSON.stringify(config));
                    return true;
                } catch (e) {
                    console.error('Error al guardar configuraci√≥n del sintetizador:', e);
                    return false;
                }
            }
            
            // Inicializar Web Audio API
            // Inicializar Web Audio API
            // Inicializar Web Audio API
            initAudio(listener) { // <-- Acepta el listener principal
                try {
                    if (!listener || !listener.context) {
                        console.error("AlienSynth no recibi√≥ un AudioListener v√°lido!");
                        // Como fallback, crea uno, pero no es lo ideal
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        this.masterGain = this.audioContext.createGain();
                        this.masterGain.connect(this.audioContext.destination);
                        return;
                    }
                    
                    // 1. Usa el contexto de audio existente (¬°Esto estaba bien!)
                    this.audioContext = listener.context; 
                    
                    // 2. Crea el nodo de ganancia maestro para el synth (¬°Esto estaba bien!)
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.7; // Volumen predeterminado
                    
                    // 3. ¬°LA CORRECCI√ìN! Conecta el gain del synth DIRECTAMENTE A LA SALIDA (destination)
                    //    No debe pasar por el 'listener.gain', que es para el audio 3D.
                    this.masterGain.connect(this.audioContext.destination); 
                    
                    console.log('Sistema de audio del synth conectado al context.destination principal.');
                } catch (e) {
                    console.error('Error al inicializar el sistema de audio:', e);
                }
            }
            
            // Crear una nota con audio
            createAudioNote(frequency) {
                // Crear oscilador
                const oscillator = this.audioContext.createOscillator();
                oscillator.type = this.currentWaveform;
                oscillator.frequency.value = frequency;
                
                // Crear nodo de ganancia para esta nota
                const noteGain = this.audioContext.createGain();
                noteGain.gain.value = 0;
                
                // Conectar oscilador -> noteGain -> masterGain -> salida
                oscillator.connect(noteGain);
                noteGain.connect(this.masterGain);
                
                // Configurar ataque
                const now = this.audioContext.currentTime;
                noteGain.gain.setValueAtTime(0, now);
                noteGain.gain.linearRampToValueAtTime(this.velocity / 127, now + this.attackTime);
                
                // Iniciar oscilador
                oscillator.start();
                
                return { oscillator, noteGain };
            }
            
            // Detener una nota
            stopAudioNote(noteObj) {
                const now = this.audioContext.currentTime;
                
                // Aplicar release
                noteObj.noteGain.gain.cancelScheduledValues(now);
                noteObj.noteGain.gain.setValueAtTime(noteObj.noteGain.gain.value, now);
                noteObj.noteGain.gain.exponentialRampToValueAtTime(0.001, now + this.releaseTime);
                
                // Detener oscilador despu√©s del release
                setTimeout(() => {
                    try {
                        noteObj.oscillator.stop();
                        noteObj.oscillator.disconnect();
                        noteObj.noteGain.disconnect();
                    } catch (e) {
                        // Ignorar errores si ya se ha detenido
                    }
                }, this.releaseTime * 1000);
            }
            
            // Convertir n√∫mero MIDI a frecuencia
            midiToFrequency(midiNote) {
                return 440 * Math.pow(2, (midiNote - 69) / 12);
            }
            
            
            
            // Generar el teclado en el DOM basado en la escala actual
            generateKeyboard() {
                if (!this.synthKeyboardContainer) return;
                this.synthKeyboardContainer.innerHTML = '';

                const rows = [
                    ['t', 'y', 'u', 'i', 'o', 'p', '¬¥', '+'],
                    ['g', 'h', 'j', 'k', 'l', '√±', '{'],
                    ['b', 'n', 'm', ',', '.', '-']
                ];

                const scaleNotes = this.getScaleNotes();
                let noteCounter = 0;

                rows.forEach((rowKeys, rowIndex) => {
                    const rowElement = document.createElement('div');
                    rowElement.className = 'keyboard-row';
                    if (rowIndex === 1) rowElement.style.marginLeft = '20px';
                    if (rowIndex === 2) rowElement.style.marginLeft = '45px';

                    rowKeys.forEach(keyChar => {
                        const noteValue = scaleNotes[noteCounter % scaleNotes.length];
                        const isBlack = [1, 3, 6, 8, 10].includes(noteValue % 12);
                        
                        const keyElement = document.createElement('div');
                        keyElement.className = `key ${isBlack ? 'black' : 'white'}`;
                        keyElement.dataset.note = noteValue;
                        
                        const eventCode = this.keyToCode[keyChar]; 
                        if (eventCode) {
                            keyElement.dataset.code = eventCode;
                        }
                        
                        keyElement.innerHTML = `${this.getNoteNameFromValue(noteValue)}<span class="key-binding">${keyChar.toUpperCase()}</span>`;

                        // --- L√ìGICA T√ÅCTIL Y DE MOUSE UNIFICADA ---
                        
                        const startNote = (e) => {
                            if (e.cancelable) e.preventDefault(); // Prevenir scroll/zoom
                            
                            if (this.audioContext && this.audioContext.state === 'suspended') {
                                this.audioContext.resume();
                            }

                            if (!this.isRebinding && !keyElement.classList.contains('active')) {
                                const adjustedNote = this.getAdjustedNote(noteValue);
                                this.playNote(adjustedNote);
                                keyElement.classList.add('active');
                            }
                        };

                        const stopNote = (e) => {
                            if (e.cancelable) e.preventDefault();

                            if (!this.isRebinding) {
                                const adjustedNote = this.getAdjustedNote(noteValue);
                                this.stopNote(adjustedNote);
                                keyElement.classList.remove('active');
                            }
                        };
                        
                        // Listeners Mouse
                        keyElement.addEventListener('mousedown', startNote);
                        keyElement.addEventListener('mouseup', stopNote);
                        keyElement.addEventListener('mouseleave', (e) => {
                            if (keyElement.classList.contains('active')) stopNote(e);
                        });

                        // Listeners T√°ctiles (passive: false permite e.preventDefault)
                        keyElement.addEventListener('touchstart', startNote, { passive: false });
                        keyElement.addEventListener('touchend', stopNote, { passive: false });
                        keyElement.addEventListener('touchcancel', stopNote, { passive: false });

                        rowElement.appendChild(keyElement);
                        noteCounter++;
                    });

                    this.synthKeyboardContainer.appendChild(rowElement);
                });
            }


            
            // Obtener las notas de la escala actual con la nota ra√≠z aplicada
            getScaleNotes() {
                const scaleIntervals = this.scales[this.currentScale];
                const notes = [];
                
                // Generar 3 octavas de notas para tener suficientes
                for (let octave = 0; octave < 3; octave++) {
                    for (const interval of scaleIntervals) {
                        const note = (this.currentRootNote + interval + octave * 12) % 36;
                        notes.push(note);
                    }
                }
                
                // Ordenar y eliminar duplicados
                return [...new Set(notes)].sort((a, b) => a - b);
            }
            
            // Ajustar nota seg√∫n la octava actual
            getAdjustedNote(noteValue) {
                return noteValue + ((this.currentOctave - 3) * 12);
            }
            
            // Obtener nombre de nota a partir del valor relativo
            getNoteNameFromValue(noteValue) {
                const noteIndex = (noteValue + this.currentRootNote) % 12;
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return noteNames[noteIndex];
            }
            
            // Inicializar todos los event listeners
            initializeEventListeners() {
                // Bot√≥n para minimizar/maximizar
                this.headerElement.addEventListener('click', (event) => {
                // Nos aseguramos de que el clic no sea en un bot√≥n dentro del encabezado
                if (event.target.tagName !== 'BUTTON' && !event.target.closest('button')) {
                    this.toggleMinimize();
                }
            });                
                // Bot√≥n de configuraci√≥n
                    this.settingsButton.addEventListener('click', () => this.toggleConfigPanel());
                
                // Bot√≥n de cerrar configuraci√≥n
                this.closeConfigButton.addEventListener('click', () => this.toggleConfigPanel());
                
                // Controles de octava
                this.octaveDown.addEventListener('click', () => this.changeOctave(-1));
                this.octaveUp.addEventListener('click', () => this.changeOctave(1));
                
                // Control de volumen (velocidad MIDI)
                this.velocitySlider.addEventListener('input', () => {
                    this.velocity = parseInt(this.velocitySlider.value);
                    this.volumeDisplay.textContent = this.velocity;
                });
                
                // Selector de escala
                this.scaleSelector.addEventListener('change', () => {
                    this.currentScale = this.scaleSelector.value;
                    this.updateScaleDisplay();
                    this.generateKeyboard();
                });
                
                // Selector de nota ra√≠z
                this.rootNoteSelector.addEventListener('change', () => {
                    this.currentRootNote = parseInt(this.rootNoteSelector.value);
                    this.updateScaleDisplay();
                    this.generateKeyboard();
                });
                
                // Bot√≥n para resetear asignaciones de teclas
                this.resetKeyBindingsButton.addEventListener('click', () => {
                    this.customKeyMapping = this._createDefaultMapping();
                    this.generateKeyboard();
                    this.keyBindingStatus.textContent = "Asignaciones de teclas restauradas";
                });
                
                // Bot√≥n para guardar configuraci√≥n
                this.saveConfigButton.addEventListener('click', () => {
                    if (this.saveConfig()) {
                        this.keyBindingStatus.textContent = "Configuraci√≥n guardada correctamente";
                        this.toggleConfigPanel();
                    } else {
                        this.keyBindingStatus.textContent = "Error al guardar la configuraci√≥n";
                    }
                });
                
                // Knobs (diales) - Attack y Release
                this.setupKnobControl(this.attackKnob, 'attack', 0.01, 0.5);
                this.setupKnobControl(this.releaseKnob, 'release', 0.1, 2.0);
                
                // Botones de selecci√≥n de forma de onda
                const waveButtons = document.querySelectorAll('.wave-button');
                waveButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        // Desactivar todos los botones
                        waveButtons.forEach(btn => btn.classList.remove('active'));
                        // Activar el bot√≥n seleccionado
                        button.classList.add('active');
                        // Cambiar forma de onda
                        this.currentWaveform = button.getAttribute('data-wave');
                    });
                });
                
                // Iniciar modo de reasignaci√≥n de teclas
                this.keyboardElement.addEventListener('click', (e) => {
                    // Solo para iniciar audio en Chrome, no para reasignar teclas
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                });
                
                // Eventos para el teclado f√≠sico
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                // Evento para asignar nueva tecla
                document.addEventListener('keypress', (e) => {
                    if (this.isRebinding && this.selectedKey) {
                        e.preventDefault();
                        
                        const keyChar = e.key.toLowerCase();
                        const keyIndex = parseInt(this.selectedKey.dataset.index);
                        
                        // Verificar si la tecla ya est√° asignada
                        for (const [key, index] of Object.entries(this.customKeyMapping)) {
                            if (key === keyChar) {
                                this.customKeyMapping[key] = null; // Desasignar la tecla anterior
                            }
                        }
                        
                        // Asignar la nueva tecla
                        this.customKeyMapping[keyChar] = keyIndex;
                        
                        // Actualizar visualizaci√≥n
                        this.selectedKey.querySelector('.key-binding').textContent = keyChar.toUpperCase();
                        this.keyBindingStatus.textContent = `Tecla ${keyChar.toUpperCase()} asignada a ${this.getNoteNameFromValue(parseInt(this.selectedKey.dataset.note))}`;
                        
                        // Finalizar reasignaci√≥n
                        this.selectedKey.classList.remove('rebinding');
                        this.selectedKey = null;
                        this.isRebinding = false;
                    }
                });
                
                // Inicializar selectores
                this.scaleSelector.value = this.currentScale;
                this.rootNoteSelector.value = this.currentRootNote;
            }
            
            // Configurar control para los knobs (diales)
            setupKnobControl(knobElement, paramName, minValue, maxValue) {
                let isDragging = false;
                let startY;
                let startValue;
                
                // Valor inicial
                if (paramName === 'attack') {
                    startValue = this.attackTime;
                } else if (paramName === 'release') {
                    startValue = this.releaseTime;
                }
                
                // Evento mousedown
                knobElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startValue = paramName === 'attack' ? this.attackTime : this.releaseTime;
                    
                    // Capturar el mouse
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    
                    // Prevenir selecci√≥n de texto
                    e.preventDefault();
                });
                
                // Funci√≥n para manejar mousemove
                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    
                    // Calcular delta Y (movimiento invertido para que hacia arriba aumente el valor)
                    const deltaY = startY - e.clientY;
                    const sensitivity = 0.005; // Sensibilidad del knob
                    
                    // Calcular nuevo valor basado en el rango
                    let newValue = startValue + (deltaY * sensitivity);
                    newValue = Math.max(minValue, Math.min(maxValue, newValue));
                    
                    // Actualizar valor seg√∫n el par√°metro
                    if (paramName === 'attack') {
                        this.attackTime = newValue;
                    } else if (paramName === 'release') {
                        this.releaseTime = newValue;
                    }
                    
                    // Actualizar posici√≥n visual del knob
                    this.updateKnobPosition(paramName, newValue);
                };
                
                // Funci√≥n para manejar mouseup
                const onMouseUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
            }
            
            // Actualizar la posici√≥n visual de los knobs
            updateKnobPosition(paramName, value) {
                const knobElement = paramName === 'attack' ? this.attackKnob : this.releaseKnob;
                const minValue = paramName === 'attack' ? 0.01 : 0.1;
                const maxValue = paramName === 'attack' ? 0.5 : 2.0;
                
                // Calcular √°ngulo basado en el valor (0 a 270 grados)
                const range = maxValue - minValue;
                const normalizedValue = (value - minValue) / range;
                const angle = normalizedValue * 270; // Rango de 270 grados
                
                // Actualizar la rotaci√≥n del knob
                knobElement.style.transform = `rotate(${angle}deg)`;
            }
            
            // Actualizar visualizaci√≥n de la escala actual
            updateScaleDisplay() {
                // Obtener nombre legible de la escala
                const scaleNames = {
                    chromatic: 'CROM√ÅTICA',
                    major: 'MAYOR',
                    minor: 'MENOR',
                    pentatonic: 'PENTAT√ìNICA',
                    blues: 'BLUES',
                    harmonicMinor: 'MENOR ARM√ìNICA',
                    dorian: 'D√ìRICA',
                    phrygian: 'FRIGIA',
                    lydian: 'LIDIA',
                    mixolydian: 'MIXOLIDIA'
                };
                
                // Obtener nombre de la nota ra√≠z
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const rootName = noteNames[this.currentRootNote];
                
                // Actualizar visualizaci√≥n
                this.currentScaleDisplay.textContent = `${rootName} ${scaleNames[this.currentScale]}`;
            }
            
            // Minimizar/maximizar el teclado
            toggleMinimize() {
                this.isMinimized = !this.isMinimized;
                if (this.isMinimized) {
                    this.keyboardElement.classList.add('minimized');
                    
                    // Si el panel de configuraci√≥n est√° abierto, cerrarlo
                    if (this.isConfigOpen) {
                        this.toggleConfigPanel();
                    }
                } else {
                    this.keyboardElement.classList.remove('minimized');
                }
            }
            
            // Abrir/cerrar panel de configuraci√≥n
            toggleConfigPanel() {
                this.isConfigOpen = !this.isConfigOpen;
                
                if (this.isConfigOpen) {
                    this.configPanel.style.display = 'block';
                    this.isRebinding = false;
                    this.keyBindingStatus.textContent = 'Listo para reasignar';
                    
                    // Si est√° minimizado, expandirlo
                    if (this.isMinimized) {
                        this.toggleMinimize();
                    }
                } else {
                    this.configPanel.style.display = 'none';
                    
                    // Si estaba en modo reasignaci√≥n, cancelarlo
                    if (this.selectedKey) {
                        this.selectedKey.classList.remove('rebinding');
                        this.selectedKey = null;
                        this.isRebinding = false;
                    }
                }
            }
            
            // Cambiar octava
            changeOctave(delta) {
                this.currentOctave = Math.max(1, Math.min(7, this.currentOctave + delta));
                this.currentOctaveDisplay.textContent = this.currentOctave;
            }
            
            // Manejar eventos keydown del teclado f√≠sico
            handleKeyDown(e) {
                // Evitar repetici√≥n de tecla mantenida
                if (e.repeat) return;
                
                // Evitar capturar teclas cuando se est√° escribiendo en un input o en modo reasignaci√≥n
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || this.isRebinding) return;

                 // 3. A√ëADE el siguiente bloque en su lugar. Es m√°s corto y eficiente.
    
                // Buscamos directamente la tecla virtual que corresponde al C√ìDIGO de la tecla f√≠sica.
                const keyElement = this.synthKeyboardContainer.querySelector(`.key[data-code="${e.code}"]`);

            // Si encontramos una tecla y no est√° ya activa...
                 if (keyElement && !keyElement.classList.contains('active')) {
                // Prevenir comportamiento predeterminado (scrolling, etc.)
                // Tambi√©n previene la acci√≥n de la tecla 'p' si est√° mapeada, sin necesidad de la l√≥gica anterior.
                e.preventDefault(); 
                
                // El resto de tu l√≥gica original se mantiene casi id√©ntica:
                const noteValue = parseInt(keyElement.dataset.note);
                const adjustedNote = this.getAdjustedNote(noteValue);
                
                // Marcar la tecla virtual como activa
                keyElement.classList.add('active');
                
                // Tocar la nota
                this.playNote(adjustedNote);
            }
                
        }
            
            // Manejar eventos keyup del teclado f√≠sico
            handleKeyUp(e) {
                // Evitar capturar teclas cuando se est√° escribiendo en un input o en modo reasignaci√≥n
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || this.isRebinding) return;
                
               // Buscamos la tecla virtual usando el c√≥digo de la tecla f√≠sica.
                const keyElement = this.synthKeyboardContainer.querySelector(`.key[data-code="${e.code}"]`);

            // Si encontramos una tecla...
                 if (keyElement) {
                // Tu l√≥gica original se mantiene:
                const noteValue = parseInt(keyElement.dataset.note);
                const adjustedNote = this.getAdjustedNote(noteValue);
                
                // Desmarcar la tecla virtual
                keyElement.classList.remove('active');
                
                // Detener la nota
                this.stopNote(adjustedNote);
            }
            }
            
            // Tocar una nota (audio + efecto visual + integraci√≥n con galaxias)
            // Tocar una nota (audio + efecto visual + integraci√≥n con galaxias)
            playNote(noteNumber) {
                // Evitar tocar la misma nota dos veces
                if (this.activeKeys.has(noteNumber)) return;
                
                this.activeKeys.add(noteNumber);
                
                // Actualizar visualizaci√≥n
                const noteName = this.getNoteNameFromMIDI(noteNumber);
                this.currentNoteDisplay.textContent = noteName;
                
                // Verificar que la galaxia del usuario existe
                if (galaxies[username]) {
                    // --- ¬°L√ìGICA DE AUDIO 3D A√ëADIDA! ---
                    // 1. Crear el sonido 3D desde nuestra galaxia local
                    const galaxy = galaxies[username];
                    if (galaxy.positionalAudio && !galaxy.activeAudioNotes[noteNumber]) {
                        const frequency = this.midiToFrequency(noteNumber);
                        const oscillator = this.audioContext.createOscillator();
                        oscillator.type = this.currentWaveform;
                        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);

                        const gainNode = this.audioContext.createGain();
                        const targetVolume = (this.velocity / 127) * 0.7;
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(targetVolume, this.audioContext.currentTime + this.attackTime);

                        oscillator.connect(gainNode);
                        gainNode.connect(galaxy.positionalAudio.gain); // Conectar al audio 3D local
                        oscillator.start();
                        
                        galaxy.activeAudioNotes[noteNumber] = { oscillator, gainNode };
                    }
                    
                    // 2. A√±adir la nota a la galaxia (mismo m√©todo que usa el MIDI hardware)
                    galaxy.addNote(noteNumber, this.velocity);

                    // 3. Enviar la nota al servidor
                    sendNote('note_on', noteNumber, this.velocity);
                    
                    if (midiStatusElement) {
                        midiStatusElement.textContent = `Nota: ${noteName} (${noteNumber}), Velocidad: ${this.velocity}`;
                    }
                }
            }
            
            // Detener una nota
            stopNote(noteNumber) {
                this.activeKeys.delete(noteNumber);
                
                // Verificar que la galaxia del usuario existe
                if (galaxies[username]) {
                    const galaxy = galaxies[username];

                    // --- ¬°L√ìGICA DE AUDIO 3D A√ëADIDA! ---
                    // 1. Detener el sonido 3D local
                    if (galaxy.activeAudioNotes[noteNumber]) {
                        const { oscillator, gainNode } = galaxy.activeAudioNotes[noteNumber];
                        const now = this.audioContext.currentTime;
                        
                        gainNode.gain.cancelScheduledValues(now);
                        gainNode.gain.setValueAtTime(gainNode.gain.value, now); 
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + this.releaseTime); 

                        oscillator.stop(now + this.releaseTime + 0.05); 

                        setTimeout(() => {
                            try {
                                oscillator.disconnect();
                                gainNode.disconnect();
                            } catch(e) { /* Ignorar */ }
                        }, (this.releaseTime + 0.1) * 1000); 

                        delete galaxy.activeAudioNotes[noteNumber];
                    }
                    
                    // 2. Eliminar la nota de la galaxia (visual)
                    galaxy.removeNote(noteNumber);

                    // 3. Enviar la nota al servidor
                    sendNote('note_off', noteNumber, 0);
                }
                
                // Actualizar visualizaci√≥n
                if (this.activeKeys.size === 0) {
                    this.currentNoteDisplay.textContent = '--';
                }
            }
            
            // Obtener nombre de nota a partir del n√∫mero MIDI
            getNoteNameFromMIDI(midiNote) {
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const octave = Math.floor(midiNote / 12) - 1;
                const noteName = noteNames[midiNote % 12];
                return `${noteName}${octave}`;
            }
            
            // Verificar si una tecla debe ser inhibida (como la P)
            isKeyInhibited(key) {
                if (key === 'p' && this.inhibitKeyP) {
                    return true;
                }
                return false;
            }
        }

         // Agregar un event listener al documento para cerrar el men√∫ al hacer clic fuera
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('settingsMenu');
            const settingsButton = document.getElementById('btnSettings');
            
            // Si el men√∫ est√° abierto y el clic no fue dentro del men√∫ ni en el bot√≥n de configuraci√≥n
            if (menu.style.display === 'block' && 
                !menu.contains(event.target) && 
                event.target !== settingsButton) {
                menu.style.display = 'none';
            }
        });   

        // Evitar que los clics dentro del men√∫ cierren el men√∫
        document.getElementById('settingsMenu').addEventListener('click', function(event) {
            event.stopPropagation(); // Evita que el clic se propague al documento
        });

        // Iniciar todo cuando el DOM est√© cargado
        document.addEventListener('DOMContentLoaded', function() {
            // Inicializaciones originales
            init();
            initMIDI();
            
            // Inicializar el sintetizador virtual alien√≠gena
            const alienSynth = new AlienSynthKeyboard(audioListener);            
            // Exportar a una variable global para acceso desde otras partes del c√≥digo
            window.alienSynth = alienSynth;

            // --- C√ìDIGO A√ëADIDO: Minimizar sintetizador al hacer clic fuera ---
        document.addEventListener('click', function(event) {
            const keyboardElement = document.getElementById('virtualKeyboard');
            const settingsMenu = document.getElementById('settingsMenu'); // Referencia al men√∫ de configuraci√≥n principal
            const synth = window.alienSynth; // Accedemos a la instancia global

            // Si no existe el sintetizador o su elemento, no hacemos nada
            if (!synth || !keyboardElement) {
                return;
            }

            // Condici√≥n para minimizar:
            // 1. El sintetizador debe estar abierto (no minimizado).
            // 2. El clic NO debe ser dentro del propio sintetizador.
            // 3. El clic NO debe ser dentro del men√∫ de configuraci√≥n principal (para no cerrarlo al mismo tiempo).
            const isClickOutsideSynth = !keyboardElement.contains(event.target);
            const isClickOutsideSettings = !settingsMenu.contains(event.target);

            if (!synth.isMinimized && isClickOutsideSynth && isClickOutsideSettings) {
                synth.toggleMinimize(); // Llamamos a la funci√≥n para minimizarlo
            }
        });
        // --- FIN DEL C√ìDIGO A√ëADIDO ---
            
            // Asegurar que la funci√≥n getNoteNameFromMIDI est√© disponible globalmente si es necesario
            if (typeof window.getNoteNameFromMIDI !== 'function') {
                window.getNoteNameFromMIDI = function(midiNote) {
                    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                    const octave = Math.floor(midiNote / 12) - 1;
                    const noteName = noteNames[midiNote % 12];
                    return `${noteName}${octave}`;
                };
            }
        });

    </script>
        <!-- Teclado MIDI Virtual Compacto y Transparente -->
        <div id="virtualKeyboard" class="alien-synth compact minimized">
            <div class="synth-header">
            <div class="synth-logo">
                <span class="alien-text">XENO</span><span class="alien-glow">SYNTH</span>
            </div>
            <div class="synth-controls">
                <button id="synthSettings" class="alien-button settings-btn" title="Configuraci√≥n">‚öô</button>
            </div>
        </div>
        
        <div class="synth-body">
            <div class="synth-display">
                <div class="display-screen">
                    <div class="display-left">
                        <div class="display-octave">OCT: <span id="currentOctave">4</span></div>
                        <div class="display-velocity">VOL: <span id="displayVolume">78</span></div>
                    </div>
                    <div class="display-right">
                        <div class="display-note" id="currentNote">--</div>
                        <div class="display-scale">SCALE: <span id="currentScale">CHROMATIC</span></div>
                    </div>
                </div>
            </div>
            
            <div class="synth-panel">
                <div class="panel-section">
                    <div class="control-knob">
                        <div class="knob-ring"></div>
                        <div class="knob" id="knobAttack">
                            <div class="knob-indicator"></div>
                        </div>
                        <div class="knob-label">ATTACK</div>
                    </div>
                    <div class="control-knob">
                        <div class="knob-ring"></div>
                        <div class="knob" id="knobRelease">
                            <div class="knob-indicator"></div>
                        </div>
                        <div class="knob-label">RELEASE</div>
                    </div>
                    <div class="control-group">
                        <label>OCTAVE</label>
                        <div class="control-buttons">
                            <button id="octaveDown" class="alien-small-button">-</button>
                            <button id="octaveUp" class="alien-small-button">+</button>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="control-slider">
                        <label>VOLUME</label>
                        <input type="range" id="virtualVelocity" min="1" max="127" value="78">
                    </div>
                    <div class="wave-selector">
                        <label>WAVEFORM</label>
                        <div class="wave-buttons">
                            <button class="wave-button active" data-wave="sine">‚ó†‚ó°</button>
                            <button class="wave-button" data-wave="square">‚ñÆ‚ñØ</button>
                            <button class="wave-button" data-wave="sawtooth">‚ó∏</button>
                            <button class="wave-button" data-wave="triangle">‚ó∫‚óø</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="keyboard-container">
                <!-- Contenedor simplificado para las teclas - se generan din√°micamente con JS -->
                <div id="synthKeyboard" class="synth-keyboard">
                    <!-- Las teclas se generar√°n din√°micamente -->
                </div>
            </div>
        </div>
        
        <!-- Panel de configuraci√≥n del sintetizador -->
        <div id="synthConfigPanel" class="synth-config-panel">
            <div class="config-header">
                <h3>Configuraci√≥n del Sintetizador</h3>
                <button id="closeConfigPanel" class="alien-button">‚úï</button>
            </div>
            <div class="config-body">
                <div class="config-section">
                    <h4>Escala Musical</h4>
                    <select id="scaleSelector" class="alien-select">
                        <option value="chromatic">Crom√°tica (Todas las notas)</option>
                        <option value="major">Mayor</option>
                        <option value="minor">Menor</option>
                        <option value="pentatonic">Pentat√≥nica Mayor</option>
                        <option value="blues">Blues</option>
                        <option value="harmonicMinor">Menor Arm√≥nica</option>
                        <option value="dorian">Modo D√≥rico</option>
                        <option value="phrygian">Modo Frigio</option>
                        <option value="lydian">Modo Lidio</option>
                        <option value="mixolydian">Modo Mixolidio</option>
                    </select>
                </div>
                
                <div class="config-section">
                    <h4>Nota Base</h4>
                    <select id="rootNoteSelector" class="alien-select">
                        <option value="0">C (Do)</option>
                        <option value="1">C# (Do#)</option>
                        <option value="2">D (Re)</option>
                        <option value="3">D# (Re#)</option>
                        <option value="4">E (Mi)</option>
                        <option value="5">F (Fa)</option>
                        <option value="6">F# (Fa#)</option>
                        <option value="7">G (Sol)</option>
                        <option value="8">G# (Sol#)</option>
                        <option value="9">A (La)</option>
                        <option value="10">A# (La#)</option>
                        <option value="11">B (Si)</option>
                    </select>
                </div>
                
                <div class="config-section">
                    <h4>Personalizaci√≥n de Teclas</h4>
                    <div class="key-binding-info">
                        <p>Clica en una tecla del teclado y luego presiona la tecla en tu teclado f√≠sico para reasignarla.</p>
                    </div>
                    <div class="key-binding-status">
                        <span id="keyBindingStatus">Listo para reasignar</span>
                    </div>
                    <button id="resetKeyBindings" class="alien-config-button">Restaurar asignaciones predeterminadas</button>
                </div>
                
                <div class="config-section">
                    <button id="saveConfig" class="alien-config-button save-btn">Guardar Configuraci√≥n</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Estilos para el sintetizador compacto y transparente -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&family=Rajdhani:wght@500&display=swap');

        /* Animaciones */
        @keyframes glow {
            0% { text-shadow: 0 0 10px rgba(98, 215, 255, 0.5), 0 0 20px rgba(98, 215, 255, 0.2); }
            50% { text-shadow: 0 0 15px rgba(98, 215, 255, 0.8), 0 0 30px rgba(98, 215, 255, 0.5); }
            100% { text-shadow: 0 0 10px rgba(98, 215, 255, 0.5), 0 0 20px rgba(98, 215, 255, 0.2); }
        }

        @keyframes pulse {
            0% { opacity: 0.9; box-shadow: 0 0 10px rgba(98, 215, 255, 0.7); }
            50% { opacity: 1; box-shadow: 0 0 20px rgba(98, 215, 255, 1); }
            100% { opacity: 0.9; box-shadow: 0 0 10px rgba(98, 215, 255, 0.7); }
        }

        /* Estilos principales */
        .alien-synth {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 450px; /* Reducido de 580px */
            background: rgba(10, 15, 34, 0.01); /* Mayor transparencia */
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(98, 215, 255, 0.3);
            color: #c7e5ff;
            font-family: 'Orbitron', sans-serif;
            z-index: 300;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(98, 215, 255, 0.3);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            padding-bottom: 8px;
        }
        
        .alien-synth.compact {
            max-height: calc(100vh - 100px); /* Evitar que ocupe toda la pantalla */
        }

        .alien-synth.minimized {
            height: 45px !important;
            width: 250px;
        }

        .alien-synth.minimized .synth-body {
            height: 0;
            opacity: 0;
        }

        .synth-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: rgba(16, 23, 46, 0.8);
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            border-bottom: 1px solid rgba(98, 215, 255, 0.4);
        }

        .synth-logo {
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .alien-text {
            color: #62d7ff;
        }

        .alien-glow {
            color: #ffffff;
            animation: glow 2s infinite;
        }

        .synth-controls {
            display: flex;
            gap: 8px;
        }

        .alien-button {
            background: none;
            border: 1px solid rgba(98, 215, 255, 0.4);
            color: #62d7ff;
            font-size: 14px;
            width: 28px;
            height: 28px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .alien-button:hover {
            background-color: rgba(98, 215, 255, 0.2);
            box-shadow: 0 0 10px rgba(98, 215, 255, 0.4);
        }

        .alien-synth.minimized .alien-button .alien-icon {
            transform: rotate(180deg);
        }

        .alien-small-button {
            background: rgba(16, 23, 46, 0.9);
            border: 1px solid rgba(98, 215, 255, 0.4);
            color: #62d7ff;
            font-size: 12px;
            width: 22px;
            height: 22px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .alien-small-button:hover {
            background-color: rgba(98, 215, 255, 0.2);
        }

        .synth-body {
            transition: all 0.5s;
            overflow: hidden;
        }

        /* Display del sintetizador */
        .synth-display {
            padding: 8px 12px;
            background: rgba(8, 12, 24, 0.6);
            border-bottom: 1px solid rgba(98, 215, 255, 0.3);
        }

        .display-screen {
            background: linear-gradient(180deg, rgba(8, 31, 40, 0.8), rgba(10, 25, 35, 0.8));
            border-radius: 5px;
            border: 1px solid rgba(98, 215, 255, 0.5);
            padding: 8px 12px;
            height: 60px; /* Reducido de 70px */
            color: #62d7ff;
            font-family: 'Rajdhani', sans-serif;
            display: flex;
            flex-wrap: wrap;
            position: relative;
        }

        .display-left, .display-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .display-octave, .display-velocity, .display-note, .display-scale {
            font-size: 14px;
            padding: 3px 0;
        }

        .display-note {
            font-size: 20px;
            font-weight: bold;
            text-align: right;
        }

        .display-scale {
            text-align: right;
        }

        /* Panel de control */
        .synth-panel {
            display: flex;
            background: rgba(16, 23, 46, 0.5);
            padding: 10px; /* Reducido de 15px */
            border-bottom: 1px solid rgba(98, 215, 255, 0.3);
        }

        .panel-section {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Reducido de 15px */
            align-items: center;
            justify-content: space-around;
        }

        .control-knob {
            position: relative;
            width: 40px; /* Reducido de 50px */
            height: 60px; /* Reducido de 70px */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .knob-ring {
            width: 32px; /* Reducido de 40px */
            height: 32px; /* Reducido de 40px */
            border-radius: 50%;
            border: 1px solid rgba(98, 215, 255, 0.5);
            position: relative;
        }

        .knob {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 24px; /* Reducido de 30px */
            height: 24px; /* Reducido de 30px */
            border-radius: 50%;
            background: linear-gradient(145deg, rgba(20, 30, 60, 0.9), rgba(25, 40, 80, 0.9));
            box-shadow: 0 0 5px rgba(98, 215, 255, 0.3);
            cursor: pointer;
        }

        .knob-indicator {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px; /* Reducido de 10px */
            background-color: #62d7ff;
            border-radius: 1px;
        }

        .knob-label {
            margin-top: 6px; /* Reducido de 8px */
            font-size: 8px; /* Reducido de 10px */
            text-align: center;
            color: #c7e5ff;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px; /* Reducido de 5px */
        }

        .control-group label {
            font-size: 8px; /* Reducido de 10px */
            color: #c7e5ff;
        }

        .control-buttons {
            display: flex;
            gap: 4px; /* Reducido de 5px */
        }

        .control-slider {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 4px; /* Reducido de 5px */
        }

        .control-slider label {
            font-size: 8px; /* Reducido de 10px */
            color: #c7e5ff;
            text-align: center;
        }

        #virtualVelocity {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(98, 215, 255, 0.3);
            border-radius: 2px;
            outline: none;
        }

        #virtualVelocity::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px; /* Reducido de 15px */
            height: 12px; /* Reducido de 15px */
            border-radius: 50%;
            background: linear-gradient(145deg, #62d7ff, #4aa9cc);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(98, 215, 255, 0.5);
        }

        #virtualVelocity::-moz-range-thumb {
            width: 12px; /* Reducido de 15px */
            height: 12px; /* Reducido de 15px */
            border-radius: 50%;
            background: linear-gradient(145deg, #62d7ff, #4aa9cc);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(98, 215, 255, 0.5);
        }

        .wave-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px; /* Reducido de 5px */
            width: 100%;
        }

        .wave-selector label {
            font-size: 8px; /* Reducido de 10px */
            color: #c7e5ff;
        }

        .wave-buttons {
            display: flex;
            gap: 3px; /* Reducido de 5px */
            justify-content: center;
        }

        .wave-button {
            width: 25px; /* Reducido de 30px */
            height: 20px; /* Reducido de 25px */
            background: rgba(16, 23, 46, 0.9);
            border: 1px solid rgba(98, 215, 255, 0.4);
            border-radius: 3px;
            color: #62d7ff;
            font-size: 11px; /* Reducido de 12px */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wave-button.active {
            background-color: rgba(98, 215, 255, 0.3);
            box-shadow: 0 0 8px rgba(98, 215, 255, 0.5);
        }

        /* Teclado */
        .keyboard-container {
            padding: 8px 10px; /* Reducido de 10px 15px */
            background: rgba(12, 18, 35, 0.6);
        }

         /* Pega estas nuevas reglas en tu CSS */
         .synth-keyboard {
            display: flex;
            flex-direction: column; /* Apila las filas verticalmente */
            align-items: center;  /* Centra las filas */
            gap: 4px;             /* Espacio entre filas */
        }

        .keyboard-row {
            display: flex;
            justify-content: center; /* Centra las teclas en la fila */
        }


        .key {
            position: relative;
            height: 40px; /* Reducido de 50px */
            width: 36px; /* Reducido de 50px */
            margin: 0 1px; /* Reducido de 2px */
            border-radius: 4px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            font-size: 10px; /* Reducido de 12px */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
            padding-bottom: 6px; /* Reducido de 8px */
            user-select: none;
        }

        .key.white {
            background: linear-gradient(180deg, #f2f9ff, #d9e9ff);
            border: 1px solid rgba(98, 215, 255, 0.7);
            color: #1f2d59;
            box-shadow: 0 4px 0 rgba(98, 215, 255, 0.3);
            z-index: 1;
        }

        .key.black {
            background: linear-gradient(180deg, #313b5e, #1c2340);
            border: 1px solid rgba(98, 215, 255, 0.5);
            color: #c7e5ff;
            box-shadow: 0 3px 0 rgba(11, 16, 33, 0.8);
            z-index: 2;
            height: 34px; /* M√°s peque√±as que las blancas */
            margin-top: 0;
        }

        .key.white:hover {
            background: linear-gradient(180deg, #ffffff, #e9f5ff);
            box-shadow: 0 4px 0 rgba(98, 215, 255, 0.5);
        }

        .key.black:hover {
            background: linear-gradient(180deg, #3a4573, #232b4f);
            box-shadow: 0 3px 0 rgba(16, 23, 46, 0.8);
        }

        .key.white:active, .key.white.active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(98, 215, 255, 0.3);
        }

        .key.black:active, .key.black.active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 rgba(11, 16, 33, 0.8);
        }

        .key-binding {
            position: absolute;
            top: 3px;
            right: 4px;
            font-size: 7px; /* Reducido de 9px */
            opacity: 0.7;
        }

        .key.rebinding {
            border: 2px solid #ff62b5;
            box-shadow: 0 0 10px rgba(255, 98, 181, 0.5);
        }

        /* Panel de configuraci√≥n */
        .synth-config-panel {
            position: absolute;
            top: 45px;
            right: 0;
            width: 100%;
            background: rgba(10, 15, 34, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(98, 215, 255, 0.5);
            box-shadow: 0 0 20px rgba(98, 215, 255, 0.3);
            z-index: 301;
            display: none;
            overflow: auto;
            max-height: 70vh;
        }

        .config-header {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(98, 215, 255, 0.3);
        }

        .config-header h3 {
            margin: 0;
            font-size: 16px;
            color: #62d7ff;
        }

        .config-body {
            padding: 15px;
        }

        .config-section {
            margin-bottom: 15px;
        }

        .config-section h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #c7e5ff;
        }

        .alien-select {
            width: 100%;
            padding: 6px 10px;
            background: rgba(16, 23, 46, 0.9);
            border: 1px solid rgba(98, 215, 255, 0.4);
            border-radius: 4px;
            color: #c7e5ff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            appearance: none;
            cursor: pointer;
        }

        .alien-select:focus {
            outline: none;
            border-color: #62d7ff;
            box-shadow: 0 0 8px rgba(98, 215, 255, 0.5);
        }

        .key-binding-info p {
            font-size: 12px;
            line-height: 1.4;
            margin: 0 0 8px 0;
        }

        .key-binding-status {
            background: rgba(16, 23, 46, 0.6);
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .alien-config-button {
            background: rgba(16, 23, 46, 0.9);
            border: 1px solid rgba(98, 215, 255, 0.4);
            border-radius: 4px;
            color: #c7e5ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .alien-config-button:hover {
            background: rgba(25, 35, 70, 0.9);
            box-shadow: 0 0 8px rgba(98, 215, 255, 0.5);
        }

        .save-btn {
            background: rgba(25, 60, 100, 0.9);
            width: 100%;
        }

        .save-btn:hover {
            background: rgba(35, 75, 120, 0.9);
        }
    </style>
</body>

</html>
