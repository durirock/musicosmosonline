
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0", maximum-scale=1.0, user-scalable=no">
    <title>Musicosmos - Universo Musical Interactivo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: white;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            opacity: 1;
            transition: opacity 2s ease-in;
        }
        .fade-out {
            opacity: 0 !important; /* Añadimos !important para forzar la prioridad */
            transition: opacity 2s ease-in; /* Reducir a 2 segundos para una transición más rápida */
            pointer-events: none; /* Impedir que se pueda hacer click después del fade */
        }
        #midiStatus {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
        }
        #coordinates {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
        }
        #teleportPanel {
            position: absolute;
            bottom: 60px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            z-index: 100;
            border-radius: 5px;
            display: none;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(100, 120, 255, 0.3);
            box-shadow: 0 0 15px rgba(100, 120, 255, 0.3);
        }
        #teleportPanel input {
            width: 60px;
            background-color: rgba(30,30,40,0.8);
            color: white;
            border: 1px solid #557;
            border-radius: 3px;
            padding: 5px;
            margin: 0 5px;
            font-family: monospace;
        }
        #teleportPanel button {
            background-color: #4466dd;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 6px 12px;
            cursor: pointer;
            margin-left: 10px;
        }
        #teleportPanel button:hover {
            background-color: #5577ee;
        }
        canvas {
            display: block;
        }
        .btn-settings {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 15px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-settings:hover {
            background-color: rgba(70,70,100,0.8);
            transform: scale(1.1);
        }
        .btn-teleport {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 0 10px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-teleport:hover {
            background-color: rgba(70,70,100,0.8);
        }
        .btn-perspective {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 0 10px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-perspective:hover {
            background-color: rgba(70,70,100,0.8);
        }
        #settingsMenu {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            /* CAMBIA ESTA LÍNEA para mayor transparencia */
            background-color: rgba(30, 30, 50, 0.85); 
            color: white;
            border-radius: 10px;
            padding: 0; /* Lo quitamos de aquí para controlar por secciones */
            box-shadow: 0 0 20px rgba(0,0,255,0.3);
            z-index: 200;
            display: none;
            backdrop-filter: blur(8px); /* Aumentamos el blur para que se vea mejor */
        }

        #settingsMenu h3 {
            margin-top: 0;
            color: #aaf;
            border-bottom: 1px solid #557;
            padding-bottom: 10px;
        }
        #viewControls {
            position: absolute;
            right: 20px;
            bottom: 70px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #viewControls button {
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        #viewControls button:hover {
            background-color: rgba(70,70,100,0.8);
        }
        .midi-device-item {
            margin-bottom: 10px;
            padding: 8px;
            background-color: rgba(50,50,80,0.5);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .midi-device-item.active {
            background-color: rgba(80,80,180,0.5);
            border-left: 3px solid #88f;
        }
        .toggle-button {
            width: 40px;
            height: 20px;
            background-color: #444;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
        }
        .toggle-button.active {
            background-color: #55f;
        }
        .toggle-button::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        .toggle-button.active::after {
            transform: translateX(20px);
        }
        .network-status {
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid #557;
        }
        #usernameInput {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background-color: rgba(40,40,60,0.9);
            color: white;
            border: 1px solid #557;
            border-radius: 5px;
        }
        #connectButton {
            padding: 8px 16px;
            background-color: #4466dd;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #connectButton:hover {
            background-color: #5577ee;
        }

        .playlist-separator {
            border: none;
            height: 1px;
            background-color: #557;
            margin: 15px 0;
        }

        .playlist-section {
            width: 100%;
        }

        .playlist-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 0 5px;
        }

        .playlist-header-controls strong {
            font-size: 14px;
            color: #c7e5ff;
        }

        .playlist-buttons button {
            background: none;
            border: 1px solid #557;
            color: #aab;
            width: 28px;
            height: 28px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .playlist-buttons button:hover {
            border-color: #fff;
            color: #fff;
        }

        .playlist-buttons button.active {
            background-color: rgba(68, 102, 221, 0.6);
            border-color: #4466dd;
            color: #fff;
        }

        .playlist-item.radio-stream {
            background-color: rgba(20, 20, 25, 0.8);
            border: 1px solid #98324a;
            color: #ff99aa;
            font-weight: bold;
            border-radius: 5px;
            margin: 0 15px; /* Margen para que no ocupe todo el ancho */
        }

        .playlist-item.radio-stream:hover {
            border-color: #ff5577;
            color: #ffdde2;
            background-color: rgba(50, 25, 30, 0.8);
        }

        .playlist-item.radio-stream.active {
            background-color: rgba(180, 60, 90, 0.6);
            border-color: #ff809d;
            color: #fff;
        }

        .playlist-item-empty {
            padding: 10px;
            text-align: center;
            font-style: italic;
            color: #778;
        }
        </style>
    </style>
</head>
<body>
    <div id="touch-controls" class="touch-controls-container">
        <div id="joystick-container">
            <div id="joystick-knob"></div>
        </div>
        
        <div id="joystick-container-rotation">
            <div id="joystick-knob-rotation"></div>
        </div>

        <div id="button-hyperspace" class="action-button">🚀</div>
    </div>
    <div id="info">
        <h1>Musicosmos</h1>
        <p>Conecta un dispositivo MIDI y toca para crear galaxias musicales.</p>
        <p>Usa las teclas W, A, S, D para moverte, ratón para navegar en todas direcciones.</p>
    </div>
    
    <div id="midiStatus">Esperando conexión MIDI...</div>
    <div id="coordinates">X: 0.00, Y: 0.00, Z: 0.00</div>
    
    <button class="btn-teleport" id="btnTeleport">Teletransporte</button>
    <button class="btn-perspective" id="btnPerspective">Cambiar Vista</button>
    
    <div id="teleportPanel">
        <div>X: <input type="number" id="teleportX" step="0.1"></div>
        <div>Y: <input type="number" id="teleportY" step="0.1"></div>
        <div>Z: <input type="number" id="teleportZ" step="0.1"></div>
        <button id="btnGoToCoords">Ir a Coordenadas</button>
    </div>
    

    
    <button class="btn-settings" id="btnSettings">⚙️</button>
    
    <div id="settingsMenu"> 
        
        <div class="settings-tabs">
            <button class="tab-button active" data-tab="tab-general">General</button>
            <button class="tab-button" data-tab="tab-playlist">Playlist</button>
            <button class="tab-button" data-tab="tab-pulsares">Pulsares</button>
        </div>
        
        <div id="tab-general" class="tab-content active">
            <h3>Configuración General</h3>
            
            <div>
                <h4>Dispositivos MIDI</h4>
                <div id="midiDevicesContainer">
                    <p>No se encontraron dispositivos MIDI</p>
                </div>
            </div>
            
            <div class="network-status">
                <h4>Multijugador</h4>
                <input type="text" id="usernameInput" placeholder="Tu nombre en el cosmos" maxlength="20">
                <button id="connectButton">Conectar</button>
                <div id="playersOnline"></div>
            </div>
        
            <div class="galaxy-settings">
                <h4>Configuración de Galaxia</h4>
                <div class="setting-item">
                    <label for="galaxySize">Tamaño de Galaxia:</label>
                    <input type="range" id="galaxySize" min="15" max="50" value="25" class="slider">
                    <span id="galaxySizeValue">25</span>
                </div>
                <div class="setting-item">
                    <label for="particleCount">Partículas Afectadas por Nota:</label>
                    <input type="range" id="particleCount" min="5" max="30" value="12" class="slider">
                    <span id="particleCountValue">12%</span>
                </div>
                <div class="setting-item">
                    <label for="colorMixing">Intensidad de Mezcla de Color:</label>
                    <input type="range" id="colorMixing" min="30" max="80" value="50" class="slider">
                    <span id="colorMixingValue">50%</span>
                </div>
                <div class="setting-item">
                    <label for="expansionTime">Tiempo de Expansión:</label>
                    <input type="range" id="expansionTime" min="2000" max="8000" value="4000" step="1000" class="slider">
                    <span id="expansionTimeValue">4s</span>
                </div>
                <div class="setting-item">
                    <label for="fadeoutTime">Tiempo de Inactividad:</label>
                    <input type="range" id="fadeoutTime" min="10000" max="60000" value="20000" step="5000" class="slider">
                    <span id="fadeoutTimeValue">20s</span>
                </div>
                <button id="applyGalaxySettings" class="settings-button">Guardar Configuración</button>
                <button id="resetGalaxySettings" class="settings-button secondary">Restaurar Valores</button>
            </div>
        </div>
        
        <div id="tab-playlist" class="tab-content">
            <h3>Playlist del Cosmos</h3>
        
            <div class="playlist-section" id="radio-section">
                <div id="tagua-radio-item" class="playlist-item radio-stream">
                    <span class="play-indicator">▶</span> Radio Tagua Tagua (Stream)
                </div>
            </div>
        
            <hr class="playlist-separator">
        
            <div class="playlist-section">
                <div class="playlist-header-controls">
                    <strong>Púlsares Descubiertos</strong>
                    <div class="playlist-buttons">
                        <button id="btn-repeat" title="Repetir">🔁</button>
                        <button id="btn-shuffle" title="Aleatorio">🔀</button>
                    </div>
                </div>
                <div class="playlist-container">
                    <ul id="playlist-list">
                        <li class="playlist-item-empty">Aún no has descubierto púlsares.</li>
                    </ul>
                </div>
            </div>
            
            <div class="playlist-controls">
                <div id="now-playing">
                    <strong>Ahora suena:</strong> <span id="current-track-name">Silencio...</span>
                </div>
                <div class="volume-control">
                    <label for="playlist-volume">Volumen Playlist (2D):</label>
                    <input type="range" id="playlist-volume" min="0" max="1" step="0.01" value="0.7">
                </div>
                <div class="volume-control">
                    <label for="pulsarVolume">Volumen Púlsares (3D):</label>
                    <input type="range" id="pulsarVolume" min="0.1" max="15" value="5" step="0.1" class="slider">
                    <span id="pulsarVolumeValue">5.0</span>
                </div>
            </div>
        </div>
        
        
        
        <div id="tab-pulsares" class="tab-content">
            <h3>Forja de Pulsares</h3>
            <p>Próximamente: La forja donde podrás dar a luz a nuevos soles musicales.</p>
        </div>
          
          <!-- Estilos para el panel de configuración -->
          <style>
            /* Controles Táctiles */
            .touch-controls-container {
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 100%; /* Ocupa toda la pantalla para capturar gestos de cámara */
                pointer-events: none; /* Por defecto no intercepta, solo los hijos con 'auto' */
                display: none; /* Oculto por defecto, se muestra con JS */
                z-index: 50; /* Asegúrate de que esté por encima del canvas pero debajo de menús modales si los tienes */
            }

            #joystick-container {
                position: absolute;
                bottom: 30px;
                left: 30px;
                width: 150px;
                height: 150px;
                background-color: rgba(50, 50, 80, 0.3);
                border-radius: 50%;
                display: flex;
                justify-content: center;
                align-items: center;
                pointer-events: auto; /* Permite interacción con el joystick */
                border: 2px solid rgba(120, 120, 150, 0.5);
                user-select: none; /* Evitar selección de texto */
                -webkit-user-select: none; /* Safari */
                -ms-user-select: none; /* IE 10+ */
            }

            #joystick-knob {
                width: 70px;
                height: 70px;
                background-color: rgba(100, 100, 150, 0.7);
                border-radius: 50%;
                border: 2px solid rgba(180, 180, 220, 0.8);
                position: absolute; /* Se moverá dentro del contenedor del joystick */
                cursor: pointer;
                user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
            }

            #action-buttons-container {
                position: absolute;
                bottom: 40px;
                right: 30px;
                display: flex;
                flex-direction: column;
                gap: 20px;
                pointer-events: auto; /* Permite interacción con los botones */
                user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
            }

            .action-button {
                width: 70px;
                height: 70px;
                background-color: rgba(100, 100, 150, 0.6);
                border-radius: 50%;
                border: 2px solid rgba(180, 180, 220, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 24px;
                font-weight: bold;
                color: white;
                cursor: pointer;
                user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
            }
            .action-button:active {
                background-color: rgba(120, 120, 180, 0.8);
            }

            /* Asegurar que el body no haga scroll en táctil */
            body.touch-active {
                overscroll-behavior: none;
            }

            .galaxy-settings {
              margin-top: 20px;
              padding-top: 15px;
              border-top: 1px solid #557;
            }
            
            .setting-item {
              margin: 12px 0;
              display: flex;
              align-items: center;
              flex-wrap: wrap;
            }
            
            .setting-item label {
              width: 100%;
              margin-bottom: 5px;
              color: #aaf;
              font-size: 14px;
            }
            
            .slider {
              flex: 1;
              height: 6px;
              appearance: none;
              background: rgba(50,50,100,0.6);
              border-radius: 3px;
              margin-right: 10px;
            }
            
            .slider::-webkit-slider-thumb {
              appearance: none;
              width: 15px;
              height: 15px;
              border-radius: 50%;
              background: #4466dd;
              cursor: pointer;
            }
            
            .slider::-moz-range-thumb {
              width: 15px;
              height: 15px;
              border-radius: 50%;
              background: #4466dd;
              cursor: pointer;
            }
            
            .settings-button {
              padding: 8px 16px;
              background-color: #4466dd;
              color: white;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              margin-top: 10px;
              margin-right: 10px;
            }
            
            .settings-button:hover {
              background-color: #5577ee;
            }
            
            .settings-button.secondary {
              background-color: #555;
            }
            
            .settings-button.secondary:hover {
              background-color: #777;
            }

            /* --- ESTILOS PARA PESTAÑAS DEL PANEL DE CONFIGURACIÓN --- */
            .settings-tabs {
                display: flex;
                border-bottom: 1px solid #557;
                background-color: rgba(40, 40, 60, 0.9);
                padding: 5px 5px 0 5px;
                border-top-left-radius: 10px;
                border-top-right-radius: 10px;
            }

            .tab-button {
                padding: 10px 15px;
                cursor: pointer;
                background-color: transparent;
                border: none;
                color: #aab;
                font-size: 14px;
                border-radius: 5px 5px 0 0;
                transition: background-color 0.3s, color 0.3s;
                outline: none;
            }

            .tab-button:hover {
                background-color: rgba(80, 80, 120, 0.5);
                color: #fff;
            }

            .tab-button.active {
                background-color: rgba(30, 30, 50, 0.9); /* Mismo color que el fondo del panel */
                color: #fff;
                border-bottom: 2px solid #4466dd;
            }

            .tab-content {
                display: none; /* Oculto por defecto */
                padding: 15px;
                animation: fadeIn 0.5s;
            }

            .tab-content.active {
                display: block; /* Visible solo si tiene la clase active */
            }

            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }

            /* --- ESTILOS PARA LA PESTAÑA PLAYLIST --- */
            .playlist-container {
                max-height: 200px;
                overflow-y: auto;
                background-color: rgba(15, 15, 25, 0.7);
                border: 1px solid #557;
                border-radius: 5px;
                margin-bottom: 15px;
            }

            #playlist-list {
                list-style: none;
                padding: 0;
                margin: 0;
            }

            .playlist-item {
                padding: 10px 12px;
                border-bottom: 1px solid #334;
                cursor: pointer;
                transition: background-color 0.2s;
                font-size: 14px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .playlist-item:last-child {
                border-bottom: none;
            }

            .playlist-item:hover {
                background-color: rgba(80, 80, 120, 0.5);
            }

            .playlist-item.active {
                background-color: rgba(68, 102, 221, 0.6);
                color: #fff;
                font-weight: bold;
            }

            .playlist-item .play-indicator {
                font-size: 10px;
                color: #9f9;
                opacity: 0;
                transition: opacity 0.3s;
            }

            .playlist-item.active .play-indicator {
                opacity: 1;
            }

            .playlist-controls {
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid #557;
            }

            #now-playing {
                font-size: 13px;
                margin-bottom: 10px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            #now-playing span {
                color: #aac;
            }

            .volume-control {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 14px;
            }

            #playlist-volume {
                flex-grow: 1;
            }

            /* --- AÑADE ESTOS ESTILOS AL FINAL DE TU CSS --- */
            .radio-control-section {
                padding: 10px;
                background-color: rgba(30, 30, 50, 0.8);
                border-radius: 5px;
                margin-bottom: 15px;
                text-align: center;
            }
            .radio-control-section strong {
                font-size: 14px;
                color: #ffc0d0; /* Color distintivo para la radio */
            }
            .radio-buttons {
                margin-top: 8px;
                display: flex;
                justify-content: center;
                gap: 10px;
            }
            .radio-buttons button {
                background-color: #555;
                border: 1px solid #777;
                color: #eee;
                padding: 5px 15px;
                border-radius: 4px;
                cursor: pointer;
            }
            .radio-buttons button:hover {
                background-color: #666;
            }
            /* AÑADE ESTE BLOQUE A TU CSS */

            .playlist-separator {
                border: none;
                height: 1px;
                background-color: #557;
                margin: 10px 15px;
            }
            .playlist-section {
                padding: 0 15px;
            }
            #radio-section {
                padding-bottom: 5px;
            }
            .playlist-header-controls {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
            }
            .playlist-buttons button {
                background: none; border: 1px solid #557; color: #aab;
                width: 28px; height: 28px; border-radius: 5px; cursor: pointer;
                font-size: 14px; transition: all 0.2s;
            }
            .playlist-buttons button:hover {
                border-color: #fff; color: #fff;
            }
            .playlist-buttons button.active {
                background-color: rgba(68, 102, 221, 0.6);
                border-color: #4466dd; color: #fff;
            }
            .playlist-item.radio-stream {
                background-color: rgba(20, 20, 25, 0.8);
                border: 1px solid #98324a; color: #ff99aa;
                font-weight: bold; border-radius: 5px;
            }
            .playlist-item.radio-stream:hover {
                border-color: #ff5577; color: #ffdde2;
                background-color: rgba(50, 25, 30, 0.8);
            }
            .playlist-item.radio-stream.active {
                background-color: rgba(180, 60, 90, 0.6);
                border-color: #ff809d; color: #fff;
            }
            .playlist-item-empty {
                padding: 10px; text-align: center;
                font-style: italic; color: #778;
            }
            .volume-control {
                margin-top: 10px;
            }
            /* --- ESTILOS PARA EL SEGUNDO JOYSTICK (ROTACIÓN) --- */
        #joystick-container-rotation {
            position: absolute;
            bottom: 30px;
            right: 30px; /* <-- La clave es 'right' en lugar de 'left' */
            width: 150px;
            height: 150px;
            background-color: rgba(50, 50, 80, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            border: 2px solid rgba(120, 120, 150, 0.5);
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        #joystick-knob-rotation {
            width: 70px;
            height: 70px;
            background-color: rgba(100, 100, 150, 0.7);
            border-radius: 50%;
            border: 2px solid rgba(180, 180, 220, 0.8);
            position: absolute;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
        /* --- ESTILOS PARA EL BOTÓN DE HIPERVELOCIDAD --- */
        #button-hyperspace {
            position: absolute;
            bottom: 180px; /* Posición vertical */
            right: 30px;   /* Posición horizontal */
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }

        #button-hyperspace.active {
            background-color: rgba(98, 215, 255, 0.7);
            box-shadow: 0 0 20px rgba(98, 215, 255, 1);
            transform: scale(1.1);
        }
          </style>
          
          <!-- Script para manejar la configuración de la galaxia -->
          <script>
          // Variables para almacenar la configuración de la galaxia
          let galaxySettings = {
            size: 25,
            particleCount: 12,
            colorMixing: 50,
            expansionTime: 4000,
            fadeoutTime: 20000
          };
          
          // Función para inicializar los sliders y eventos
          function initGalaxySettings() {
            // Vincular sliders con sus valores de visualización
            const sliders = {
                'galaxySize': { elem: document.getElementById('galaxySizeValue'), suffix: '', key: 'size' },
                'particleCount': { elem: document.getElementById('particleCountValue'), suffix: '%', key: 'particleCount' },
                'colorMixing': { elem: document.getElementById('colorMixingValue'), suffix: '%', key: 'colorMixing' },
                'expansionTime': { elem: document.getElementById('expansionTimeValue'), suffix: 's', key: 'expansionTime' },
                'fadeoutTime': { elem: document.getElementById('fadeoutTimeValue'), suffix: 's', key: 'fadeoutTime' }
            };
            
            // Configurar eventos de los sliders
            Object.keys(sliders).forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const info = sliders[sliderId];
                
                slider.addEventListener('input', () => {
                let displayValue = slider.value;
                
                // Formatear valores especiales
                if (sliderId === 'expansionTime' || sliderId === 'fadeoutTime') {
                    displayValue = (slider.value / 1000).toFixed(0);
                }
                
                info.elem.textContent = displayValue + info.suffix;
                galaxySettings[info.key] = parseInt(slider.value);
                
                // Aplicar cambios inmediatamente
                applyGalaxySettings(false); // Pasar false para no mostrar notificación
                });
            });
            
            // El botón aplicar ahora solo guarda la configuración
            document.getElementById('applyGalaxySettings').textContent = 'Guardar Configuración';
            document.getElementById('applyGalaxySettings').addEventListener('click', applyGalaxySettings);
            
            // Botón restaurar valores
            document.getElementById('resetGalaxySettings').addEventListener('click', resetGalaxySettings);
            }

            // Modificar la función // Modificar la función applyGalaxySettings para aceptar un parámetro de notificación
            function applyGalaxySettings(showNotification = true) {
                // Solo guardar en localStorage si se solicita explícitamente (botón)
                if (showNotification) {
                    localStorage.setItem('musicosmosGalaxySettings', JSON.stringify(galaxySettings));
                }
                
                // Aplicar a configuración global que se usará para nuevas galaxias
                if (GALAXY_PIXEL_CONFIG) {
                    GALAXY_PIXEL_CONFIG.maxExpansion = galaxySettings.size;
                }
                
                // Aplicar a galaxias existentes
                for (const galaxyId in galaxies) {
                    const galaxy = galaxies[galaxyId];
                    if (galaxy && galaxy.pixelGalaxy) {
                        // Crear objeto de configuración nueva
                        const newConfig = {
                            maxExpansion: galaxySettings.size,
                            particleAffectedRatio: galaxySettings.particleCount / 100,
                            colorMixFactor: galaxySettings.colorMixing / 100,
                            expansionTime: galaxySettings.expansionTime,
                            inactivityTime: galaxySettings.fadeoutTime
                        };
                        
                        // Usar el nuevo método updateConfig si está disponible
                        if (galaxy.pixelGalaxy.updateConfig) {
                            galaxy.pixelGalaxy.updateConfig(newConfig);
                        } 
                        // Compatibilidad con la implementación anterior
                        else if (galaxy.pixelGalaxy.config) {
                            // Actualizar configuración
                            galaxy.pixelGalaxy.config.maxExpansion = galaxySettings.size;
                            galaxy.pixelGalaxy.config.particleAffectedRatio = galaxySettings.particleCount / 100;
                            galaxy.pixelGalaxy.config.colorMixFactor = galaxySettings.colorMixing / 100;
                            galaxy.pixelGalaxy.config.expansionTime = galaxySettings.expansionTime;
                            galaxy.pixelGalaxy.config.inactivityTime = galaxySettings.fadeoutTime;
                        }
                    }
                }
                
                // Notificar solo si se solicita (al usar el botón guardar)
                if (showNotification) {
                    showNotification('Configuración guardada', 2000);
                }
            }
          
          // Función para restaurar valores predeterminados
          function resetGalaxySettings() {
            // Restaurar valores por defecto
            document.getElementById('galaxySize').value = 25;
            document.getElementById('galaxySizeValue').textContent = '25';
            document.getElementById('particleCount').value = 12;
            document.getElementById('particleCountValue').textContent = '12%';
            document.getElementById('colorMixing').value = 50;
            document.getElementById('colorMixingValue').textContent = '50%';
            document.getElementById('expansionTime').value = 4000;
            document.getElementById('expansionTimeValue').textContent = '4s';
            document.getElementById('fadeoutTime').value = 20000;
            document.getElementById('fadeoutTimeValue').textContent = '20s';
            
            // Actualizar objeto de configuración
            galaxySettings = {
              size: 25,
              particleCount: 12,
              colorMixing: 50,
              expansionTime: 4000,
              fadeoutTime: 20000
            };
            
            // Aplicar valores restaurados
            applyGalaxySettings();
          }
          
          // Función auxiliar para mostrar notificaciones
          function showNotification(message, duration = 3000) {
            // Crear elemento de notificación si no existe
            let notification = document.getElementById('notification');
            if (!notification) {
              notification = document.createElement('div');
              notification.id = 'notification';
              notification.style.position = 'fixed';
              notification.style.bottom = '20px';
              notification.style.left = '50%';
              notification.style.transform = 'translateX(-50%)';
              notification.style.backgroundColor = 'rgba(68, 102, 221, 0.8)';
              notification.style.color = 'white';
              notification.style.padding = '10px 20px';
              notification.style.borderRadius = '5px';
              notification.style.zIndex = '1000';
              notification.style.transition = 'opacity 0.3s';
              document.body.appendChild(notification);
            }
            
            // Mostrar mensaje
            notification.textContent = message;
            notification.style.opacity = '1';
            
            // Ocultar después de la duración
            setTimeout(() => {
              notification.style.opacity = '0';
            }, duration);
          }
          
          // Cargar configuración guardada al iniciar
          function loadGalaxySettings() {
            const savedSettings = localStorage.getItem('musicosmosGalaxySettings');
            if (savedSettings) {
              try {
                const parsedSettings = JSON.parse(savedSettings);
                galaxySettings = parsedSettings;
                
                // Actualizar sliders con valores guardados
                document.getElementById('galaxySize').value = galaxySettings.size;
                document.getElementById('galaxySizeValue').textContent = galaxySettings.size;
                document.getElementById('particleCount').value = galaxySettings.particleCount;
                document.getElementById('particleCountValue').textContent = galaxySettings.particleCount + '%';
                document.getElementById('colorMixing').value = galaxySettings.colorMixing;
                document.getElementById('colorMixingValue').textContent = galaxySettings.colorMixing + '%';
                document.getElementById('expansionTime').value = galaxySettings.expansionTime;
                document.getElementById('expansionTimeValue').textContent = (galaxySettings.expansionTime / 1000) + 's';
                document.getElementById('fadeoutTime').value = galaxySettings.fadeoutTime;
                document.getElementById('fadeoutTimeValue').textContent = (galaxySettings.fadeoutTime / 1000) + 's';
              } catch (e) {
                console.error('Error al cargar configuración guardada:', e);
              }
            }
          }
          
          // Inicializar configuración cuando el DOM esté cargado
          document.addEventListener('DOMContentLoaded', function() {
            // Inicializar cuando el DOM esté listo
            initGalaxySettings();
            
            // Cargar configuración guardada
            loadGalaxySettings();
          });
          </script>
          
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Variables principales
        let scene, camera, renderer;
        let nebulaRadarElement, radarArrowElement, radarDotElement;
        let ultimaCancionUrl = null; // Aquí guardaremos la URL de la última canción usada
        // AÑADIR ESTAS VARIABLES PARA EL CONTROL DE LA ÓRBITA
        // ----------------------------------------------------
        let currentOrbitAngleH = 0; // Ángulo horizontal
        let currentOrbitAngleV = 0.2; // Ángulo vertical (un poco picado)
        // ----------------------------------------------------
        let clock = new THREE.Clock();
        let updatableSpecialFeatures = [];
        let audioListener;
        let galaxies = {};
        let particles = [];  // Para mezcla de colores global
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        let rotateCameraLeft = false;
        let rotateCameraRight = false;
        const cameraRotationSpeed = 0.02; // Velocidad de rotación
        let pitchAngle = 0;
        let yawAngle = 0;
        let gridHelper;
        let proceduralGenerator; // Añade esta línea
        let hyperspaceEffect;
        let hyperspaceModeActive = false;
        // AÑADIR ESTAS VARIABLES GLOBALES PARA EL MODO ÓRBITA
        // ----------------------------------------------------
        let isOrbitingNebula = false;
        let orbitingNebulaInstance = null;
        let orbitDistance = 200; // Distancia de la órbita
        let orbitAngle = 0.0;
        const ORBIT_SPEED = 0.0005; // La velocidad a la que el avatar girará automáticamente
        const MIN_ORBIT_DISTANCE = 40;
        const MAX_ORBIT_DISTANCE = 500;
        const ORBIT_ZOOM_SPEED = 2.5; // Velocidad para acercarse/alejarse con teclas en modo órbita.
        let currentOrbitType = 'comet'; // <-- ¡AÑADE ESTA LÍNEA! 'comet' o 'fixed'


        let playerOrbitSpeed = 0.0; // AÑADIDO: Controlará la velocidad orbital del jugador con A y D.

        // AÑADIR ESTAS NUEVAS VARIABLES GLOBALES PARA EL ARRASTRE DE PÚLSARES
        // ----------------------------------------------------
        let raycaster = new THREE.Raycaster();
        let mousePosition = new THREE.Vector2();
        let draggedPulsar = null; // Guardará la instancia del púlsar que estamos arrastrando

         // AÑADE ESTAS DOS LÍNEAS PARA EVITAR EL CRASH
        // ----------------------------------------------------
        let radioNebulaInstance = null;
        let radioNebulaInstanceTaguaTagua = null;
        let audioContext;

        // AÑADE ESTA CONSTANTE PARA LA CAPA DE CLIC
        const CLICKABLE_LAYER = 1;

        // --- Variables para la Radio Tagua Tagua Estática ---
        let radioTaguaTaguaStream;
        let radioTaguaTaguaNebula = null;
        let analyserNodeTaguaTagua;
        const TAGUA_TAGUA_STREAM_URL = 'https://stream-165.zeno.fm/d5rixk44lfyvv';
        const TAGUA_TAGUA_NEBULA_POS = new THREE.Vector3(0, 400, 0); // Posición: 400 unidades por encima del origen.

       // REEMPLAZA las variables de la playlist con estas:
         // --- Variables de la Playlist (Versión Simplificada) ---
        let playlistAudio = new Audio(); // Un único reproductor para todo
        let playlist = []; 
        let currentTrackId = null; // Usaremos un ID único ('radio' o el pulsarId) en lugar de un índice
        let userPlaylistVolume = 0.7; 
        let pulsarVolumeMultiplier = 10.0;
        let isRepeatOn = false;
        let isShuffleOn = false;

        // --- Constantes para el Fade ---
        const FADE_START_DISTANCE = 800; // Distancia a la que empieza el fade out
        const FADE_END_DISTANCE = 350;   // Distancia a la que el volumen es 0

        let isStereoMode = false;
        let eyeSeparation = 0.15; // Esta es la nueva variable que controla la intensidad del 3D

        // --- Variables para controles táctiles ---
        let isTouchDevice = false;
        let joystickActive = false;
        let joystickInitialPos = { x: 0, y: 0 };
        const joystickMaxDistance = 40; // Radio máximo de movimiento del knob (ajústalo si es necesario)

          // --> AÑADIDO: Variables para el segundo joystick y doble toque
        let rotationJoystickActive = false;
        let rotationJoystickInitialPos = { x: 0, y: 0 };
        let touchIdentifierRotationJoystick = null;
        let lastJoystickTapTime = 0; // Para detectar el doble toque


// ----------------------------------------------------
        function elegirSiguienteCancion() {
            // Si solo hay una canción en la biblioteca, no hay opción, devolvemos esa.
            if (miBibliotecaMusical.length <= 1) {
                return miBibliotecaMusical[0];
            }

            let cancionElegida;
            // Usamos un bucle 'do-while' para asegurarnos de que la nueva canción
            // sea diferente a la última. Repetirá el sorteo si sale la misma.
            do {
                const indiceAleatorio = Math.floor(Math.random() * miBibliotecaMusical.length);
                cancionElegida = miBibliotecaMusical[indiceAleatorio];
            } while (cancionElegida === ultimaCancionUrl);

            // Actualizamos nuestra memoria con la nueva canción que vamos a usar
            ultimaCancionUrl = cancionElegida;
            
            // Devolvemos la canción que no se repite
            return cancionElegida;
        }
        // Añade esto después de las variables principales (let scene, camera, renderer; etc.)

        // Sistema de generación procedural para Musicosmos
        // Versión mejorada del sistema procedural
        class ProceduralGenerator {
            constructor(scene, chunkSize = 200) {
                this.scene = scene;
                this.chunkSize = chunkSize;
                this.activeChunks = new Map();
                this.visibleDistance = 2;
                this.playerPosition = new THREE.Vector3();
                this.currentChunkCoords = null;
                this.chunkSeed = 12345;
                this.nebulaeObjects = []; // Tracking para animación de nebulosas
            }

            applyFadeOutEffect(chunkObject, onComplete) {
                const fadeOutDuration = 1500; // 1.5 segundos para el desvanecimiento
                const startTime = Date.now();

                const fadeOut = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1, elapsedTime / fadeOutDuration);
                    const opacity = 1 - progress; // Opacidad inversa

                    chunkObject.traverse(object => {
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(mat => {
                                    if (mat._originalOpacity) {
                                        mat.opacity = opacity * mat._originalOpacity;
                                    }
                                });
                            } else if (object.material._originalOpacity) {
                                object.material.opacity = opacity * object.material._originalOpacity;
                            }
                        }
                    });

                    if (progress < 1) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        onComplete(); // Llama a la función de completado cuando termina
                    }
                };
                fadeOut();
            }

            update(playerPosition) {
                this.playerPosition.copy(playerPosition);
                
                const chunkX = Math.floor(playerPosition.x / this.chunkSize);
                const chunkY = Math.floor(playerPosition.y / this.chunkSize);
                const chunkZ = Math.floor(playerPosition.z / this.chunkSize);
                const chunkCoords = `${chunkX},${chunkY},${chunkZ}`;
                
                if (this.currentChunkCoords !== chunkCoords) {
                    this.currentChunkCoords = chunkCoords;
                    this.updateChunks();
                }
                
                // Animar las nebulosas
                this.animateNebulae();
            }
            
            updateChunks() {
                const [chunkX, chunkY, chunkZ] = this.currentChunkCoords.split(',').map(Number);
                const chunksToKeep = new Set();
                
                for (let x = chunkX - this.visibleDistance; x <= chunkX + this.visibleDistance; x++) {
                    for (let y = chunkY - this.visibleDistance; y <= chunkY + this.visibleDistance; y++) {
                        for (let z = chunkZ - this.visibleDistance; z <= chunkZ + this.visibleDistance; z++) {
                            const coords = `${x},${y},${z}`;
                            chunksToKeep.add(coords);
                            
                            if (!this.activeChunks.has(coords)) {
                                this.generateChunk(x, y, z);
                            }
                        }
                    }
                }
                
                for (const coords of this.activeChunks.keys()) {
                    if (!chunksToKeep.has(coords)) {
                        this.removeChunk(coords);
                    }
                }
            }
            
            generateChunk(x, y, z) {
                console.log(`Generando cuadrante en [${x}, ${y}, ${z}]`);
                const chunkId = `${x},${y},${z}`;
                
                const chunkObject = new THREE.Group();
                chunkObject.position.set(
                    x * this.chunkSize + this.chunkSize/2,
                    y * this.chunkSize + this.chunkSize/2,
                    z * this.chunkSize + this.chunkSize/2
                );
                
                const chunkSeed = this.getChunkSeed(x, y, z);
                
                // Generar estrellas para este cuadrante
                this.generateStars(chunkObject, chunkSeed);
                
                // Reducir la probabilidad de nebulosas al 10%
                if (this.pseudoRandom(chunkSeed + 123) < 0.10) {
                    this.generateNebula(chunkObject, chunkSeed);
                }

                // AÑADIR ESTE BLOQUE PARA GENERAR PULSARES MP3
                // -------------------------------------------------------------------
                const pulsarChance = 0.02; 
                    if (Math.random() < pulsarChance) {
                        const pulsarId = `pulsar_${x}_${y}_${z}`;
                        if (!gestorDePulsares.activos[pulsarId]) {
                            const MIN_DISTANCE_BETWEEN_PULSARS = 1200;
                            let isTooClose = false;

                            const offsetX = (Math.random() - 0.5) * this.chunkSize * 0.8;
                            const offsetY = (Math.random() - 0.5) * this.chunkSize * 0.8;
                            const offsetZ = (Math.random() - 0.5) * this.chunkSize * 0.8;
                            const potentialPosition = new THREE.Vector3(chunkObject.position.x + offsetX, chunkObject.position.y + offsetY, chunkObject.position.z + offsetZ);

                            for (const existingPulsarId in gestorDePulsares.activos) {
                                const existingPulsar = gestorDePulsares.activos[existingPulsarId];
                                if (potentialPosition.distanceTo(existingPulsar.nebula.initialStaticPosition) < MIN_DISTANCE_BETWEEN_PULSARS) {
                                    isTooClose = true;
                                    break;
                                }
                            }

                            if (!isTooClose) {
                                console.log(`✨ Creando Pulsar Persistente en chunk [${x}, ${y}, ${z}]`);
                                
                                // ¡Punto Clave! Elegimos la canción AHORA, en el nacimiento.
                                const cancionUrl = elegirSiguienteCancion();

                                // AÑADE ESTA LÍNEA PARA AGREGAR LA CANCIÓN A LA PLAYLIST
                                addTrackToPlaylist(`Pulsar Descubierto #${Math.floor(Math.random()*1000)}`, cancionUrl);


                                const audioElement = new Audio();
                                audioElement.crossOrigin = "anonymous";
                                audioElement.loop = true;
                                // Guardamos la URL permanentemente en el objeto del pulsar
                                audioElement.url = cancionUrl;

                                const analyserNode = audioListener.context.createAnalyser();
                                analyserNode.fftSize = 512;
                                analyserNode.smoothingTimeConstant = 0.75;
                                
                                const positionalAudio = new THREE.PositionalAudio(audioListener);
                                const radioNebula = new RadioNebula(scene, potentialPosition, analyserNode, GALAXY_PULSAR_CONFIG, 'mp3', false);
                                radioNebula.particlesObject.add(positionalAudio);

                                gestorDePulsares.activos[pulsarId] = {
                                    id: pulsarId,
                                    nebula: radioNebula,
                                    audio: audioElement,
                                    analyser: analyserNode,
                                    positionalAudio: positionalAudio,
                                    url: cancionUrl, // Guardamos la URL asignada
                                    tiempoGuardado: 0, // NUEVO: Para guardar el tiempo de reproducción
                                    mediaSource: null,
                                    isLoaded: false,
                                    isPlaying: false
                                };
                            }
                        }
                    }

                
                // Aplicar aparición gradual
                this.applyFadeInEffect(chunkObject);
                
                this.scene.add(chunkObject);
                this.activeChunks.set(chunkId, chunkObject);
            }

            
            // Aplicar efecto de aparición gradual
            applyFadeInEffect(chunkObject) {
                // Comenzar con opacidad cero
                chunkObject.traverse(object => {
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(mat => {
                                mat.transparent = true;
                                mat._originalOpacity = mat.opacity || 1.0;
                                mat.opacity = 0;
                            });
                        } else {
                            object.material.transparent = true;
                            object.material._originalOpacity = object.material.opacity || 1.0;
                            object.material.opacity = 0;
                        }
                    }
                });
                
                // Definir la duración de la aparición gradual
                const fadeInDuration = 1000; // 1.5 segundos
                const startTime = Date.now();
                
                const fadeIn = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1, elapsedTime / fadeInDuration);
                    
                    // Aplicar opacidad gradual
                    chunkObject.traverse(object => {
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(mat => {
                                    if (mat._originalOpacity) {
                                        mat.opacity = progress * mat._originalOpacity;
                                    }
                                });
                            } else if (object.material._originalOpacity) {
                                object.material.opacity = progress * object.material._originalOpacity;
                            }
                        }
                    });
                    
                    if (progress < 1) {
                        requestAnimationFrame(fadeIn);
                    }
                };
                
                // Iniciar la animación de aparición
                fadeIn();
            }
            
            removeChunk(chunkId) {
                const chunkObject = this.activeChunks.get(chunkId);
                if (chunkObject) {
                    // Eliminar las nebulosas asociadas de la lista de animación
                    this.nebulaeObjects = this.nebulaeObjects.filter(nebData => {
                        return !chunkObject.children.includes(nebData.object);
                    });

                    // Iniciar el fade-out y eliminar el chunk solo cuando termine
                    this.applyFadeOutEffect(chunkObject, () => {
                        this.disposeChunkContents(chunkObject);
                        this.scene.remove(chunkObject);
                        console.log(`Eliminando cuadrante ${chunkId} después del fade-out`);
                    });

                    // Es importante eliminarlo del mapa de chunks activos inmediatamente
                    // para que no se intente eliminar de nuevo.
                    this.activeChunks.delete(chunkId);
                }
            }

            
            disposeChunkContents(chunkObject) {
                chunkObject.traverse(object => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            
            pseudoRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }
            
            getChunkSeed(x, y, z) {
                return this.chunkSeed + x * 73856093 + y * 19349663 + z * 83492791;
            }
            
            // Genera estrellas dentro del cuadrante (versión actualizada)
            generateStars(chunkObject, seed) {
                // Reducir cantidad de estrellas
                const starCount = Math.floor(this.pseudoRandom(seed) * 150) + 30; // Reducido de 500+100 a 150+50
                
                const starGeometry = new THREE.BufferGeometry();
                const starPositions = new Float32Array(starCount * 3);
                const starColors = new Float32Array(starCount * 3);
                const starSizes = new Float32Array(starCount);
                
                for (let i = 0; i < starCount; i++) {
                    const offsetX = (this.pseudoRandom(seed + i) - 0.5) * this.chunkSize;
                    const offsetY = (this.pseudoRandom(seed + i + 1000) - 0.5) * this.chunkSize;
                    const offsetZ = (this.pseudoRandom(seed + i + 2000) - 0.5) * this.chunkSize;
                    
                    starPositions[i * 3] = offsetX;
                    starPositions[i * 3 + 1] = offsetY;
                    starPositions[i * 3 + 2] = offsetZ;
                    
                    // Color y tamaño basado en posición
                    const colorOffset = this.pseudoRandom(seed + i * 3) * 0.2;
                    starColors[i * 3] = 0.8 + colorOffset;
                    starColors[i * 3 + 1] = 0.8 + colorOffset;
                    starColors[i * 3 + 2] = 0.9 + colorOffset * 0.5;
                    
                    // Tamaño reducido
                    starSizes[i] = 0.2 + this.pseudoRandom(seed + i * 7) * 0.5; // Reducido de 0.5+1.5 a 0.3+0.7
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
                starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: 0.2, // Reducido de 1.0 a 0.7
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true
                });
                
                const stars = new THREE.Points(starGeometry, starMaterial);
                chunkObject.add(stars);
            }
            
            // Genera una nebulosa dentro del cuadrante (versión actualizada con movimiento)
           // Versión mejorada con tamaños de nebulosas variables

            // Modificar el método de generación de nebulosas
            generateNebula(chunkObject, seed) {
                // Determinar el tamaño de la nebulosa - pequeña, mediana o grande
                const sizeCategory = this.pseudoRandom(seed + 222);
                let nebulaSizeBase, particleCount;
                
                if (sizeCategory < 0.33) {
                    // Nebulosa pequeña (33% de probabilidad)
                    nebulaSizeBase = 30;
                    particleCount = 1500; // Menos partículas para nebulosas pequeñas
                } else if (sizeCategory < 0.85) {
                    // Nebulosa mediana (52% de probabilidad)
                    nebulaSizeBase = 70;
                    particleCount = 3000; // Partículas estándar para nebulosas medianas
                } else {
                    // Nebulosa grande (15% de probabilidad)
                    nebulaSizeBase = 120;
                    particleCount = 5000; // Más partículas para nebulosas grandes
                }
                
                // Añadir variación al tamaño base
                const nebulaSize = nebulaSizeBase + this.pseudoRandom(seed + 333) * (nebulaSizeBase * 0.4);
                
                // Usar colores variados como en el procedural actual
                const hue = this.pseudoRandom(seed + 444); // Color aleatorio (0-1)
                const saturation = 0.6 + this.pseudoRandom(seed + 555) * 0.4; // Entre 0.6 y 1.0
                const baseLightness = 0.4 + this.pseudoRandom(seed + 666) * 0.2; // Entre 0.4 y 0.6
                
                // Crear geometría para la nebulosa
                const nebulaGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                // Distribución de partículas mejorada para núcleo más definido
                for (let i = 0; i < particleCount; i++) {
                    // Determinar si esta partícula será parte del núcleo o de la región externa
                    const isCore = this.pseudoRandom(seed + i * 15) < 0.3; // 30% de partículas en el núcleo
                    
                    // Radio variable según si es núcleo o región externa
                    let radius;
                    if (isCore) {
                        // Partículas del núcleo más concentradas
                        radius = Math.pow(this.pseudoRandom(seed + i * 10), 2.5) * nebulaSize * 0.3;
                    } else {
                        // Partículas externas más dispersas
                        radius = (0.3 + Math.pow(this.pseudoRandom(seed + i * 10), 1.2) * 0.7) * nebulaSize;
                    }
                    
                    // Forma esférica con aplastamiento
                    const theta = this.pseudoRandom(seed + i * 20) * Math.PI * 2;
                    const phi = this.pseudoRandom(seed + i * 30) * Math.PI;
                    
                    // Distorsión para crear forma de nebulosa - varía según el tamaño
                    // Las nebulosas pequeñas tienen menos distorsión para mantener forma compacta
                    const baseDistortion = sizeCategory < 0.33 ? 0.8 : 0.6;
                    const distortion = baseDistortion + this.pseudoRandom(seed + i * 40) * 
                                    (sizeCategory < 0.33 ? 0.4 : 0.8);
                    
                    // Coordenadas en polares
                    const x = radius * Math.sin(phi) * Math.cos(theta) * distortion;
                    const y = radius * Math.sin(phi) * Math.sin(theta) * 
                            (sizeCategory < 0.33 ? 0.7 : 0.5); // Menos aplastamiento para nebulosas pequeñas
                    const z = radius * Math.cos(phi) * distortion;
                    
                    // Posiciones
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                    
                    // Ajustar color basado en si es núcleo o región externa
                    let lightness = baseLightness;
                    let particleHue = hue;
                    
                    if (isCore) {
                        // El núcleo es más brillante
                        lightness += 0.2;
                        // Pequeña variación de tono para el núcleo
                        particleHue = (hue + this.pseudoRandom(seed + i * 50) * 0.05) % 1.0;
                    } else {
                        // Más variación en tono para las partículas externas
                        particleHue = (hue + (this.pseudoRandom(seed + i * 50) - 0.5) * 0.15) % 1.0;
                    }
                    
                    const c = new THREE.Color().setHSL(particleHue, saturation, lightness);
                    colors[i * 3] = c.r;
                    colors[i * 3 + 1] = c.g;
                    colors[i * 3 + 2] = c.b;
                    
                    // Tamaños variables - ajustados según el tamaño de la nebulosa
                    const particleSizeFactor = sizeCategory < 0.33 ? 0.8 : (sizeCategory > 0.85 ? 1.3 : 1.0);
                    
                    if (isCore) {
                        sizes[i] = (3 + Math.pow(this.pseudoRandom(seed + i * 60), 2) * 12) * particleSizeFactor;
                    } else {
                        sizes[i] = (1.5 + Math.pow(this.pseudoRandom(seed + i * 60), 2) * 8) * particleSizeFactor;
                    }
                }
                
                nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Material para nebulosa
                const nebulaMaterial = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.25,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false
                });
                
                const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
                
                // Rotación inicial aleatoria
                nebula.rotation.x = this.pseudoRandom(seed + 777) * Math.PI;
                nebula.rotation.y = this.pseudoRandom(seed + 888) * Math.PI;
                nebula.rotation.z = this.pseudoRandom(seed + 999) * Math.PI;
                
                // Posición dentro del cuadrante - ajustar según el tamaño
                // Las nebulosas grandes estarán más centradas para evitar cortes en los bordes
                const positionFactor = sizeCategory > 0.85 ? 0.5 : 0.8;
                const offsetX = (this.pseudoRandom(seed + 1111) - 0.5) * this.chunkSize * positionFactor;
                const offsetY = (this.pseudoRandom(seed + 2222) - 0.5) * this.chunkSize * positionFactor;
                const offsetZ = (this.pseudoRandom(seed + 3333) - 0.5) * this.chunkSize * positionFactor;
                nebula.position.set(offsetX, offsetY, offsetZ);
                
                // Añadir al cuadrante
                chunkObject.add(nebula);
                
                // Parámetros de animación - adaptados al tamaño
                // Las nebulosas más grandes se mueven más lentamente
                const speedFactor = sizeCategory > 0.85 ? 0.6 : (sizeCategory < 0.33 ? 1.3 : 1.0);
                
                const nebulaData = {
                    object: nebula,
                    // Velocidades de rotación escaladas por tamaño
                    rotationSpeed: {
                        x: (this.pseudoRandom(seed + 4444) - 0.5) * 0.002 * speedFactor,
                        y: (this.pseudoRandom(seed + 5555) - 0.5) * 0.002 * speedFactor,
                        z: (this.pseudoRandom(seed + 6666) - 0.5) * 0.002 * speedFactor
                    },
                    // Movimiento en elipse
                    movementPath: {
                        center: new THREE.Vector3(offsetX, offsetY, offsetZ),
                        amplitude: {
                            // Las amplitudes escalan con el tamaño - nebulosas más grandes tienen amplitudes mayores
                            x: (20 + this.pseudoRandom(seed + 7777) * 50) * (sizeCategory < 0.33 ? 0.7 : (sizeCategory > 0.85 ? 1.5 : 1.0)),
                            y: (20 + this.pseudoRandom(seed + 8888) * 50) * (sizeCategory < 0.33 ? 0.7 : (sizeCategory > 0.85 ? 1.5 : 1.0)),
                            z: (20 + this.pseudoRandom(seed + 9999) * 50) * (sizeCategory < 0.33 ? 0.7 : (sizeCategory > 0.85 ? 1.5 : 1.0))
                        },
                        phase: {
                            x: this.pseudoRandom(seed + 11111) * Math.PI * 2,
                            y: this.pseudoRandom(seed + 22222) * Math.PI * 2,
                            z: this.pseudoRandom(seed + 33333) * Math.PI * 2
                        },
                        speed: {
                            x: (this.pseudoRandom(seed + 44444) - 0.5) * 0.005 * speedFactor,
                            y: (this.pseudoRandom(seed + 55555) - 0.5) * 0.005 * speedFactor,
                            z: (this.pseudoRandom(seed + 66666) - 0.5) * 0.005 * speedFactor
                        }
                    }
                };
                
                // Añadir a la lista de nebulosas para animación
                this.nebulaeObjects.push(nebulaData);
            }
            
            // Animar todas las nebulosas (similar a la función original)
            animateNebulae() {
                const time = Date.now() * 0.001; // Tiempo en segundos para movimiento suave
                
                this.nebulaeObjects.forEach(nebulaData => {
                    const { object, rotationSpeed, movementPath } = nebulaData;
                    
                    // Aplicar rotación
                    object.rotation.x += rotationSpeed.x;
                    object.rotation.y += rotationSpeed.y;
                    object.rotation.z += rotationSpeed.z;
                    
                    // Movimiento en elipse alrededor del centro
                    object.position.x = movementPath.center.x + 
                        Math.sin(time * movementPath.speed.x + movementPath.phase.x) * movementPath.amplitude.x;
                    
                    object.position.y = movementPath.center.y + 
                        Math.cos(time * movementPath.speed.y + movementPath.phase.y) * movementPath.amplitude.y;
                    
                    object.position.z = movementPath.center.z + 
                        Math.sin(time * movementPath.speed.z + movementPath.phase.z) * movementPath.amplitude.z;
                });
            }
        }

        class HyperspaceEffect {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.active = false;
                this.speedFactor = 1.0; // Factor normal de velocidad
                this.maxSpeedFactor = 10.0; // Velocidad máxima (10x)
                this.acceleration = 0.2; // Tasa de aceleración
                this.deceleration = 0.4; // Tasa de desaceleración (más rápida que la aceleración)
                this.targetSpeedFactor = 1.0;
                
                // Efecto de estrellas de velocidad
                this.speedLinesCount = 300;
                this.speedLinesObject = null;
                this.speedLinesVisible = false;
                
                // Sonido de hipervelocidad (opcional)
                this.hyperspaceSound = null;
                this.soundInitialized = false;
                
                // Crear el efecto visual
                this.createSpeedLines();
                
                // Opcionalmente inicializar sonido
                this.initializeSound();
            }
            
            // Activar/desactivar el modo hipervelocidad
            toggleHyperspace(enabled) {
                this.active = enabled;
                this.targetSpeedFactor = enabled ? this.maxSpeedFactor : 1.0;
                
                // Si está activo, mostrar las líneas de velocidad
                if (enabled && !this.speedLinesVisible) {
                    this.showSpeedLines();
                }
                
                // Activar/desactivar sonido
                if (this.soundInitialized) {
                    if (enabled && !this.hyperspaceSound.isPlaying) {
                        this.hyperspaceSound.play();
                    }
                }
            }
            
            // Actualizar el efecto (llamar desde el loop de animación)
            update(playerDirection) {
                // Ajustar velocidad actual gradualmente
                if (this.active && this.speedFactor < this.targetSpeedFactor) {
                    this.speedFactor += this.acceleration;
                    if (this.speedFactor > this.targetSpeedFactor) {
                        this.speedFactor = this.targetSpeedFactor;
                    }
                } else if (!this.active && this.speedFactor > this.targetSpeedFactor) {
                    this.speedFactor -= this.deceleration;
                    if (this.speedFactor < this.targetSpeedFactor) {
                        this.speedFactor = this.targetSpeedFactor;
                    }
                }
                
                // Si ya desaceleró completamente, ocultar las líneas de velocidad
                if (!this.active && this.speedFactor <= 1.1 && this.speedLinesVisible) {
                    this.hideSpeedLines();
                }
                
                // Actualizar el efecto visual de líneas de velocidad
                if (this.speedLinesVisible) {
                    this.updateSpeedLines(playerDirection);
                }
                
                // Actualizar sonido si está activo
                if (this.soundInitialized && this.hyperspaceSound.isPlaying) {
                    // Ajustar volumen y pitch basado en velocidad
                    const speedRatio = (this.speedFactor - 1.0) / (this.maxSpeedFactor - 1.0);
                    this.hyperspaceSound.volume = Math.min(0.7, speedRatio * 0.7);
                    
                    // Si ya no está en hipervelocidad y el sonido casi desaparece, detenerlo
                    if (!this.active && speedRatio < 0.1) {
                        this.hyperspaceSound.stop();
                    }
                }
                
                // Devolver el factor de velocidad actual para que sea usado por el movimiento
                return this.speedFactor;
            }
            
            // Crear las líneas de velocidad (inicialmente ocultas)
            createSpeedLines() {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.speedLinesCount * 3);
                const colors = new Float32Array(this.speedLinesCount * 3);
                const sizes = new Float32Array(this.speedLinesCount);
                const speedParams = new Float32Array(this.speedLinesCount * 2); // Longitud y velocidad
                
                // Generar posiciones iniciales en forma de hemisferio delante del jugador
                for (let i = 0; i < this.speedLinesCount; i++) {
                    // Posición inicial aleatoria en un hemisferio
                    const theta = Math.random() * Math.PI * 2; // Ángulo horizontal
                    const phi = Math.random() * Math.PI / 2; // Ángulo vertical (solo hemisferio frontal)
                    const r = 5 + Math.random() * 95; // Radio entre 5 y 100
                    
                    // Coordenadas esféricas a cartesianas
                    positions[i * 3] = -r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = r * Math.cos(phi);
                    positions[i * 3 + 2] = -r * Math.sin(phi) * Math.sin(theta);
                    
                    // Color azulado con variación para efecto de velocidad
                    const blueIntensity = 0.5 + Math.random() * 0.5;
                    colors[i * 3] = 0.7; // R
                    colors[i * 3 + 1] = 0.8; // G
                    colors[i * 3 + 2] = blueIntensity; // B (azul más intenso)
                    
                    // Tamaño de la línea (variar para diversidad)
                    sizes[i] = 0.5 + Math.random() * 1.5;
                    
                    // Parámetros de velocidad y longitud
                    speedParams[i * 2] = 0.5 + Math.random() * 2.5; // Longitud de estela
                    speedParams[i * 2 + 1] = 0.5 + Math.random() * 1.5; // Velocidad relativa
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Crear textura para las líneas
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 16;
                const ctx = canvas.getContext('2d');
                
                // Dibujar línea con degradado
                const grd = ctx.createLinearGradient(0, 8, 64, 8);
                grd.addColorStop(0, "rgba(255, 255, 255, 1.0)");
                grd.addColorStop(1, "rgba(255, 255, 255, 0.0)");
                
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, 64, 16);
                
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                
                // Material para las líneas de velocidad
                const material = new THREE.PointsMaterial({
                    size: 2.0,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0,  // Inicialmente invisible
                    map: texture,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                // Crear el objeto y añadirlo a la escena (inicialmente invisible)
                this.speedLinesObject = new THREE.Points(geometry, material);
                this.speedLinesObject.frustumCulled = false; // Evitar que desaparezca fuera del frustum
                this.scene.add(this.speedLinesObject);
                
                // Guardar referencia a los atributos para animación
                this.speedLinesPositions = geometry.attributes.position;
                this.speedLinesColors = geometry.attributes.color;
                this.speedLinesSizes = geometry.attributes.size;
                this.speedParams = speedParams;
            }
            
            // Mostrar las líneas de velocidad con fade in
            showSpeedLines() {
                if (!this.speedLinesObject) return;
                this.speedLinesVisible = true;
                
                // Hacer aparecer gradualmente
                const material = this.speedLinesObject.material;
                const startOpacity = material.opacity;
                const targetOpacity = 0.7;
                const duration = 500; // ms
                const startTime = Date.now();
                
                const fadeIn = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1.0, elapsedTime / duration);
                    
                    material.opacity = startOpacity + (targetOpacity - startOpacity) * progress;
                    
                    if (progress < 1.0) {
                        requestAnimationFrame(fadeIn);
                    }
                };
                
                fadeIn();
            }
            
            // Ocultar las líneas de velocidad con fade out
            hideSpeedLines() {
                if (!this.speedLinesObject) return;
                
                // Hacer desaparecer gradualmente
                const material = this.speedLinesObject.material;
                const startOpacity = material.opacity;
                const targetOpacity = 0.0;
                const duration = 500; // ms
                const startTime = Date.now();
                
                const fadeOut = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1.0, elapsedTime / duration);
                    
                    material.opacity = startOpacity + (targetOpacity - startOpacity) * progress;
                    
                    if (progress < 1.0) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        this.speedLinesVisible = false;
                    }
                };
                
                fadeOut();
            }
            
            // Actualizar la posición y apariencia de las líneas de velocidad
            updateSpeedLines(playerDirection) {
                if (!this.speedLinesObject || !this.speedLinesVisible) return;
                
                // Obtener la dirección en la que está mirando el jugador
                const forward = playerDirection.clone().normalize();
                
                // Crear un sistema de coordenadas local
                const up = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3().crossVectors(forward, up).normalize();
                up.crossVectors(right, forward);
                
                // Efecto incremental con velocidad
                const speedEffect = this.speedFactor / this.maxSpeedFactor;
                const positions = this.speedLinesPositions.array;
                const sizes = this.speedLinesSizes.array;
                const colors = this.speedLinesColors.array;
                
                for (let i = 0; i < this.speedLinesCount; i++) {
                    // Obtener posición actual
                    const px = positions[i * 3];
                    const py = positions[i * 3 + 1];
                    const pz = positions[i * 3 + 2];
                    
                    // Mover hacia atrás (efecto de estela)
                    const speed = this.speedParams[i * 2 + 1] * this.speedFactor * 0.2;
                    positions[i * 3] -= forward.x * speed;
                    positions[i * 3 + 1] -= forward.y * speed;
                    positions[i * 3 + 2] -= forward.z * speed;
                    
                    // Si la línea se fue muy lejos, reiniciarla al frente
                    const distanceToCamera = Math.sqrt(
                        px * px + py * py + pz * pz
                    );
                    
                    if (distanceToCamera > 120) {
                        // Nueva posición en un círculo delante del jugador
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 5 + Math.random() * 15;
                        
                        positions[i * 3] = right.x * Math.cos(angle) * radius + 
                                        up.x * Math.sin(angle) * radius + 
                                        forward.x * (-10 - Math.random() * 20);
                                        
                        positions[i * 3 + 1] = right.y * Math.cos(angle) * radius + 
                                            up.y * Math.sin(angle) * radius + 
                                            forward.y * (-10 - Math.random() * 20);
                                            
                        positions[i * 3 + 2] = right.z * Math.cos(angle) * radius + 
                                            up.z * Math.sin(angle) * radius + 
                                            forward.z * (-10 - Math.random() * 20);
                    }
                    
                    // Ajustar tamaño basado en velocidad
                    sizes[i] = (0.5 + Math.random() * 0.5) * (1 + speedEffect * this.speedParams[i * 2] * 2);
                    
                    // Ajustar color (más azul a mayor velocidad)
                    colors[i * 3 + 2] = Math.min(1.0, 0.7 + speedEffect * 0.3);
                }
                
                // Marcar atributos para actualización
                this.speedLinesPositions.needsUpdate = true;
                this.speedLinesSizes.needsUpdate = true;
                this.speedLinesColors.needsUpdate = true;
                
                // Alinear con la cámara (estrategia de billboarding)
                this.speedLinesObject.quaternion.copy(this.camera.quaternion);
            }
            
            // Inicializar sonido (si Three.js Audio está disponible)
            initializeSound() {
                if (typeof THREE.Audio === 'undefined') return;
                
                try {
                    // Crear listener de audio y añadirlo a la cámara
                    const listener = new THREE.AudioListener();
                    this.camera.add(listener);
                    
                    // Crear fuente de sonido
                    this.hyperspaceSound = new THREE.Audio(listener);
                    
                    // Crear buffer de audio con ruido blanco filtrado
                    const context = listener.context;
                    const bufferSize = 2 * context.sampleRate;
                    const buffer = context.createBuffer(1, bufferSize, context.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Generar ruido con más bajas frecuencias (tipo "whoosh")
                    let lastOut = 0.0;
                    for (let i = 0; i < bufferSize; i++) {
                        // Ruido blanco filtrado para efecto de viento espacial
                        const white = Math.random() * 2 - 1;
                        // Filtro paso bajo simple
                        lastOut = (lastOut + (0.02 * white)) / 1.02;
                        data[i] = lastOut * 3.5; // Amplificación
                    }
                    
                    // Configurar el sonido
                    this.hyperspaceSound.setBuffer(buffer);
                    this.hyperspaceSound.setLoop(true);
                    this.hyperspaceSound.setVolume(0);
                    
                    this.soundInitialized = true;
                } catch (e) {
                    console.error("Error initializing hyperspace sound:", e);
                }
            }
            
            // Limpiar recursos al destruir
            dispose() {
                if (this.speedLinesObject) {
                    if (this.speedLinesObject.geometry) {
                        this.speedLinesObject.geometry.dispose();
                    }
                    if (this.speedLinesObject.material) {
                        if (this.speedLinesObject.material.map) {
                            this.speedLinesObject.material.map.dispose();
                        }
                        this.speedLinesObject.material.dispose();
                    }
                    this.scene.remove(this.speedLinesObject);
                }
                
                if (this.hyperspaceSound && this.hyperspaceSound.isPlaying) {
                    this.hyperspaceSound.stop();
                }
            }
        }

        class RadioNebula {
            constructor(scene, initialStaticPosition, analyser, initialConfig, type = 'mp3', isMajestic = false) {
                this.scene = scene;
                this.initialStaticPosition = initialStaticPosition.clone(); 
                this.analyser = analyser;
                this.config = initialConfig; 
                this.type = type; 
                this.isMajestic = isMajestic; 

                this.orbitCenter = this.initialStaticPosition.clone(); 
                this.orbitAmplitude = new THREE.Vector3(80 + Math.random() * 70, 20 + Math.random() * 30, 80 + Math.random() * 70);
                this.orbitPhase = new THREE.Vector3(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
// Aumentamos la velocidad base para que sea un poco más rápida que las nebulosas
                this.orbitSpeed = new THREE.Vector3(
                                    (Math.random() - 0.5) * 0.007, 
                                    (Math.random() - 0.5) * 0.004,
                                    (Math.random() - 0.5) * 0.007
                                );
                this.currentDynamicPosition = this.initialStaticPosition.clone(); 

                this.baseColorPalette = (type === 'tagua_tagua') ? TAGUA_TAGUA_BASE_COLORS_HSL : MAJESTIC_NEBULA_COLORS_HSL; 
                this.coreColorPalette = (type === 'tagua_tagua') ? TAGUA_TAGUA_CORE_COLORS_HSL : CORE_PULSATING_COLORS_HSL; 

                this.bufferLength = this.analyser.frequencyBinCount;
                this.particleCount = 12000; 
                if (this.isMajestic) this.particleCount = 15000; 

                this.particlesObject = new THREE.Object3D();
                this.particlesObject.position.copy(this.currentDynamicPosition); 
                this.scene.add(this.particlesObject);
                this.geometry = new THREE.BufferGeometry();
                
                this.currentBaseColorIndex = Math.floor(Math.random() * this.baseColorPalette.length);
                this.targetBaseColorIndex = this.currentBaseColorIndex;
                this.colorTransitionProgress = 1;
                
                this.currentCoreColorIndex = Math.floor(Math.random() * this.coreColorPalette.length);
                this.targetCoreColorIndex = this.currentCoreColorIndex;
                this.coreColorTransitionProgress = 1;
                this.currentCoronaColorIndex = 0; 

                const particleTexture = this.createParticleTexture(); 
                this.material = new THREE.PointsMaterial({
                    map: particleTexture,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9, 
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    sizeAttenuation: true, 
                    size: 1.0, 
                    alphaTest: 0.05 
                });
                this.maxExpansionRadius = this.config.baseSize;
                this.coreRadius = this.config.baseSize * 0.15;
                this.coronaRadius = this.isMajestic ? this.config.baseSize * 0.35 : 0; 
                this.coronaParticleRatio = this.isMajestic ? 0.15 : 0; 

                this.baseRotationSpeed = new THREE.Vector3(0.0007, 0.0012, 0.0005);
                this.particleAttributes = {
                    positions: new Float32Array(this.particleCount * 3), colors: new Float32Array(this.particleCount * 3),
                    targetColors: new Float32Array(this.particleCount * 3), alphas: new Float32Array(this.particleCount),
                    sizes: new Float32Array(this.particleCount), velocities: new Float32Array(this.particleCount * 3),
                    lifetimes: new Float32Array(this.particleCount), initialDistances: new Float32Array(this.particleCount),
                    isCoreParticle: new Uint8Array(this.particleCount), 
                    isTracerParticle: new Uint8Array(this.particleCount),
                    isCoronaParticle: this.isMajestic ? new Uint8Array(this.particleCount) : null 
                };
                 // AÑADIR ESTAS NUEVAS PROPIEDADES AL CONSTRUCTOR DE RadioNebula
                // ----------------------------------------------------
                this.userDragOffset = new THREE.Vector3(0, 0, 0); // Desplazamiento temporal por arrastre
                this.momentumVelocity = new THREE.Vector3(0, 0, 0); // Velocidad para el efecto de inercia
                this.isBeingDragged = false; // Bandera para saber si está siendo arrastrado
                // ----------------------------------------------------

                this._initParticles();

                this.points = new THREE.Points(this.geometry, this.material);
                this.particlesObject.add(this.points);
                this.lastUpdateTime = Date.now();
                this.lastColorChangeTime = Date.now();
                this.lastCoreColorChangeTime = Date.now();
                const heartGeometry = new THREE.SphereGeometry(this.coreRadius * 0.25, 12, 8);
                const heartMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff, emissive: 0x555555, transparent: true, opacity: 0.15,
                    blending: THREE.AdditiveBlending, shininess: 50, specular: 0xaaaaaa
                });
                this.nebulaHeart = new THREE.Mesh(heartGeometry, heartMaterial);
                this.particlesObject.add(this.nebulaHeart);
                 // --- PEGA EL BLOQUE QUE CORTASTE JUSTO AQUÍ ---
                const clickTargetGeometry = new THREE.SphereGeometry(this.maxExpansionRadius * 0.6, 16, 16);
                const clickTargetMaterial = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide }); // Invisible
                this.nebulaClickTarget = new THREE.Mesh(clickTargetGeometry, clickTargetMaterial);
                this.nebulaClickTarget.parentNebula = this; // Creamos una referencia para saber a quién pertenece
                this.nebulaClickTarget.layers.set(CLICKABLE_LAYER); // <-- AÑADE ESTA LÍNEA

                this.particlesObject.add(this.nebulaClickTarget);
                // --- HASTA AQUÍ ---
            }

            updateOrbitalPosition(time) {
                // 1. Calculamos la posición orbital base (como antes)
                const baseOrbitX = this.orbitCenter.x + Math.sin(time * this.orbitSpeed.x + this.orbitPhase.x) * this.orbitAmplitude.x;
                const baseOrbitY = this.orbitCenter.y + Math.cos(time * this.orbitSpeed.y + this.orbitPhase.y) * this.orbitAmplitude.y;
                const baseOrbitZ = this.orbitCenter.z + Math.sin(time * this.orbitSpeed.z + this.orbitPhase.z) * this.orbitAmplitude.z;

                // 2. Aplicamos la física de momentum y retorno (¡la nueva magia!)
                //    Esto solo se ejecuta si NO estamos arrastrando el púlsar.
                if (!this.isBeingDragged) {
                    // Aplicamos la velocidad del momentum que guardamos al arrastrar
                    this.userDragOffset.add(this.momentumVelocity);
                    // Frenamos el momentum un 5% en cada fotograma (amortiguación)
                    this.momentumVelocity.multiplyScalar(0.95);
                    // Atraemos el púlsar de vuelta a su órbita original (efecto goma elástica)
                    this.userDragOffset.lerp(new THREE.Vector3(0, 0, 0), 0.02);
                }

                // 3. La posición final es la órbita base + nuestro desplazamiento temporal
                this.currentDynamicPosition.set(
                    baseOrbitX + this.userDragOffset.x,
                    baseOrbitY + this.userDragOffset.y,
                    baseOrbitZ + this.userDragOffset.z
                );

                // 4. Actualizamos la posición del objeto en la escena
                this.particlesObject.position.copy(this.currentDynamicPosition);
            }




            applyConfigChange() {
                this.maxExpansionRadius = this.config.baseSize;
                this.coreRadius = this.config.baseSize * 0.15;
                if (this.nebulaHeart) {
                    this.nebulaHeart.geometry.dispose();
                    this.nebulaHeart.geometry = new THREE.SphereGeometry(this.coreRadius * 0.25, 12, 8);
                }
                if (this.isMajestic) {
                    this.coronaRadius = this.config.baseSize * 0.35;
                }
            }

            createParticleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 128; 
                canvas.height = 128;
                const context = canvas.getContext('2d');
                context.fillStyle = 'rgba(0,0,0,0)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = canvas.width / 2 - 2;
                const gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.7, 'rgba(255,255,255,0.9)');
                gradient.addColorStop(0.9, 'rgba(255,255,255,0.3)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                context.beginPath();
                context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
                context.fillStyle = gradient;
                context.fill();
                const innerGradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 0.5 );
                innerGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
                innerGradient.addColorStop(1, 'rgba(255,255,255,0)');
                context.beginPath();
                context.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2, false);
                context.fillStyle = innerGradient;
                context.fill();
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true; 
                return texture;
            }


            _initParticles() {
                const { positions, colors, targetColors, alphas, sizes, velocities, lifetimes, initialDistances, isCoreParticle, isTracerParticle, isCoronaParticle } = this.particleAttributes;
                for (let i = 0; i < this.particleCount; i++) { this._spawnParticle(i); }
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            }

            _spawnParticle(i, forceCore = false) {
                const { positions, colors, targetColors, alphas, sizes, velocities, lifetimes, initialDistances, isCoreParticle, isTracerParticle, isCoronaParticle } = this.particleAttributes;
                const i3 = i * 3; let r;
                
                isCoreParticle[i] = 0;
                isTracerParticle[i] = 0;
                if (this.isMajestic && isCoronaParticle) isCoronaParticle[i] = 0;

                if (this.isMajestic && Math.random() < this.coronaParticleRatio) {
                    if(isCoronaParticle) isCoronaParticle[i] = 1;
                    r = this.coreRadius * 0.8 + Math.random() * (this.coronaRadius - this.coreRadius * 0.8); 
                } else if (forceCore || Math.random() < (0.10 + Math.random() * 0.08)) {
                    isCoreParticle[i] = 1;
                    r = Math.pow(Math.random(), 3.0) * this.coreRadius;
                } else {
                    const peripheryFactor = 0.80;
                    r = this.coreRadius + Math.pow(Math.random(), 1.4) * (this.maxExpansionRadius * peripheryFactor - this.coreRadius);
                    if (!isCoreParticle[i] && (!this.isMajestic || (isCoronaParticle && !isCoronaParticle[i])) && Math.random() < 0.008) { 
                        isTracerParticle[i] = 1;
                    }
                }
                
                initialDistances[i] = r;
                const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                positions[i3] = r * Math.sin(phi) * Math.cos(theta); positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta); positions[i3 + 2] = r * Math.cos(phi);
                
                let chosenColorHSL; let finalColor = new THREE.Color();

                if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                    chosenColorHSL = MAJESTIC_CORONA_COLORS_HSL[this.currentCoronaColorIndex % MAJESTIC_CORONA_COLORS_HSL.length];
                    finalColor.setHSL(chosenColorHSL.h, chosenColorHSL.s, chosenColorHSL.l * (0.8 + Math.random() * 0.4)); 
                    alphas[i] = 0.3 + Math.random() * 0.4; 
                    sizes[i] = 2.5 + Math.random() * 3.0; 
                } else if (isTracerParticle[i]) {
                    const tracerBaseColor = this.baseColorPalette[this.currentBaseColorIndex % this.baseColorPalette.length];
                    chosenColorHSL = { h: (tracerBaseColor.h + 0.4) % 1, s: 0.08, l: 0.95 }; 
                    finalColor.setHSL(chosenColorHSL.h, chosenColorHSL.s, chosenColorHSL.l + (Math.random()-0.5)*0.015); alphas[i] = 0.01 + Math.random() * 0.20;
                    sizes[i] = 3.0 + Math.random() * 2.5;
                } else if (isCoreParticle[i]) {
                    chosenColorHSL = this.coreColorPalette[this.currentCoreColorIndex % this.coreColorPalette.length];
                    const coreLuminosity = chosenColorHSL.l + (Math.random() - 0.5) * 0.005;
                    finalColor.setHSL(chosenColorHSL.h, chosenColorHSL.s, coreLuminosity); alphas[i] = 0.5 + Math.random() * 0.3;
                    sizes[i] = 0.7 + Math.random() * 2.0;
                } else { 
                    chosenColorHSL = this.baseColorPalette[this.currentBaseColorIndex % this.baseColorPalette.length];
                    finalColor.setHSL(chosenColorHSL.h, chosenColorHSL.s, chosenColorHSL.l + (Math.random()-0.5)*0.015); alphas[i] = 0.01 + Math.random() * 0.20;
                    sizes[i] = 0.7 + Math.random() * 2.0;
                }
                colors[i3] = finalColor.r; colors[i3 + 1] = finalColor.g; colors[i3 + 2] = finalColor.b;
                targetColors[i3] = finalColor.r; targetColors[i3+1] = finalColor.g; targetColors[i3+2] = finalColor.b;
                
                const speedFactor = (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) ? (0.005 + Math.random() * 0.02) : (0.015 + Math.random() * 0.08); 
                 if (r > 0.01) { velocities[i3] = positions[i3] / r * speedFactor * 0.015; velocities[i3 + 1] = positions[i3 + 1] / r * speedFactor * 0.015; velocities[i3 + 2] = positions[i3 + 2] / r * speedFactor * 0.015;} 
                 else { velocities[i3] = (Math.random() - 0.5) * 0.0015; velocities[i3+1] = (Math.random() - 0.5) * 0.0015; velocities[i3+2] = (Math.random() - 0.5) * 0.0015;}
                velocities[i3] += (Math.random() - 0.5) * 0.01; velocities[i3 + 1] += (Math.random() - 0.5) * 0.01; velocities[i3 + 2] += (Math.random() - 0.5) * 0.01;
                lifetimes[i] = (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) ? (15 + Math.random() * 10) : (7 + Math.random() * 15); 
            }

            update(currentFrequencyData, currentTimeDomainData, deltaTime) { 
                 if (!this.analyser || !this.points) return;
                const now = Date.now();
                this.analyser.getByteFrequencyData(currentFrequencyData);
                this.analyser.getByteTimeDomainData(currentTimeDomainData);

                let sumAmplitudes = 0;
                for (let i = 0; i < currentTimeDomainData.length; i++) { sumAmplitudes += Math.abs(currentTimeDomainData[i] - 128); }
                const averageVolume = Math.min(1, (sumAmplitudes / currentTimeDomainData.length) / 40);
                
                const bass = (currentFrequencyData[Math.floor(this.bufferLength * 0.005)] + currentFrequencyData[Math.floor(this.bufferLength * 0.025)]) / 2 / 255;
                const mids = (currentFrequencyData[Math.floor(this.bufferLength * 0.12)] + currentFrequencyData[Math.floor(this.bufferLength * 0.22)]) / 2 / 255;
                const highs = (currentFrequencyData[Math.floor(this.bufferLength * 0.35)]+ currentFrequencyData[Math.floor(this.bufferLength * 0.50)]) / 2 / 255;

                const effectiveRotationSpeed = this.config.rotationSpeedFactor / 0.0012;
                this.particlesObject.rotation.x += this.baseRotationSpeed.x * effectiveRotationSpeed * deltaTime * (0.08 + averageVolume * 0.25);
                this.particlesObject.rotation.y += this.baseRotationSpeed.y * effectiveRotationSpeed * deltaTime * (0.08 + averageVolume * 0.5);
                this.particlesObject.rotation.z += this.baseRotationSpeed.z * effectiveRotationSpeed * deltaTime * (0.08 + averageVolume * 0.25);
                const pulseCycle = now * 0.001 * (0.5 + this.config.pulseSpeedFactor * 50);
                const easedVolume = (Math.sin(pulseCycle - Math.PI / 2) + 1) / 2 * averageVolume;
                const targetExpansionFactor = 0.20 + easedVolume * this.config.pulseIntensity;
                this.currentExpansionFactor = this.currentExpansionFactor === undefined ? 1 : this.currentExpansionFactor;
                this.currentExpansionFactor = THREE.MathUtils.lerp(this.currentExpansionFactor, targetExpansionFactor, this.config.pulseSpeedFactor);
                
                const coreTargetColor = this.coreColorPalette[this.currentCoreColorIndex % this.coreColorPalette.length]; 
                const heartLuminosity = Math.min(0.80, coreTargetColor.l * (0.3 + averageVolume * 0.7) + bass * this.config.coreBrightness);
                this.nebulaHeart.material.color.setHSL(coreTargetColor.h, coreTargetColor.s * 0.75, heartLuminosity);
                this.nebulaHeart.material.emissive.setHSL(coreTargetColor.h, coreTargetColor.s * 0.75, heartLuminosity * 0.4);
                this.nebulaHeart.material.opacity = THREE.MathUtils.lerp(this.nebulaHeart.material.opacity, 0.02 + bass * 0.20 + averageVolume * 0.10, 0.035);
                const heartScale = 0.6 + averageVolume * 1.0 + bass * 0.7;
                this.nebulaHeart.scale.set(heartScale, heartScale, heartScale);

                const colorChangeInterval = 11000 + Math.random()*2500;
                if (now - this.lastColorChangeTime > colorChangeInterval) {
                    this.targetBaseColorIndex = (this.currentBaseColorIndex + 1 + Math.floor(Math.random()*(this.baseColorPalette.length-1))) % this.baseColorPalette.length;
                    if (this.targetBaseColorIndex === this.currentBaseColorIndex && this.baseColorPalette.length > 1) { this.targetBaseColorIndex = (this.targetBaseColorIndex + 1) % this.baseColorPalette.length;}
                    this.colorTransitionProgress = 0; this.lastColorChangeTime = now;
                }
                if (this.colorTransitionProgress < 1) { this.colorTransitionProgress = Math.min(1, this.colorTransitionProgress + deltaTime * this.config.outerColorSpeed); } else { this.currentBaseColorIndex = this.targetBaseColorIndex; }
                
                const coreColorChangeInterval = 2500 + Math.random() * 800;
                if (now - this.lastCoreColorChangeTime > coreColorChangeInterval) {
                    this.targetCoreColorIndex = (this.currentCoreColorIndex + 1) % this.coreColorPalette.length;
                    this.coreColorTransitionProgress = 0; this.lastCoreColorChangeTime = now;
                }
                 if (this.coreColorTransitionProgress < 1) { this.coreColorTransitionProgress = Math.min(1, this.coreColorTransitionProgress + deltaTime * this.config.coreColorSpeed); } else { this.currentCoreColorIndex = this.targetCoreColorIndex; }

                if (this.isMajestic) { 
                    const coronaColorChangeInterval = 7000 + Math.random() * 2000; 
                    if (now - (this.lastCoronaColorChangeTime || 0) > coronaColorChangeInterval) {
                        this.currentCoronaColorIndex = (this.currentCoronaColorIndex + 1) % MAJESTIC_CORONA_COLORS_HSL.length;
                        this.lastCoronaColorChangeTime = now;
                    }
                }

                const { positions, colors, alphas, sizes, velocities, lifetimes, initialDistances, isCoreParticle, isTracerParticle, isCoronaParticle } = this.particleAttributes;
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3; lifetimes[i] -= deltaTime;
                    if (lifetimes[i] <= 0) { 
                        let forceCoreOnRespawn = false; if (averageVolume > 0.05) { forceCoreOnRespawn = Math.random() < (averageVolume * 0.45); } 
                        this._spawnParticle(i, forceCoreOnRespawn); continue; 
                    }
                    
                    velocities[i3] = THREE.MathUtils.lerp(velocities[i3], (Math.random() - 0.5) * 0.006 * (1 + bass*2.5), 0.035);
                    velocities[i3+1] = THREE.MathUtils.lerp(velocities[i3+1], (Math.random() - 0.5) * 0.006 * (1 + bass*2.5), 0.035);
                    velocities[i3+2] = THREE.MathUtils.lerp(velocities[i3+2], (Math.random() - 0.5) * 0.006 * (1 + bass*2.5), 0.035);
                    
                    positions[i3] += velocities[i3] * deltaTime * (1 + averageVolume * 28); 
                    positions[i3 + 1] += velocities[i3 + 1] * deltaTime * (1 + averageVolume * 28); 
                    positions[i3 + 2] += velocities[i3 + 2] * deltaTime * (1 + averageVolume * 28);
                    
                     const currentDist = Math.sqrt(positions[i3]**2 + positions[i3+1]**2 + positions[i3+2]**2);
                    let expansionLimitFactor = 1.0;
                    if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                        expansionLimitFactor = 1.1; 
                    } else if (isCoreParticle[i]) {
                        expansionLimitFactor = 1.0;
                    } else if (isTracerParticle[i]) {
                        expansionLimitFactor = 0.95;
                    } else { 
                        expansionLimitFactor = 0.88;
                    }

                    if (currentDist > 0.01) { 
                        const desiredDist = initialDistances[i] * this.currentExpansionFactor * expansionLimitFactor; 
                        const scaleToApply = THREE.MathUtils.lerp(1, desiredDist / currentDist, 0.018); 
                        positions[i3] *= scaleToApply; positions[i3+1] *= scaleToApply; positions[i3+2] *= scaleToApply;
                    }
                    
                    let sourceColorHSL, targetColorHSL, transitionProg; 
                    let currentParticleColor = new THREE.Color(colors[i3], colors[i3+1], colors[i3+2]); 
                    let finalTargetColor = new THREE.Color();

                    if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                        const coronaBaseColor = MAJESTIC_CORONA_COLORS_HSL[this.currentCoronaColorIndex % MAJESTIC_CORONA_COLORS_HSL.length];
                        finalTargetColor.setHSL(
                            coronaBaseColor.h,
                            coronaBaseColor.s,
                            coronaBaseColor.l * (0.7 + averageVolume * 0.5 + highs * 0.3) 
                        );
                    } else if(isTracerParticle[i]) { 
                        const tracerBaseColor = this.baseColorPalette[this.currentBaseColorIndex % this.baseColorPalette.length];
                        const tracerActualHSL = {h: (tracerBaseColor.h + 0.4 + i*0.0001) % 1, s:0.02 + Math.random()*0.05, l:0.80 + Math.random()*0.1}; 
                        finalTargetColor.setHSL(tracerActualHSL.h, tracerActualHSL.s, tracerActualHSL.l);
                    } else if(isCoreParticle[i]) {
                        sourceColorHSL = this.coreColorPalette[this.currentCoreColorIndex % this.coreColorPalette.length]; 
                        targetColorHSL = this.coreColorPalette[this.targetCoreColorIndex % this.coreColorPalette.length]; 
                        transitionProg = this.coreColorTransitionProgress;
                        const h = THREE.MathUtils.lerp(sourceColorHSL.h, targetColorHSL.h, transitionProg); 
                        const s = THREE.MathUtils.lerp(sourceColorHSL.s, targetColorHSL.s, transitionProg);
                        let l = THREE.MathUtils.lerp(sourceColorHSL.l, targetColorHSL.l, transitionProg); 
                        l = Math.min(0.85 * this.config.coreBrightness, l + averageVolume * this.config.colorIntensityAudio + bass * (this.config.colorIntensityAudio * 0.8)); 
                        finalTargetColor.setHSL(h,s,l);
                    } else { 
                        sourceColorHSL = this.baseColorPalette[this.currentBaseColorIndex % this.baseColorPalette.length]; 
                        targetColorHSL = this.baseColorPalette[this.targetBaseColorIndex % this.baseColorPalette.length]; 
                        transitionProg = this.colorTransitionProgress;
                        const h = THREE.MathUtils.lerp(sourceColorHSL.h, targetColorHSL.h, transitionProg); 
                        const s = THREE.MathUtils.lerp(sourceColorHSL.s, targetColorHSL.s, transitionProg);
                        let l = THREE.MathUtils.lerp(sourceColorHSL.l, targetColorHSL.l, transitionProg); 
                        l = Math.min(0.70, l + averageVolume * (this.config.colorIntensityAudio * 0.8) + mids * (this.config.colorIntensityAudio*0.5));
                        
                        const coreColorForInfluence = this.coreColorPalette[this.currentCoreColorIndex % this.coreColorPalette.length];
                        const coreColorNow = new THREE.Color().setHSL(
                            coreColorForInfluence.h, 
                            coreColorForInfluence.s * 0.7, 
                            Math.min(0.80 * this.config.coreBrightness, coreColorForInfluence.l + averageVolume * (this.config.colorIntensityAudio*0.4))
                        );
                        const coreInfluence = Math.max(0, 1 - (initialDistances[i] / (this.coreRadius * 4.5))) * (0.08 + bass * 0.18) ; 
                        finalTargetColor.setHSL(h,s,l).lerp(coreColorNow, coreInfluence);
                    }
                    colors[i3] = THREE.MathUtils.lerp(currentParticleColor.r, finalTargetColor.r, 0.028); 
                    colors[i3 + 1] = THREE.MathUtils.lerp(currentParticleColor.g, finalTargetColor.g, 0.028); 
                    colors[i3 + 2] = THREE.MathUtils.lerp(currentParticleColor.b, finalTargetColor.b, 0.028);
                    
                    let targetSize;
                    if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                        targetSize = (3.0 + averageVolume * 4.0 + highs * 3.0) * (0.5 + Math.random() * 0.5); 
                        targetSize = Math.max(1.0, Math.min(targetSize, 15.0));
                    } else {
                        targetSize = (isTracerParticle[i] ? 4.0 : 2.2) + averageVolume * 6.5 + bass * 5.5 + highs * 4.0; 
                        targetSize *= (0.25 + Math.random() * 0.45);
                        let maxParticleSizeGeneral = isTracerParticle[i] ? 9.0 : 16.0; if (isCoreParticle[i]) { maxParticleSizeGeneral = 12.0; } 
                        targetSize = Math.max(0.08, Math.min(targetSize, maxParticleSizeGeneral));
                    }
                    sizes[i] = THREE.MathUtils.lerp(sizes[i], targetSize, 0.018);
                    
                    const lifeRatio = Math.max(0, lifetimes[i] / ( (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) ? (15 + Math.random() * 10) : (7 + Math.random() * 15) ) ); 
                    let targetAlpha;
                    if (this.isMajestic && isCoronaParticle && isCoronaParticle[i]) {
                        targetAlpha = (0.35 + averageVolume * 0.5 + highs * 0.25) * Math.sin(lifeRatio * Math.PI * 0.8 + 0.1); 
                    } else if (isCoreParticle[i]) { 
                        targetAlpha = (0.4 + averageVolume * 0.6) * (0.65 + bass * 0.35); 
                    } else if (isTracerParticle[i]) { 
                        targetAlpha = Math.sin(lifeRatio * Math.PI) * (0.25 + highs * 0.7); 
                    } else { 
                        targetAlpha = (0.015 + averageVolume * 0.985) * Math.sin(lifeRatio * Math.PI); 
                    }
                    targetAlpha = Math.min(1.0, Math.max(0.0005, targetAlpha)); alphas[i] = THREE.MathUtils.lerp(alphas[i], targetAlpha, 0.028);
                }
                this.geometry.attributes.position.needsUpdate = true; this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true; this.geometry.attributes.alpha.needsUpdate = true;
            }

            dispose() {
                 if (this.particlesObject) {
                    if (this.nebulaHeart) this.particlesObject.remove(this.nebulaHeart);
                    this.scene.remove(this.particlesObject);
                    if (this.points) {
                        if (this.points.geometry) this.points.geometry.dispose();
                        if (this.points.material) { 
                           if (this.points.material.map) this.points.material.map.dispose();
                           this.points.material.dispose();
                        }
                    }
                    if (this.nebulaHeart) { 
                        if (this.nebulaHeart.geometry) this.nebulaHeart.geometry.dispose();
                        if (this.nebulaHeart.material) this.nebulaHeart.material.dispose();
                    }
                    this.particlesObject = null; this.points = null; this.nebulaHeart = null;
                }
            }
            // DENTRO DEL CONSTRUCTOR de RadioNebula, al final
           
        // Esta es la llave de cierre del constructor
        }

        // --- LÓGICA DE LA PLAYLIST ---

        // REEMPLAZA TODAS TUS FUNCIONES DE PLAYLIST CON ESTE BLOQUE
        // --- LÓGICA DE LA PLAYLIST (Versión Unificada y Corregida) ---

        function initPlaylist() {
            playlistAudio.addEventListener('ended', playNextTrack);
            
            const volumeSlider2D = document.getElementById('playlist-volume');
            if (volumeSlider2D) {
                volumeSlider2D.addEventListener('input', (e) => {
                    userPlaylistVolume = parseFloat(e.target.value);
                    playlistAudio.volume = userPlaylistVolume;
                });
            }
            
            const volumeSlider3D = document.getElementById('pulsarVolume');
            const volumeValue3D = document.getElementById('pulsarVolumeValue');
            if (volumeSlider3D) {
                volumeSlider3D.addEventListener('input', (e) => {
                    pulsarVolumeMultiplier = parseFloat(e.target.value);
                    volumeValue3D.textContent = pulsarVolumeMultiplier.toFixed(1);
                    
                    // Actualiza el volumen de todos los púlsares activos en tiempo real
                    for (const pulsarId in gestorDePulsares.activos) {
                        const pulsar = gestorDePulsares.activos[pulsarId];
                        if (pulsar && pulsar.preAmpGain) {
                            pulsar.preAmpGain.gain.setValueAtTime(pulsarVolumeMultiplier, audioListener.context.currentTime);
                        }
                    }
                });
            }

            document.getElementById('btn-repeat').addEventListener('click', toggleRepeat);
            document.getElementById('btn-shuffle').addEventListener('click', toggleShuffle);
            document.getElementById('tagua-radio-item').addEventListener('click', () => togglePlay('radio'));
        }

        // Esta es la única versión de la función que necesitas
        function addTrackToPlaylist(name, url) {
            const trackId = url; // Usamos la URL como ID único para evitar duplicados
            if (playlist.some(track => track.id === trackId)) return;

            playlist.push({ id: trackId, name, url });
            renderPlaylist();
        }

        function renderPlaylist() {
            const listElement = document.getElementById('playlist-list');
            const radioItem = document.getElementById('tagua-radio-item');

            // Actualiza el estado visual del item de la Radio
            const isRadioActive = (currentTrackId === 'radio' && !playlistAudio.paused);
            radioItem.classList.toggle('active', isRadioActive);
            radioItem.querySelector('.play-indicator').innerHTML = isRadioActive ? '❚❚' : '▶';

            // Renderiza la lista de púlsares descubiertos
            listElement.innerHTML = '';
            if (playlist.length === 0) {
                 listElement.innerHTML = `<li class="playlist-item-empty">Aún no has descubierto púlsares.</li>`;
                 return;
            }

            playlist.forEach(track => {
                const item = document.createElement('li');
                item.className = 'playlist-item';
                
                const isActive = (currentTrackId === track.id && !playlistAudio.paused);
                item.classList.toggle('active', isActive);
                
                const playIndicator = isActive ? '❚❚' : '▶';
                item.innerHTML = `<span class="play-indicator">${playIndicator}</span> ${track.name}`;
                
                item.addEventListener('click', () => togglePlay(track.id));
                listElement.appendChild(item);
            });
        }

        function togglePlay(trackId) {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            if (trackId === currentTrackId) {
                if (playlistAudio.paused) {
                    playlistAudio.play();
                } else {
                    playlistAudio.pause();
                }
                renderPlaylist();
                return;
            }

            currentTrackId = trackId;
            let trackToPlay;

            if (trackId === 'radio') {
                trackToPlay = { name: "Radio Tagua Tagua (Stream)", url: TAGUA_TAGUA_STREAM_URL, isStream: true };
            } else {
                trackToPlay = playlist.find(t => t.id === trackId);
            }

            if (!trackToPlay) return;

            playlistAudio.src = trackToPlay.url;
            playlistAudio.loop = !trackToPlay.isStream && isRepeatOn && !isShuffleOn;
            playlistAudio.volume = userPlaylistVolume;
            playlistAudio.play().catch(e => console.error("Error al reproducir:", e));

            document.getElementById('current-track-name').textContent = trackToPlay.name;
            renderPlaylist();
        }

        function playNextTrack() {
            if (currentTrackId === 'radio' || playlist.length === 0) return;

            const currentIndex = playlist.findIndex(t => t.id === currentTrackId);
            if (currentIndex === -1) return;

            let nextIndex;
            if (isShuffleOn) {
                do {
                    nextIndex = Math.floor(Math.random() * playlist.length);
                } while (playlist.length > 1 && nextIndex === currentIndex);
            } else {
                if (currentIndex === playlist.length - 1 && !isRepeatOn) {
                    stopPlaylist();
                    return;
                }
                nextIndex = (currentIndex + 1) % playlist.length;
            }

            const nextTrack = playlist[nextIndex];
            if (nextTrack) {
                togglePlay(nextTrack.id);
            }
        }

        function stopPlaylist() {
            playlistAudio.pause();
            playlistAudio.src = "";
            currentTrackId = null;
            document.getElementById('current-track-name').textContent = "Silencio...";
            renderPlaylist();
        }

        function toggleRepeat() {
            isRepeatOn = !isRepeatOn;
            const btn = document.getElementById('btn-repeat');
            btn.classList.toggle('active', isRepeatOn);

            if (isRepeatOn && isShuffleOn) {
                isShuffleOn = false;
                document.getElementById('btn-shuffle').classList.remove('active');
            }
            if (currentTrackId !== 'radio' && !playlistAudio.paused) {
                playlistAudio.loop = isRepeatOn;
            }
        }

        function toggleShuffle() {
            isShuffleOn = !isShuffleOn;
            const btn = document.getElementById('btn-shuffle');
            btn.classList.toggle('active', isShuffleOn);

            if (isShuffleOn && isRepeatOn) {
                isRepeatOn = false;
                document.getElementById('btn-repeat').classList.remove('active');
                playlistAudio.loop = false;
            }
        }

        function handlePlaylistFade() {
            if (playlistAudio.paused || !currentTrackId) return;

            let nearestDistance = Infinity;
            if (gestorDePulsares.pulsarAudible && gestorDePulsares.pulsarAudible.id !== "tagua_tagua_matriz") {
                // Asegúrate que la posición dinámica del púlsar se usa aquí
                nearestDistance = avatarObject.position.distanceTo(gestorDePulsares.pulsarAudible.nebula.particlesObject.position);
            }
            
            let fadeMultiplier = 1.0;
            if (nearestDistance < FADE_START_DISTANCE) {
                fadeMultiplier = (nearestDistance - FADE_END_DISTANCE) / (FADE_START_DISTANCE - FADE_END_DISTANCE);
                fadeMultiplier = Math.max(0, Math.min(1, fadeMultiplier));
            }
            
            playlistAudio.volume = userPlaylistVolume * fadeMultiplier;
        }

        // La función initAudioControls ya no es necesaria, su lógica está integrada arriba.

        function createSharperCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;  // Mayor resolución para más nitidez
            canvas.height = 128;
            
            const context = canvas.getContext('2d');
            
            // Fondo transparente
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 2;
            
            // Degradado radial con borde más definido
            const gradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.7, 'rgba(255,255,255,0.9)'); // Mayor opacidad hasta más lejos
            gradient.addColorStop(0.9, 'rgba(255,255,255,0.3)'); // Caída más rápida al final
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            // Dibujar círculo con degradado
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
            context.fillStyle = gradient;
            context.fill();
            
            // Añadir un resplandor central para más brillo
            const innerGradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius * 0.5
            );
            innerGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
            innerGradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.beginPath();
            context.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2, false);
            context.fillStyle = innerGradient;
            context.fill();
            
            // Crear textura
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

        // Añade esta función al inicio del archivo (después de las variables principales)
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            
            const context = canvas.getContext('2d');
            
            // Fondo transparente
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar círculo con degradado radial para bordes suaves
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 2;  // -2 para dejar un poco de margen
            
            // Crear degradado radial
            const gradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.8, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            // Dibujar círculo con el degradado
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
            context.fillStyle = gradient;
            context.fill();
            
            // Crear textura
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
            
        // Función para crear una textura circular con bordes más nítidos
        function createSharperCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            
            const context = canvas.getContext('2d');
            
            // Fondo transparente
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 2;
            
            // Degradado radial con borde más definido
            const gradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.7, 'rgba(255,255,255,0.9)');
            gradient.addColorStop(0.9, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
            context.fillStyle = gradient;
            context.fill();
            
            // Añadir un resplandor central para más brillo
            const innerGradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius * 0.5
            );
            innerGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
            innerGradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.beginPath();
            context.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2, false);
            context.fillStyle = innerGradient;
            context.fill();
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

        // --- Variables para controles táctiles ---


        let touchControlsContainer, joystickContainer, joystickKnob, buttonUp, buttonDown;

        // Para control de cámara táctil (arrastre)
        let touchCameraInitialPos = { x: 0, y: 0 };
        let touchIdentifierCamera = null; // Identificador del dedo que controla la cámara
        let touchIdentifierJoystick = null; // Identificador del dedo que controla el joystick

        // Para "pinch-to-zoom"
        let initialPinchDistance = null;
        let touchIdentifierPinch1 = null;
        let touchIdentifierPinch2 = null;
        const pinchZoomSensitivity = 0.05; // Ajusta la sensibilidad del zoom


        // Objetos para la cámara
        let avatarObject;
        let cameraTarget = new THREE.Vector3();
        let cameraOffset = new THREE.Vector3(0, 10, 20);
        let currentViewMode = 'thirdPerson';
        
        // Variables de control del mouse
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let mouseSensitivity = 0.003;
        
        let socket = null; // Variable para nuestra conexión WebSocket
        // Variables MIDI
        let midiAccess = null;
        let activeInputs = new Set();
        let midiStatusElement = document.getElementById('midiStatus');
        let coordsElement = document.getElementById('coordinates');
        
        // Variables de red
        let username = "Explorador" + Math.floor(Math.random() * 1000);
        let otherPlayers = {};

        // AÑADIR ESTE BLOQUE
        // ----------------------------------------------------
        const miBibliotecaMusical = [
            // ¡IMPORTANTE! Reemplaza estas URLs con las URLs reales de tus archivos MP3
            "https://files.catbox.moe/kmzejt.flac", // Hay corazon solo piano
            "https://files.catbox.moe/sge1i6.flac", //radio tagua con canto en junio
            "https://files.catbox.moe/m4h5se.flac", //he atrapado una galaxia con voz
            "https://files.catbox.moe/vk6oe3.flac",
            "https://files.catbox.moe/103wdw.mp3", //Corazon se lleva la tormenta
            "https://files.catbox.moe/q95jbe.flac" //Trascendencia2
        ];

        let gestorDePulsares = {
            activos: {},       // Almacenará todas las instancias de pulsares
            pulsarAudible: null, // Guardará la ID del único pulsar que puede sonar
            // Parámetros de gestión de audio
            zonaDeCarga: 800,  // Distancia a la que empezamos a cargar el audio
            zonaAudible: 300   // Distancia a la que el pulsar es candidato para sonar
        };
        
        // AÑADIR ESTE BLOQUE COMPLETO DE PALETAS DE COLORES
        // -------------------------------------------------------------------
        const MAJESTIC_NEBULA_COLORS_HSL = [
            { h: 0.80, s: 0.9, l: 0.60, name: "Magenta Profundo" },
            { h: 0.52, s: 0.9, l: 0.55, name: "Cian Eléctrico" },
            { h: 0.95, s: 0.8, l: 0.65, name: "Rosa Cósmico" },
            { h: 0.70, s: 0.85,l: 0.50, name: "Violeta Intenso" },
            { h: 0.35, s: 0.7, l: 0.50, name: "Verde Esmeralda" },
            { h: 0.05, s: 0.9, l: 0.60, name: "Naranja Ígneo" },
        ];
        const CORE_PULSATING_COLORS_HSL = [
            { h: 0.0,  s: 0.0, l: 0.80, name: "Blanco Estelar" },
            { h: 0.83, s: 0.90, l: 0.55, name: "Fucsia Radiante" },
            { h: 0.93, s: 0.90, l: 0.62, name: "Rosa Eléctrico" },
            { h: 0.50, s: 0.85,l: 0.60, name: "Calipso Luminoso" },
            { h: 0.10, s: 0.90, l: 0.53, name: "Oro Brillante" },
        ];
        const MAJESTIC_CORONA_COLORS_HSL = [
            { h: 0.12, s: 1.0, l: 0.75, name: "Oro Solar" },
            { h: 0.08, s: 0.9, l: 0.80, name: "Ámbar Brillante" },
            { h: 0.0,  s: 0.0, l: 0.95, name: "Luz Estelar Pura" }
        ];
        const TAGUA_TAGUA_BASE_COLORS_HSL = [
            { h: 0.95, s: 0.9, l: 0.65, name: "Rosa Cósmico Intenso" },
            { h: 0.85, s: 0.88,l: 0.60, name: "Fucsia Vibrante" },
            { h: 0.50, s: 0.85,l: 0.60, name: "Calipso Luminoso" },
            { h: 0.0,  s: 0.9, l: 0.55, name: "Rojo Nebular" },
            { h: 0.90, s: 0.8, l: 0.70, name: "Magenta Suave" }
        ];
        const TAGUA_TAGUA_CORE_COLORS_HSL = [
            { h: 0.93, s: 0.95, l: 0.70, name: "Rosa Eléctrico Nuclear" },
            { h: 0.0, s: 1.0, l: 0.65, name: "Rojo Corazón Ardiente" },
            { h: 0.52, s: 0.9, l: 0.65, name: "Cian Estelar" }
        ];
        // -------------------------------------------------------------------

        // Configuración física mejorada de galaxias
        const GALAXY_CONFIG = {
            particleCount: 8000,        // Más partículas para mejor efecto
            maxSize: 80,               // Mayor tamaño máximo
            coreIntensity: 1.5,        // Más brillo en el núcleo
            expansionRate: 0.025,      // Velocidad de expansión
            rotationSpeed: 0.0008,     // Rotación
            fadeRate: 0.002,           // Desvanecimiento
            spiralFactor: 3.5,         // Factor espiral más pronunciado
            armCount: 5,               // Brazos
            armWidth: 0.4,             // Ancho de brazos
            viewingDistance: 30,       // Distancia de visualización
            interactionDistance: 2.0,  // Distancia para mezcla de colores entre partículas
            sphereQuality: 8,          // Calidad de las esferas (segmentos)
            mixingIntensity: 0.3       // Intensidad de la mezcla de colores (0-1)
        };
        // Configuración mejorada para galaxias de píxeles
        const GALAXY_PIXEL_CONFIG = {
            particleCount: 10000,        // Más partículas para mayor riqueza visual
            size: 0.5,                  // Tamaño de los píxeles
            spiralFactor: 4.5,          // Factor espiral más pronunciado
            armCount: 4,                // Número de brazos de la galaxia
            colorVariety: [
                // Paleta de colores inspirada en nebulosas y galaxias reales
                {name: "Azul Profundo", hue: 0.6, sat: 0.8, light: 0.4},
                {name: "Violeta Cósmico", hue: 0.75, sat: 0.7, light: 0.45},
                {name: "Turquesa Espacial", hue: 0.55, sat: 0.6, light: 0.5},
                {name: "Rosa Magenta", hue: 0.9, sat: 0.7, light: 0.5},
                {name: "Verde Esmeralda", hue: 0.4, sat: 0.6, light: 0.45},
                {name: "Naranja Cálido", hue: 0.08, sat: 0.8, light: 0.5},
            ],
            mixingIntensity: 0.4,       // Intensidad de mezcla de colores
            expansionTime: 5000,        // Tiempo de expansión de la galaxia
            rotationSpeed: 0.005,       // Velocidad de rotación
            lifetime: 30000             // Tiempo de vida de la galaxia
        };
        const GALAXY_PULSAR_CONFIG = {
            
            baseSize: 80,
            pulseIntensity: 4.5,
            pulseSpeedFactor: 0.012,
            rotationSpeedFactor: 0.0015,
            coreBrightness: 0.5,
            generalOpacity: 0.5,
            colorIntensityAudio: 0.35,
            coreColorSpeed: 0.20,
            outerColorSpeed: 0.12
            
        };

         // AÑADE ESTE NUEVO OBJETO DE CONFIGURACIÓN
         const TAGUA_TAGUA_CONFIG = {
            ...GALAXY_PULSAR_CONFIG, // Copia toda la configuración del púlsar MP3
            baseSize: 160,
            pulseIntensity: 4.5,
            pulseSpeedFactor: 0.012,
            rotationSpeedFactor: 0.0015,
            coreBrightness: 0.5,
            generalOpacity: 0.5,
            colorIntensityAudio: 0.35,
            coreColorSpeed: 0.20,
            outerColorSpeed: 0.12,    // Un núcleo más brillante para que destaque
        };
        
        // Clase para partícula individual
        // 1. SOLUCIÓN PARA EL CONGELAMIENTO DE ANIMACIÓN
        // 1. SOLUCIÓN PARA EL CONGELAMIENTO DE ANIMACIÓN
        // El problema probablemente está en la gestión de la memoria y los objetos
        // Modifica la clase PixelGalaxy para garantizar una limpieza adecuada

        // ---------- Clase PixelGalaxy (actualizada) ------------
        class PixelGalaxy {
            constructor(id, initialPosition, avatarMesh) {                this.id = id;
                this.position = initialPosition.clone();
                this.creationTime = Date.now();
                this.geometry = new THREE.BufferGeometry();
                this.isFadingOut = false;
                this.fadeOutStartTime = 0;
                this.lastUpdateTime = Date.now();
                this.lastNoteTime = Date.now();
                this.isDisposed = false;
                this.avatarMesh = avatarMesh;
                this.pulsePhase = 0;
                this.armRotation = 0; // Controla la rotación global de los brazos
                this.activeNotes = {};
                this.fullyExpanded = false; // Flag para controlar si ya se expandió completamente

                // Sistema de transiciones fluidas
                this.baseExpansionSize = 25; // Tamaño base configurado por el slider
                this.targetExpansion = 25;   // Tamaño objetivo (afectado por MIDI y slider)
                this.currentExpansion = 25;  // Tamaño actual interpolado
                this.expansionTransitionSpeed = 0.008; // Velocidad de transición
                this.minExpansion = 15;      // Tamaño mínimo (velocidad alta)
                this.maxExpansion = 50;      // Tamaño máximo (velocidad baja)
                this.midiScaleFactor = 1.0;  // Factor de escala MIDI (0.6-1.4)

                // Nuevo: Color predominante para toda la galaxia
                const colorSchemes = [
                    { name: "Azul Nebulosa", baseHue: 0.6, variation: 0.03 },
                    { name: "Púrpura Espacial", baseHue: 0.75, variation: 0.03 },
                    { name: "Verde Cósmico", baseHue: 0.35, variation: 0.04 },
                    { name: "Rojo Estelar", baseHue: 0.0, variation: 0.03 },
                    { name: "Ámbar Solar", baseHue: 0.12, variation: 0.03 },
                    { name: "Turquesa Profundo", baseHue: 0.48, variation: 0.03 }
                ];
                
                this.colorScheme = colorSchemes[Math.floor(Math.random() * colorSchemes.length)];

                // Obtener configuración personalizada si existe
                let customSettings = {};
                try {
                    const savedSettings = localStorage.getItem('musicosmosGalaxySettings');
                    if (savedSettings) {
                        customSettings = JSON.parse(savedSettings);
                    }
                } catch (e) {
                    console.error('Error al cargar configuración de galaxia:', e);
                }

                // Configuración combinada
                this.config = {
                    particleCount: 7000,
                    baseSize: 0.3,
                    expansionSpeed: 0.0008,
                    spiralSpeed: 0.0008,
                    armRotationSpeed: 0.00015,
                    pulseSpeed: 0.02,
                    // Valores que pueden ser personalizados
                    maxExpansion: customSettings.size || 25,
                    particleAffectedRatio: (customSettings.particleCount || 12) / 100,
                    colorMixFactor: (customSettings.colorMixing || 50) / 100,
                    expansionTime: customSettings.expansionTime || 4000,
                    inactivityTime: customSettings.fadeoutTime || 20000,
                    // Otros valores
                    lifeTime: 25000,
                    fadeOutTime: 5000,
                    verticalScale: 0.9,
                    responseSpeed: 0.3,
                    // Usar un único esquema de color predominante
                    baseHue: this.colorScheme.baseHue,
                    colorVariation: this.colorScheme.variation,
                    // Historial de notas para transición cromática
                    noteHistory: [],
                    maxHistoryLength: 10
                };

                // Inicializar los valores del sistema de transiciones
                this.baseExpansionSize = this.config.maxExpansion;
                this.targetExpansion = this.config.maxExpansion;
                this.currentExpansion = this.config.maxExpansion;

                this.createGalaxy();
                this.createNebulaCore(this.avatarMesh);
            }

            // Método para actualizar la configuración cuando cambia el slider
            updateConfig(newConfig) {
                // Actualizar la configuración
                for (const key in newConfig) {
                    if (this.config.hasOwnProperty(key)) {
                        this.config[key] = newConfig[key];
                    }
                }
                
                // IMPORTANTE: Actualizar el tamaño base cuando cambia el slider
                if (newConfig.maxExpansion !== undefined) {
                    this.baseExpansionSize = newConfig.maxExpansion;
                    
                    // Recalcular el tamaño objetivo manteniendo el factor de escala MIDI
                    this.adjustTargetExpansion();
                }
            }
            
            // Nuevo método para ajustar el tamaño objetivo teniendo en cuenta 
            // tanto el tamaño base (slider) como el factor de escala MIDI
            adjustTargetExpansion() {
                // Calcular nuevo tamaño objetivo basado en el tamaño base y el factor MIDI actual
                this.targetExpansion = this.baseExpansionSize * this.midiScaleFactor;
                
                // Mantener dentro de límites razonables
                this.targetExpansion = Math.max(this.minExpansion, 
                                    Math.min(this.maxExpansion, this.targetExpansion));
            }

            createGalaxy() {
                const particleCount = this.config.particleCount;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const nebulaParams = new Float32Array(particleCount * 4);
                
                // Hue base para toda la galaxia (color predominante)
                const baseHue = this.config.baseHue;
                
                for (let i = 0; i < particleCount; i++) {
                    // Generar un radio aleatorio con sesgo y un ángulo base aleatorio
                    const distFromCenter = Math.pow(Math.random(), 0.5) * this.config.maxExpansion;
                    const baseAngle = Math.random() * Math.PI * 2;
                    const speedVar = Math.random();
                    const phaseOffset = Math.random() * Math.PI * 2;
                    
                    nebulaParams[i * 4] = distFromCenter;
                    nebulaParams[i * 4 + 1] = baseAngle;
                    nebulaParams[i * 4 + 2] = speedVar;
                    nebulaParams[i * 4 + 3] = phaseOffset;
                    
                    // Posición inicial concentrada
                    positions[i * 3] = (Math.random() - 0.5) * 0.2;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                    
                    // Pequeña variación sutil en el color (dentro del mismo tono)
                    const hueVar = (Math.random() - 0.5) * this.config.colorVariation;
                    const saturation = 0.7 + Math.random() * 0.3; // Alta saturación
                    const lightness = 0.4 + Math.random() * 0.2; // Brillo moderado
                    
                    // Aplicar color con pequeña variación pero mismo tono base
                    const color = new THREE.Color().setHSL(
                        (baseHue + hueVar) % 1.0, 
                        saturation, 
                        lightness
                    );
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = this.config.baseSize * (0.6 + Math.random() * 0.6);
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                this.nebulaParams = nebulaParams;
                
                // Usar textura circular nítida
                const circleTexture = createSharperCircleTexture();
                const material = new THREE.PointsMaterial({
                    size: this.config.baseSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    map: circleTexture,
                    alphaTest: 0.05
                });
                
                this.pixelObject = new THREE.Points(this.geometry, material);
                this.pixelObject.position.copy(this.position);
                scene.add(this.pixelObject);
            }

            createNebulaCore(avatarMesh) {
                if (!avatarMesh) return;
                
                // Shaders para efectos de glow mejorados
                const glowVertexShader = `
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
                `;
                
                const glowFragmentShader = `
                uniform vec3 glowColor;
                uniform float pulseIntensity;
                uniform float timeFactor;
                
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                void main() {
                    // Calcular intensidad basada en ángulo de visión
                    float intensity = pow(0.7 - dot(normalize(vViewPosition), vNormal), 2.0);
                    // Añadir efecto de pulso
                    intensity *= 1.0 + 0.3 * sin(timeFactor);
                    // Aplicar intensidad de pulso global
                    intensity *= pulseIntensity;
                    
                    gl_FragColor = vec4(glowColor, 1.0) * intensity;
                }
                `;
                
                // Guardar material original
                this.originalAvatarMaterial = avatarMesh.material.clone();                
                // Crear shader personalizado para el avatar
                const avatarUniforms = {
                    glowColor: { value: new THREE.Color(0x4488ff) },
                    pulseIntensity: { value: 1.0 },
                    timeFactor: { value: 0.0 }
                };
                
                const avatarMaterial = new THREE.ShaderMaterial({
                    uniforms: avatarUniforms,
                    vertexShader: glowVertexShader,
                    fragmentShader: glowFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.FrontSide
                });
                
                avatarMesh.material = avatarMaterial; // <-- LÍNEA CORRECTA// <-- 4. MODIFICA ESTA LÍNEA.material = avatarMaterial;
                this.avatarUniforms = avatarUniforms;
                
                // Inner glow mejorado con shaders
                const innerGlowGeometry = new THREE.SphereGeometry(1.05, 24, 24);
                const innerGlowUniforms = {
                    glowColor: { value: new THREE.Color(0xccffff) },
                    pulseIntensity: { value: 0.8 },
                    timeFactor: { value: 0.0 }
                };
                
                const innerGlowMaterial = new THREE.ShaderMaterial({
                    uniforms: innerGlowUniforms,
                    vertexShader: glowVertexShader,
                    fragmentShader: glowFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                this.innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
                this.innerGlowUniforms = innerGlowUniforms;
                avatarMesh.add(this.innerGlow); // <-- 5. MODIFICA ESTA LÍNEA                
                // Outer glow expansivo con shader
                const outerGlowGeometry = new THREE.SphereGeometry(this.config.maxExpansion / 10, 24, 24);
                const outerGlowUniforms = {
                    glowColor: { value: new THREE.Color(0x3366ff) },
                    pulseIntensity: { value: 0.4 },
                    timeFactor: { value: 0.0 }
                };
                
                const outerGlowMaterial = new THREE.ShaderMaterial({
                    uniforms: outerGlowUniforms,
                    vertexShader: glowVertexShader,
                    fragmentShader: glowFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                
                this.outerGlowEffect = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
                this.outerGlowUniforms = outerGlowMaterial.uniforms;
                avatarMesh.add(this.outerGlowEffect); // <-- 6. MODIFICA ESTA LÍNEA                
                // Luz central sutil
                this.coreLight = new THREE.PointLight(0xffffff, 1.0, 15);
                this.coreLight.position.set(0, 0, 0);
                avatarMesh.add(this.coreLight); // <-- 7. MODIFICA ESTA LÍNEA
            }

            // Añade esta mejora al método pulseCore en la clase PixelGalaxy
            pulseCore(note, velocity) {
                if (!this.innerGlow || !this.outerGlowEffect || !this.coreLight) return;
                
                const now = Date.now();
                this.lastNoteTime = now;
                
                // Mapeo de nota MIDI a color (0-127 -> 0-1 en hue)
                const noteHue = (note % 12) / 12;
                const octave = Math.floor(note / 12) - 1;
                
                // Registrar o actualizar nota en activeNotes
                if (!this.activeNotes[note]) {
                    // Nueva nota
                    this.activeNotes[note] = {
                        velocity: velocity,
                        startTime: now,
                        duration: 0,
                        lastUpdateTime: now,
                        color: new THREE.Color().setHSL(
                            noteHue, 
                            0.85, 
                            0.55 + (octave / 8) * 0.25
                        )
                    };
                } else {
                    // MODIFICADO: Si la nota ya existe, actualizar su velocidad
                    // pero mantener otros parámetros para una mejor experiencia
                    const previousUpdateTime = this.activeNotes[note].lastUpdateTime;
                    this.activeNotes[note].velocity = velocity;
                    this.activeNotes[note].lastUpdateTime = now;
                    
                    // Solo actualizar la duración acumulada si es una nueva pulsación
                    // no si es un cambio de volumen continuo
                    if (now - previousUpdateTime > 500) { // Umbral para diferenciar nuevo toque vs cambio de CC
                        this.activeNotes[note].duration += now - previousUpdateTime;
                    }
                }
                
                // Calcular color basado en la nota
                const noteColor = new THREE.Color().setHSL(
                    noteHue, 
                    0.85, 
                    0.55 + (octave / 8) * 0.25
                );
                
                const intensity = 0.7 + (velocity / 127) * 1.3;
                
                // Actualizar uniforms del shader del avatar
                if (this.avatarUniforms) {
                    this.avatarUniforms.glowColor.value = noteColor;
                    this.avatarUniforms.pulseIntensity.value = intensity;
                    this.avatarUniforms.timeFactor.value = now * 0.003;
                }
                
                // Inner glow: mezcla con blanco usando uniforms
                if (this.innerGlowUniforms) {
                    const mixedColor = new THREE.Color(0xffffff).lerp(noteColor, 0.4);
                    this.innerGlowUniforms.glowColor.value = mixedColor;
                    this.innerGlowUniforms.pulseIntensity.value = 0.2 + (velocity / 127) * 0.2;
                    this.innerGlowUniforms.timeFactor.value = now * 0.003;
                }
                
                // Outer glow con uniforms
                if (this.outerGlowUniforms) {
                    this.outerGlowUniforms.glowColor.value = noteColor;
                    this.outerGlowUniforms.pulseIntensity.value = 0.2 + (velocity / 127) * 0.2;
                    this.outerGlowUniforms.timeFactor.value = now * 0.002;
                }
                
                // Luz central
                if (this.coreLight) {
                    this.coreLight.color = noteColor;
                    this.coreLight.intensity = 0.8 + intensity * 0.4;
                    this.coreLight.distance = 10 + (velocity / 127) * 10;
                }
                
                // AÑADIDO: Actualizar también el factor de escala MIDI basado en la velocidad
                // para mantener consistencia con los cambios de volumen
                const velocityNormalized = velocity / 127;
                const inversedVelocity = 1 - velocityNormalized;
                this.midiScaleFactor = 0.6 + inversedVelocity * 0.8;
                this.adjustTargetExpansion();
                
                // Actualizar variable de control
                this.updateDominantNote();
            }

            // Agregar método para encontrar la nota dominante
            updateDominantNote() {
                const now = Date.now();
                let maxDuration = 0;
                let mostPlayedNote = null;
                
                // Buscar nota sostenida más tiempo o tocada más veces
                for (const noteId in this.activeNotes) {
                    const note = this.activeNotes[noteId];
                    
                    // Calcular duración acumulada
                    const noteDuration = note.duration + (now - note.lastUpdateTime);
                    
                    if (noteDuration > maxDuration) {
                        maxDuration = noteDuration;
                        mostPlayedNote = noteId;
                    }
                }
                
                // Si hay una nota dominante que supera un umbral (3 segundos)
                const dominanceThreshold = 3000; // 3 segundos
                if (maxDuration > dominanceThreshold && mostPlayedNote) {
                    this.dominantNote = parseInt(mostPlayedNote);
                    this.dominantNoteIntensity = Math.min(1, maxDuration / 10000); // Máximo en 10 segundos
                } else {
                    this.dominantNoteIntensity = this.dominantNoteIntensity ? 
                        Math.max(0, this.dominantNoteIntensity - 0.01) : 0; // Disminuir gradualmente
                }
            }

            addParticles(note, velocity) {
                if (!this.pixelObject || !this.pixelObject.geometry || this.isDisposed) return;
                
                // Si estaba desvaneciéndose, cancelar el desvanecimiento
                if (this.isFadingOut) {
                    this.isFadingOut = false;
                    if (this.pixelObject.material) {
                        this.pixelObject.material.opacity = 0.9; // Restaurar opacidad
                    }
                }
                
                // Activar efectos del núcleo según nota MIDI
                this.pulseCore(note, velocity);
                this.lastNoteTime = Date.now();
                
                // Mapeo de nota a tono de color
                const noteHue = (note % 12) / 12;
                const octave = Math.floor(note / 12) - 1;
                const noteColor = new THREE.Color().setHSL(
                    noteHue, 
                    0.85, 
                    0.55 + (octave / 8) * 0.25
                );
                
                // MODIFICADO: Relación invertida entre velocidad y tamaño
                // Usando factor de escala MIDI en lugar de reemplazar directamente maxExpansion
                const velocityNormalized = velocity / 127;
                const inversedVelocity = 1 - velocityNormalized;
                
                // Calcular factor de escala entre 0.6 (velocidad alta) y 1.4 (velocidad baja)
                // Esto permite que el slider mantenga su función de control de tamaño base
                this.midiScaleFactor = 0.6 + inversedVelocity * 0.8;
                
                // Actualizar el tamaño objetivo basado en el tamaño base y el factor MIDI
                this.adjustTargetExpansion();
                
                const positions = this.geometry.attributes.position;
                const colors = this.geometry.attributes.color;
                
                // Mayor cantidad de partículas para respuesta más rápida
                // Usar ratio personalizado y velocidad
                const transformCount = Math.floor(positions.count * this.config.particleAffectedRatio * velocityNormalized);
                
                // Transformar un subconjunto de partículas
                for (let i = 0; i < transformCount; i++) {
                    // Elegir partícula aleatoria
                    const idx = Math.floor(Math.random() * positions.count);
                    
                    // Transformar color gradualmente
                    const currentColor = new THREE.Color(
                        colors.array[idx * 3],
                        colors.array[idx * 3 + 1],
                        colors.array[idx * 3 + 2]
                    );
                    
                    // Mezcla más agresiva hacia el nuevo color para respuesta más rápida
                    const baseFactor = this.config.colorMixFactor;
                    const mixFactor = baseFactor + velocityNormalized * (baseFactor * 0.8);
                    const newColor = currentColor.lerp(noteColor, mixFactor);
                    
                    colors.array[idx * 3] = newColor.r;
                    colors.array[idx * 3 + 1] = newColor.g;
                    colors.array[idx * 3 + 2] = newColor.b;
                }
                
                // Marcar colores para actualización
                colors.needsUpdate = true;
                
                // Extender la vida de la galaxia
                this.creationTime = Math.min(this.creationTime, Date.now() - 5000); // Mantener expansión
            }

            update() {
                if (this.isDisposed || !this.pixelObject) return false;
                
                const now = Date.now();
                const deltaTime = now - this.lastUpdateTime;
                this.lastUpdateTime = now;
                
                if (deltaTime > 1000) return true;
                
                // Actualizar factor de tiempo para shaders
                if (this.avatarUniforms) {
                    this.avatarUniforms.timeFactor.value = now * 0.003;
                }
                if (this.innerGlowUniforms) {
                    this.innerGlowUniforms.timeFactor.value = now * 0.003;
                }
                if (this.outerGlowUniforms) {
                    this.outerGlowUniforms.timeFactor.value = now * 0.002;
                }
                
                const age = now - this.creationTime;
                const timeSinceLastNote = now - this.lastNoteTime;
                
                // MODIFICADO: Transición suave del tamaño de expansión
                if (this.currentExpansion !== this.targetExpansion) {
                    // Factor que controla la velocidad de transición
                    const lerpFactor = Math.min(1.0, this.expansionTransitionSpeed * deltaTime);
                    
                    // Interpolación lineal hacia el tamaño objetivo
                    this.currentExpansion += (this.targetExpansion - this.currentExpansion) * lerpFactor;
                    
                    // Si estamos muy cerca del objetivo, finalizar la transición
                    if (Math.abs(this.currentExpansion - this.targetExpansion) < 0.01) {
                        this.currentExpansion = this.targetExpansion;
                    }
                }
                
                // Usar tiempo de expansión personalizado
                let normalizedAge = Math.min(1, age / this.config.expansionTime);
                
                // Si ya se expandió completamente una vez, mantenerla expandida
                if (normalizedAge >= 1) {
                    this.fullyExpanded = true;
                }
                
                // Si está completamente expandida, mantener la expansión
                if (this.fullyExpanded) {
                    normalizedAge = 1;
                }
                
                // Incrementar el pulso y la rotación global de los brazos
                this.pulsePhase += this.config.pulseSpeed * deltaTime / 1000;
                this.armRotation += this.config.armRotationSpeed * deltaTime;
                const pulseValue = 0.5 + Math.sin(this.pulsePhase) * 0.5;
                
                // MODIFICADO: Usar currentExpansion en lugar de config.maxExpansion
                const maxScale = this.currentExpansion / 20;
                const currentScale = Math.min(maxScale, normalizedAge * maxScale);
                const positions = this.geometry.attributes.position;
                const sizes = this.geometry.attributes.size;
                
                // Actualizar cada partícula para lograr un efecto espiral animado
                for (let i = 0; i < positions.count; i++) {
                    const dist = this.nebulaParams[i * 4] * currentScale;
                    const baseAngle = this.nebulaParams[i * 4 + 1];
                    const speedVar = this.nebulaParams[i * 4 + 2];
                    const phaseVar = this.nebulaParams[i * 4 + 3];
                    
                    // Calcular rotación diferencial y sumar la rotación global (se resta para invertir sentido)
                    const rotationIncrement = this.config.spiralSpeed * deltaTime * (0.5 + speedVar);
                    const angle = baseAngle + rotationIncrement - this.armRotation + Math.sin(this.pulsePhase * 0.2 + phaseVar * 10) * 0.1;
                    
                    // Onda radial
                    const wavePhase = this.pulsePhase * 0.3 + phaseVar * Math.PI * 2;
                    const waveMagnitude = 0.25 * speedVar * dist;
                    const orbitRadius = dist * (0.7 + Math.sin(wavePhase) * 0.3);
                    
                    positions.array[i * 3] = Math.cos(angle) * orbitRadius + Math.cos(wavePhase * 1.5) * waveMagnitude;
                    positions.array[i * 3 + 2] = Math.sin(angle) * orbitRadius + Math.sin(wavePhase * 1.5) * waveMagnitude;
                    
                    // Componente Y para dar volumen
                    const yOffset = speedVar * currentScale * this.config.verticalScale;
                    const yWave = Math.sin(wavePhase + angle) * waveMagnitude * 0.8;
                    positions.array[i * 3 + 1] = yOffset + yWave;
                    
                    // Tamaño con pulso
                    const pulseFactor = 1 + pulseValue * 0.1 * (0.5 + phaseVar);
                    sizes.array[i] = this.config.baseSize * (0.5 + normalizedAge * 0.5) * pulseFactor;
                }
                
                positions.needsUpdate = true;
                sizes.needsUpdate = true;
                
                // Manejo del fade out - usar tiempo de inactividad personalizado
                if (this.isFadingOut) {
                    const fadeOutDuration = this.config.fadeOutTime;
                    const timeSinceFade = now - this.fadeOutStartTime;
                    const opacity = Math.max(0, 1 - (timeSinceFade / fadeOutDuration));
                    
                    if (this.pixelObject && this.pixelObject.material) {
                        this.pixelObject.material.opacity = opacity;
                        
                        // Solo eliminar después de un tiempo mucho mayor sin interacción
                        if (opacity <= 0 && timeSinceLastNote > 30000) {
                            scene.remove(this.pixelObject);
                            this.dispose();
                            return false;
                        }
                    }
                } else if (timeSinceLastNote > this.config.inactivityTime) {  // Usar tiempo personalizado
                    this.isFadingOut = true;
                    this.fadeOutStartTime = now;
                }
                
                return true;
            }

            removeNote(note) {
                if (this.isDisposed) return;
                delete this.activeNotes[note];
                if (Object.keys(this.activeNotes).length === 0 && Date.now() - this.lastNoteTime > 15000) {
                    if (!this.isFadingOut) {
                        this.isFadingOut = true;
                        this.fadeOutStartTime = Date.now();
                    }
                }
            }

            dispose() {
                if (this.isDisposed) return;
                this.isDisposed = true;
                
                // Desvanecimiento gradual del halo del avatar
                const startTime = Date.now();
                const fadeDuration = 2000; // 2 segundos de desvanecimiento
                
                const fadeOutAvatarGlow = () => {
                    const now = Date.now();
                    const elapsed = now - startTime;
                    const progress = Math.min(1, elapsed / fadeDuration);
                    
                    // Reducir gradualmente la intensidad del shader del avatar
                    if (this.avatarUniforms && this.avatarUniforms.pulseIntensity) {
                        this.avatarUniforms.pulseIntensity.value = 1.0 * (1 - progress);
                    }
                    
                    // Reducir la intensidad del inner glow
                    if (this.innerGlowUniforms && this.innerGlowUniforms.pulseIntensity) {
                        this.innerGlowUniforms.pulseIntensity.value = 0.8 * (1 - progress);
                    }
                    
                    // Reducir la intensidad del outer glow
                    if (this.outerGlowUniforms && this.outerGlowUniforms.pulseIntensity) {
                        this.outerGlowUniforms.pulseIntensity.value = 0.4 * (1 - progress);
                    }
                    
                    // Reducir la intensidad de la luz
                    if (this.coreLight) {
                        this.coreLight.intensity = 1.0 * (1 - progress);
                    }
                    
                    if (progress < 1) {
                        // Continuar el desvanecimiento
                        requestAnimationFrame(fadeOutAvatarGlow);
                    } else {
                    // Completar la limpieza una vez finalizado el desvanecimiento
                        this.completeDispose();
                    }
                };
                
                // Iniciar el desvanecimiento
                fadeOutAvatarGlow();
            }
            
            // Método para completar la limpieza después del desvanecimiento
            completeDispose() {
                if (this.originalAvatarMaterial && this.avatarMesh) {
                    this.avatarMesh.material = this.originalAvatarMaterial;
                    this.originalAvatarMaterial = null;
                }
                
                if (this.innerGlow && avatarObject) {
                    this.avatarMesh.remove(this.innerGlow);
                    this.innerGlow.material.dispose();
                    this.innerGlow.geometry.dispose();
                    this.innerGlow = null;
                }
                
                if (this.outerGlowEffect && this.avatarMesh) {
                    this.avatarMesh.remove(this.outerGlowEffect);
                    this.outerGlowEffect.material.dispose();
                    this.outerGlowEffect.geometry.dispose();
                    this.outerGlowEffect = null;
                }
                
                if (this.coreLight && this.avatarMesh) {
                    this.avatarMesh.remove(this.coreLight);
                    this.coreLight = null;
                }
                
                if (this.pixelObject) {
                    scene.remove(this.pixelObject);
                    if (this.pixelObject.geometry) this.pixelObject.geometry.dispose();
                    if (this.pixelObject.material) {
                        if (this.pixelObject.material.map) this.pixelObject.material.map.dispose();
                        this.pixelObject.material.dispose();
                    }
                    this.pixelObject = null;
                }
                
                this.geometry = null;
                this.nebulaParams = null;
                this.avatarUniforms = null;
                this.innerGlowUniforms = null;
                this.outerGlowUniforms = null;
            }
        }

        // Función para convertir número de nota MIDI a frecuencia en Hz
        function midiToFrequency(midiNote) {
            if (midiNote < 0 || midiNote > 127) return null; // Nota inválida
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }
        
        // Clase Galaxy para manejar conjuntos de partículas
        // Modificar el método addNote en la clase Galaxy para usar PixelGalaxy
       // ---------- Clase Galaxy (actualizada) ------------
        class Galaxy {
            
            constructor(id, initialPosition, isLocal = false) {
                this.id = id;
                this.position = initialPosition.clone();
                this.pixelGalaxy = null;
                this.activeNotes = new Map();
                this.energy = 0;
                this.lastNoteTime = Date.now();
                this.isDisposed = false;
                this.positionalAudio = null; 
                this.activeAudioNotes = {}; 
                this.isLocal = isLocal;

                // --- INICIO DE LA CORRECCIÓN ---

                // 1. Crear el emisor de audio 3D para TODAS las galaxias
                if (audioListener) {
                    this.positionalAudio = new THREE.PositionalAudio(audioListener);
                    this.positionalAudio.setRefDistance(20); 
                    this.positionalAudio.setRolloffFactor(1.5); 
                    this.positionalAudio.setMaxDistance(200); 

                    this.positionalAudio.panningModel = 'HRTF'; // Añade esta línea
                } else {
                    console.error("AudioListener no está inicializado al crear Galaxy!");
                }

                if (this.isLocal) {
                    // 2. Si es LOCAL, usamos el avatar global
                    this.avatarMesh = avatarObject;
                    // ¡LA LÍNEA QUE FALTABA! Conectamos el audio 3D al avatar local.
                    if (this.positionalAudio) {
                        this.avatarMesh.add(this.positionalAudio);
                    }

                } else {
                    // 3. Si es REMOTO, creamos un nuevo avatar
                    const geometry = new THREE.SphereGeometry(1, 16, 12);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: 0x4488ff,
                        emissive: 0x112244,
                        transparent: true,
                        opacity: 0.6,
                        shininess: 30
                    });
                    this.avatarMesh = new THREE.Mesh(geometry, material);
                    this.avatarMesh.position.copy(this.position);
                    scene.add(this.avatarMesh);
                    
                    this.targetPosition = this.position.clone();
                    this.interpolationFactor = 0.1; 

                    // Conectamos el audio 3D al avatar remoto
                    if (this.positionalAudio) {
                        this.avatarMesh.add(this.positionalAudio);
                    }
                }
                
                // --- FIN DE LA CORRECCIÓN ---
            }

            addNote(note, velocity) {
                if (this.isDisposed) return;
                this.activeNotes.set(note, { velocity: velocity, time: Date.now() });
                this.energy = Math.min(1.0, this.energy + (velocity / 127) * 0.2);
                this.lastNoteTime = Date.now();
                if (!this.pixelGalaxy) {
                this.pixelGalaxy = new PixelGalaxy(this.id, this.position, this.avatarMesh);
                }
                if (this.pixelGalaxy) {
                this.pixelGalaxy.addParticles(note, velocity);
                }
            }

            removeNote(note) {
                if (this.isDisposed) return;
                this.activeNotes.delete(note);
                if (this.activeNotes.size === 0 && Date.now() - this.lastNoteTime > 10000) {
                if (this.pixelGalaxy && !this.pixelGalaxy.isFadingOut) {
                    this.pixelGalaxy.isFadingOut = true;
                    this.pixelGalaxy.fadeOutStartTime = Date.now();
                }
                }
            }

            update() {
                if (this.isDisposed) return;
                if (this.pixelGalaxy) {
                const result = this.pixelGalaxy.update();
                if (!result) {
                    this.pixelGalaxy = null;
                }
                }
                const now = Date.now();
                if (now - this.lastNoteTime > 2000) {
                this.energy = Math.max(0, this.energy - 0.005);
                }
            }

            updatePosition(newPos) {
                if (this.isDisposed) return;
                this.position.copy(newPos);
                if (this.pixelGalaxy && this.pixelGalaxy.pixelObject) {
                this.pixelGalaxy.pixelObject.position.copy(newPos);
                }
                // --- 4. AÑADE ESTE BLOQUE ---
                // Mueve el avatar (esfera) junto con las partículas
               // if (this.avatarMesh) {
               //     this.avatarMesh.position.copy(newPos);
               // }
            }
            // --- NUEVO MÉTODO: playRemoteNote ---
           // --- NUEVO MÉTODO: playNote (reemplaza a playRemoteNote) ---
           playNote(note, velocity) {
                // No tocamos para nosotros mismos si somos el jugador local (el AlienSynth ya lo hace)
                if (this.isLocal) return;
                
                if (!this.positionalAudio || !audioContext) return; 

                if (this.activeAudioNotes[note]) {
                    return;
                }

                try {
                    const frequency = midiToFrequency(note);
                    if (!frequency) return; 

                    const oscillator = audioContext.createOscillator();
                    oscillator.type = 'sine'; 
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

                    const gainNode = audioContext.createGain();
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime); 

                    oscillator.connect(gainNode);
                    
                    // Conectamos a .gain (el input del PositionalAudio)
                    gainNode.connect(this.positionalAudio.gain); 

                    // --- ¡LÍNEAS A AÑADIR PARA FADE IN! ---
                    const targetVolume = (velocity / 127) * 0.7; // Volumen basado en velocity
                    const attackTime = 0.05; // Duración del fade-in (en segundos)
                    gainNode.gain.linearRampToValueAtTime(targetVolume, audioContext.currentTime + attackTime); // Subir volumen suavemente
                    // --- FIN LÍNEAS A AÑADIR ---

                   

                    oscillator.start();
                    this.activeAudioNotes[note] = { oscillator, gainNode };

                } catch (e) {
                    console.error(`Error al tocar nota remota ${note}:`, e);
                }
            }
            // --- FIN playNote ---

            // --- NUEVO MÉTODO: stopNote (reemplaza a stopRemoteNote) ---
            stopNote(note) {
                // No aplica para el jugador local
                if (this.isLocal) return;

                if (!this.activeAudioNotes[note] || !audioContext) return; 

                try {
                    const { oscillator, gainNode } = this.activeAudioNotes[note];
                    const releaseTime = 0.3; 
                    const now = audioContext.currentTime;

                  // --- ¡NUEVAS LÍNEAS PARA FADE OUT! ---
                    gainNode.gain.cancelScheduledValues(now); // Cancelar rampas previas
                    gainNode.gain.setValueAtTime(gainNode.gain.value, now); // Asegurar valor actual
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + releaseTime); // Bajar a casi silencio

                    // Detener el oscilador DESPUÉS de que termine el fade out
                    oscillator.stop(now + releaseTime + 0.05); // Un pequeño margen extra
                    // --- FIN NUEVAS LÍNEAS --- 

                    setTimeout(() => {
                        try {
                            oscillator.disconnect();
                            gainNode.disconnect();
                        } catch(e) { /* Ignorar */ }
                    }, (releaseTime + 0.1) * 1000); 

                    delete this.activeAudioNotes[note];

                } catch (e) {
                    console.error(`Error al detener nota remota ${note}:`, e);
                }
            }
            // --- FIN stopNote ---
            // --- FIN stopRemoteNote ---



            dispose() {
                if (this.isDisposed) return;
                this.isDisposed = true;
                // --- LIMPIEZA DE AUDIO ---
                if (!this.isLocal) {
                    // Detener todas las notas de audio activas inmediatamente
                    for (const note in this.activeAudioNotes) {
                        try {
                            const { oscillator, gainNode } = this.activeAudioNotes[note];
                            oscillator.stop();
                            oscillator.disconnect();
                            gainNode.disconnect();
                        } catch (e) { /* Ignorar errores si ya estaba desconectado */ }
                    }
                    this.activeAudioNotes = {};

                    // Quitar el PositionalAudio del avatar
                    if (this.positionalAudio && this.avatarMesh) {
                        this.avatarMesh.remove(this.positionalAudio);
                        // No necesitas desconectar positionalAudio explícitamente si se elimina del grafo
                    }
                    this.positionalAudio = null; // Liberar referencia
                }
                // --- FIN LIMPIEZA AUDIO ---
                if (this.pixelGalaxy) {
                this.pixelGalaxy.dispose();
                this.pixelGalaxy = null;
                }// --- 5. AÑADE ESTE BLOQUE ---
                // Si no es local, destruimos el avatar que creamos
                if (!this.isLocal && this.avatarMesh) {
                    scene.remove(this.avatarMesh);
                    this.avatarMesh.geometry.dispose();
                    this.avatarMesh.material.dispose();
                }
                this.avatarMesh = null;
                // --- FIN DEL BLOQUE ---
               
                this.activeNotes.clear();
            }
            }

        

        // Sistema de hipervelocidad para Musicosmos

        // Pega esta función completa en tu script (antes de la función init)

        function initStaticTaguaTaguaRadio() {
            console.log("Inicializando Radio Tagua Tagua estática...");

            // 1. Creamos el elemento de audio para el streaming
            radioTaguaTaguaStream = new Audio(TAGUA_TAGUA_STREAM_URL);
            radioTaguaTaguaStream.crossOrigin = "anonymous";
            radioTaguaTaguaStream.loop = true;

            // --- INICIO DE LA CORRECCIÓN ---
            // 1. Declaramos la variable 'source' aquí arriba
            let sourceNode = null; 
            // --- FIN DE LA CORRECCIÓN ---

            // 2. Creamos su propio analizador de audio
            if (audioContext) {
                analyserNodeTaguaTagua = audioContext.createAnalyser();
                analyserNodeTaguaTagua.fftSize = 512;
                analyserNodeTaguaTagua.smoothingTimeConstant = 0.75;

                // --- INICIO DE LA CORRECCIÓN ---
                // 2. Asignamos el nodo creado
                sourceNode = audioContext.createMediaElementSource(radioTaguaTaguaStream); 
                sourceNode.connect(analyserNodeTaguaTagua);
                // --- FIN DE LA CORRECCIÓN ---
                
                // La línea de "leak" 2D ya la habíamos quitado, lo cual es correcto.
            }

            // 3. Creamos la instancia de la nebulosa con sus características únicas
            radioTaguaTaguaNebula = new RadioNebula(
                scene,
                TAGUA_TAGUA_NEBULA_POS,
                analyserNodeTaguaTagua,
                TAGUA_TAGUA_CONFIG, 
                'tagua_tagua',      
                true                
            );

            // 4. Añadimos el audio posicional para que el sonido venga de la nebulosa
            const positionalAudio = new THREE.PositionalAudio(audioListener);
            positionalAudio.setRefDistance(40);
            positionalAudio.setRolloffFactor(1);
            positionalAudio.setMaxDistance(3000); 
            
            if (analyserNodeTaguaTagua) {
                positionalAudio.setNodeSource(analyserNodeTaguaTagua);
            }
            radioTaguaTaguaNebula.particlesObject.add(positionalAudio);
            
            // 5. Preparamos el audio para la reproducción
            radioTaguaTaguaStream.load();

            // 6. La registramos en el gestor de púlsares para que el sistema la controle
            const pulsarId = "tagua_tagua_matriz";
            gestorDePulsares.activos[pulsarId] = {
                id: pulsarId,
                nebula: radioTaguaTaguaNebula,
                audio: radioTaguaTaguaStream,
                analyser: analyserNodeTaguaTagua,
                positionalAudio: positionalAudio,
                url: TAGUA_TAGUA_STREAM_URL,
                tiempoGuardado: 0,
                
                // --- INICIO DE LA CORRECCIÓN ---
                // 3. Guardamos el nodo 'source' que creamos
                mediaSource: sourceNode, 
                // 4. Marcamos como "ya cargada" (¡ESTA ES LA LÍNEA MÁS IMPORTANTE!)
                isLoaded: true,          
                // --- FIN DE LA CORRECCIÓN ---
                
                isPlaying: false
            };
        }

        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            scene.fog = new THREE.FogExp2(0x000011, 0.0004); // Niebla más sutil
            
            // Añadir efecto de bloom para mejor apariencia
            const renderScene = new THREE.Scene();
            
            // Configurar cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            audioListener = new THREE.AudioListener();
            audioContext = audioListener.context;

            camera.add(audioListener);
            camera.position.set(0, 10, 20);
            
            // Crear renderer
            // Crear renderer
            // Crear renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Crear el efecto estéreo DESPUÉS de haber creado el renderer



            // Iluminación ambiental
            const ambientLight = new THREE.AmbientLight(0x101020);
            scene.add(ambientLight);

            // Luz direccional principal
            const directionalLight = new THREE.DirectionalLight(0x3333ff, 0.4);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Luz complementaria
            const backLight = new THREE.DirectionalLight(0x5544ee, 0.2);
            backLight.position.set(-1, -1, -1);
            scene.add(backLight);

            // Crear plano cartesiano con cuadrícula
            gridHelper = new THREE.GridHelper(1000, 100, 0x333366, 0x222244);
            scene.add(gridHelper);

            // Crear avatar para representar al usuario
            createAvatar();

            initTabs(); // <--- AÑADE ESTA LLAMADA
            initPlaylist(); // <--- AÑADE ESTA LLAMADA
            //initAudioControls(); // <--- AÑADE ESTA LLAMADA
            initMIDI();

// Todo bien hasta aquí


            
            // Crear fondo estelar
            //createStarBackground(); - 
            proceduralGenerator = new ProceduralGenerator(scene);
            hyperspaceEffect = new HyperspaceEffect(scene, camera);


            // Crear galaxia personal
            galaxies[username] = new Galaxy(username, avatarObject.position.clone(), true); // true = es Local

            // Event listeners
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown); // <--- CAMBIO AQUÍ
            window.addEventListener('keyup', onKeyUp);   // <--- CAMBIO AQUÍ
            // Mejorado: Ahora usamos mousedown en el documento, pero verificamos si fue en el menú
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('wheel', onMouseWheel);

            // Dentro de tu función init()
            isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);

            // También obtén las referencias a los elementos del DOM para los controles
            touchControlsContainer = document.getElementById('touch-controls');
            joystickContainer = document.getElementById('joystick-container');
            joystickKnob = document.getElementById('joystick-knob');
            buttonUp = document.getElementById('button-up');
            buttonDown = document.getElementById('button-down');

            if (isTouchDevice) {
                console.log("Touch device detected. Initializing touch controls.");
                if (touchControlsContainer) touchControlsContainer.style.display = 'block';
                document.body.classList.add('touch-active'); // Para CSS opcional
                initTouchControls();
            } else {
                console.log("Non-touch device detected.");
            }

            

            
            // Prevenir que los clics en el menú cierren el arrastre
            document.getElementById('settingsMenu').addEventListener('mousedown', function(event) {
                event.stopPropagation(); // Evita que el evento llegue al documento
            });
            
            // Ocultar las instrucciones después de 20 segundos
            setTimeout(() => {
                const infoElement = document.getElementById('info');
                if (infoElement) {
                    infoElement.classList.add('fade-out');
                    
                    // Opcional: remover completamente el elemento después de la transición
                    setTimeout(() => {
                        infoElement.style.display = 'none';
                    }, 2100); // Un poco más que el tiempo de transición
                }
            }, 8000);

            
            // Listener para los botones
            document.getElementById('btnSettings').addEventListener('click', function(event) {
                event.stopPropagation(); // Evita que el clic se propague al documento
                toggleSettingsMenu();
            });           
            document.getElementById('btnTeleport').addEventListener('click', toggleTeleportPanel);
            document.getElementById('btnGoToCoords').addEventListener('click', teleportToCoords);
            document.getElementById('btnPerspective').addEventListener('click', cycleViewMode);
            
            //document.getElementById('btnFirstPerson').addEventListener('click', () => setViewMode('firstPerson'));
            //document.getElementById('btnThirdPerson').addEventListener('click', () => setViewMode('thirdPerson'));
            //document.getElementById('btnBirdEye').addEventListener('click', () => setViewMode('birdEye'));
            
            document.getElementById('connectButton').addEventListener('click', connectToNetwork);
            document.getElementById('usernameInput').value = username;

            // Inicializar coordenadas de teletransporte con posición actual
            updateTeleportCoords();
            
            initStaticTaguaTaguaRadio(); // <--- AÑADE ESTA LÍNEA

            // Iniciar animación
            animate();

            // AÑADIR ESTAS LÍNEAS EN init()
            // ----------------------------------------------------
            nebulaRadarElement = document.getElementById('nebulaRadar');
            radarArrowElement = document.getElementById('radarArrow');
            radarDotElement = document.getElementById('radarDot');
            // En el radar de pulsar10.html había dos puntos. Por ahora solo usaremos uno.
            // Ocultamos el segundo por si lo usamos después para la radio.
            const radarDotTaguaTagua = document.getElementById('radarDotTaguaTagua');
            if(radarDotTaguaTagua) radarDotTaguaTagua.style.display = 'none';

                    // AÑADIMOS LA CONFIGURACIÓN DE CAPAS PARA LA CÁMARA
            camera.layers.enableAll(); // Nos aseguramos de que la cámara vea todas las capas...
            camera.layers.disable(CLICKABLE_LAYER); // ...excepto nuestra capa especial para clics.
            // ----------------------------------------------------
        }

        // Llama a esta función desde tu init() principal:
        // if (isTouchDevice) {
        //     console.log("Touch device detected. Initializing touch controls.");
        //     touchControlsContainer.style.display = 'block'; // Mostrar contenedor de controles
        //     document.body.classList.add('touch-active'); // Para deshabilitar scroll del navegador
        //     initTouchControls();
        // } else {
        //     console.log("Non-touch device detected.");
        // }

        function initTouchControls() {
            // Joystick de Movimiento (Izquierda)
            joystickKnob.addEventListener('touchstart', handleJoystickStart, { passive: false });
            document.addEventListener('touchmove', handleJoystickMove, { passive: false });
            document.addEventListener('touchend', handleJoystickEnd, { passive: false });
            document.addEventListener('touchcancel', handleJoystickEnd, { passive: false });

            // Joystick de rotación
            const joystickKnobRotation = document.getElementById('joystick-knob-rotation');
            joystickKnobRotation.addEventListener('touchstart', handleRotationJoystickStart, { passive: false });
            document.addEventListener('touchmove', handleRotationJoystickMove, { passive: false });
            document.addEventListener('touchend', handleRotationJoystickEnd, { passive: false });
            document.addEventListener('touchcancel', handleRotationJoystickEnd, { passive: false });
            
            // --> AÑADIDO: Lógica para el botón de hipervelocidad
            const buttonHyperspace = document.getElementById('button-hyperspace');
            buttonHyperspace.addEventListener('touchstart', () => {
                hyperspaceModeActive = !hyperspaceModeActive; // Alterna el estado
                if (hyperspaceEffect) {
                    hyperspaceEffect.toggleHyperspace(hyperspaceModeActive);
                }
                // Alterna la clase 'active' para el feedback visual
                buttonHyperspace.classList.toggle('active', hyperspaceModeActive);
            }, { passive: true });


            // Control de cámara táctil (arrastre y pinch-to-zoom) - Se mantiene igual
            renderer.domElement.addEventListener('touchstart', handleTouchCameraAndPinchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouchCameraAndPinchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleTouchCameraAndPinchEnd, { passive: false });
            renderer.domElement.addEventListener('touchcancel', handleTouchCameraAndPinchEnd, { passive: false });
        }

        function handleJoystickStart(event) {
            event.preventDefault();
            // Lógica original de inicio de movimiento (sin doble toque)
            if (event.target === joystickKnob && touchIdentifierJoystick === null) {
                joystickActive = true;
                touchIdentifierJoystick = event.changedTouches[0].identifier;
                const touch = event.changedTouches[0];
                joystickInitialPos.x = touch.clientX;
                joystickInitialPos.y = touch.clientY;
                joystickKnob.style.backgroundColor = 'rgba(120, 120, 180, 0.9)';
            }
        }


        function handleJoystickMove(event) {
            if (!joystickActive || touchIdentifierJoystick === null) return;
            event.preventDefault();

            let touch = null;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === touchIdentifierJoystick) {
                    touch = event.changedTouches[i];
                    break;
                }
            }
            if (!touch) return; 

            const deltaX = touch.clientX - joystickInitialPos.x;
            const deltaY = touch.clientY - joystickInitialPos.y;
            let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX);

            let knobX = deltaX;
            let knobY = deltaY;

            if (distance > joystickMaxDistance) {
                knobX = Math.cos(angle) * joystickMaxDistance;
                knobY = Math.sin(angle) * joystickMaxDistance;
            }
            
            joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;

            const threshold = joystickMaxDistance * 0.2; 
            
            // --> INVERSIÓN CORREGIDA AQUÍ
            // Hacemos que coincida con el comportamiento de las teclas W/S en tercera persona
            moveBackward = knobY < -threshold;   // Arriba en el joystick ahora es 'moveBackward'
            moveForward = knobY > threshold;    // Abajo en el joystick ahora es 'moveForward'
            
            moveLeft = knobX < -threshold;      
            moveRight = knobX > threshold;     
        }

        function handleJoystickEnd(event) {
            if (touchIdentifierJoystick === null) return;

            let touchEndedOnJoystick = false;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === touchIdentifierJoystick) {
                    touchEndedOnJoystick = true;
                    break;
                }
            }

            if (touchEndedOnJoystick) {
                joystickActive = false;
                touchIdentifierJoystick = null; // Liberar identificador
                joystickKnob.style.transform = `translate(0px, 0px)`; // Reset visual
                joystickKnob.style.backgroundColor = 'rgba(100, 100, 150, 0.7)';
                
                // Resetear variables de movimiento (CONECTA ESTO CON TUS VARIABLES)
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;
            }
        }

        function handleTouchCameraAndPinchStart(event) {
            // Ignorar si el toque es en los controles del joystick o botones
            if (event.target === joystickKnob || event.target === buttonUp || event.target === buttonDown ||
                (joystickContainer && joystickContainer.contains(event.target)) ||
                (document.getElementById('action-buttons-container') && document.getElementById('action-buttons-container').contains(event.target))
            ) {
                return;
            }
            event.preventDefault();

            if (event.touches.length === 1 && touchIdentifierCamera === null && touchIdentifierJoystick !== event.touches[0].identifier) {
                // Inicio de arrastre con un dedo para cámara
                isDragging = true; // Reutilizar la bandera del ratón
                const touch = event.touches[0];
                touchIdentifierCamera = touch.identifier;
                touchCameraInitialPos.x = touch.clientX;
                touchCameraInitialPos.y = touch.clientY;
                document.body.classList.add('dragging'); // Opcional, para feedback visual
                initialPinchDistance = null; // Resetear pinch
                touchIdentifierPinch1 = null;
                touchIdentifierPinch2 = null;

            } else if (event.touches.length === 2) {
                // Inicio de gesto de "pinch" con dos dedos
                isDragging = false; // Detener el arrastre de cámara si estaba activo
                touchIdentifierCamera = null; // Liberar el dedo de la cámara

                touchIdentifierPinch1 = event.touches[0].identifier;
                touchIdentifierPinch2 = event.touches[1].identifier;
                initialPinchDistance = getPinchDistance(event.touches);
                document.body.classList.add('dragging'); // Opcional
            }
        }

        // --- AÑADIDO: Funciones para el Joystick de Rotación y Elevación (Derecha) ---

        function handleRotationJoystickStart(event) {
            event.preventDefault();
            const joystickKnobRotation = document.getElementById('joystick-knob-rotation');
            if (event.target === joystickKnobRotation && touchIdentifierRotationJoystick === null) {
                rotationJoystickActive = true;
                touchIdentifierRotationJoystick = event.changedTouches[0].identifier;
                const touch = event.changedTouches[0];
                rotationJoystickInitialPos.x = touch.clientX;
                rotationJoystickInitialPos.y = touch.clientY;
                joystickKnobRotation.style.backgroundColor = 'rgba(120, 120, 180, 0.9)';
            }
        }

        function handleRotationJoystickMove(event) {
            if (!rotationJoystickActive || touchIdentifierRotationJoystick === null) return;
            event.preventDefault();

            let touch = null;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === touchIdentifierRotationJoystick) {
                    touch = event.changedTouches[i];
                    break;
                }
            }
            if (!touch) return;

            const joystickKnobRotation = document.getElementById('joystick-knob-rotation');
            const deltaX = touch.clientX - rotationJoystickInitialPos.x;
            const deltaY = touch.clientY - rotationJoystickInitialPos.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX);

            let knobX = deltaX;
            let knobY = deltaY;

            if (distance > joystickMaxDistance) {
                knobX = Math.cos(angle) * joystickMaxDistance;
                knobY = Math.sin(angle) * joystickMaxDistance;
            }
            
            joystickKnobRotation.style.transform = `translate(${knobX}px, ${knobY}px)`;

            const threshold = joystickMaxDistance * 0.2;
            
            moveUp = knobY < -threshold;
            moveDown = knobY > threshold;
            
            // --> INVERSIÓN CORREGIDA AQUÍ
            rotateCameraRight = knobX < -threshold; // Mover a la izquierda ahora rota a la DERECHA
            rotateCameraLeft = knobX > threshold;  // Mover a la derecha ahora rota a la IZQUIERDA
        }

        function handleRotationJoystickEnd(event) {
            if (touchIdentifierRotationJoystick === null) return;

            let touchEndedOnJoystick = false;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === touchIdentifierRotationJoystick) {
                    touchEndedOnJoystick = true;
                    break;
                }
            }

            if (touchEndedOnJoystick) {
                const joystickKnobRotation = document.getElementById('joystick-knob-rotation');
                rotationJoystickActive = false;
                touchIdentifierRotationJoystick = null;
                joystickKnobRotation.style.transform = `translate(0px, 0px)`;
                joystickKnobRotation.style.backgroundColor = 'rgba(100, 100, 150, 0.7)';
                
                // Resetear variables de rotación y elevación
                moveUp = false;
                moveDown = false;
                rotateCameraLeft = false;
                rotateCameraRight = false;
            }
        }

        function handleTouchCameraAndPinchMove(event) {
            if (!isDragging && initialPinchDistance === null) return; // Ninguna acción táctil activa
            event.preventDefault();

            if (isDragging && touchIdentifierCamera !== null && event.touches.length === 1) {
                // Mover cámara con un dedo
                let touch = null;
                for (let i = 0; i < event.changedTouches.length; i++) {
                    if (event.changedTouches[i].identifier === touchIdentifierCamera) {
                        touch = event.changedTouches[i];
                        break;
                    }
                }
                if (!touch) return;

                const deltaX = touch.clientX - touchCameraInitialPos.x;
                const deltaY = touch.clientY - touchCameraInitialPos.y;

                // CONECTA ESTO CON TUS VARIABLES DE ROTACIÓN DE CÁMARA
                // Ejemplo basado en tu código `index - copia.html`:
                yawAngle -= deltaX * mouseSensitivity * 1.5; // Aumentar sensibilidad para táctil
                pitchAngle -= deltaY * mouseSensitivity * 1.5;
                pitchAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchAngle)); // Limitar pitch

                touchCameraInitialPos.x = touch.clientX;
                touchCameraInitialPos.y = touch.clientY;

                // Llama a tu función que actualiza la posición/rotación de la cámara
                // updateCameraPosition(); // Ya se llama en animate()

            } else if (initialPinchDistance !== null && event.touches.length === 2) {
                // Mover "pinch-to-zoom" con dos dedos
                // Asegurarse de que los dedos son los mismos que iniciaron el gesto
                let t1 = null, t2 = null;
                for(let i=0; i < event.touches.length; i++) {
                    if(event.touches[i].identifier === touchIdentifierPinch1) t1 = event.touches[i];
                    if(event.touches[i].identifier === touchIdentifierPinch2) t2 = event.touches[i];
                }

                if (t1 && t2) {
                    const currentPinchDistance = getPinchDistance(event.touches);
                    const deltaDistance = currentPinchDistance - initialPinchDistance;

                    // CONECTA ESTO CON TU VARIABLE DE ZOOM O DISTANCIA DE CÁMARA
                    // Ejemplo basado en tu código `index - copia.html` (cameraOffset.z o cameraOffset.y):
                    if (currentViewMode === 'thirdPerson') {
                        cameraOffset.z -= deltaDistance * pinchZoomSensitivity;
                        cameraOffset.z = Math.max(5, Math.min(30, cameraOffset.z)); // Usa tus límites
                    } else if (currentViewMode === 'birdEye') {
                        cameraOffset.y -= deltaDistance * pinchZoomSensitivity; // En vista de pájaro, el zoom puede afectar la altura
                        cameraOffset.y = Math.max(10, Math.min(50, cameraOffset.y)); // Usa tus límites
                    } else if (currentViewMode === 'firstPerson') {
                        // En primera persona, el pinch podría controlar el FOV de la cámara
                        // camera.fov -= deltaDistance * pinchZoomSensitivity * 0.1;
                        // camera.fov = Math.max(30, Math.min(100, camera.fov));
                        // camera.updateProjectionMatrix();
                        // O simplemente no hacer nada con el zoom en primera persona.
                    }
                    // Llama a tu función que actualiza la posición/rotación de la cámara
                    // updateCameraPosition(); // Ya se llama en animate()
                    initialPinchDistance = currentPinchDistance; // Actualizar para el siguiente movimiento
                }
            }
        }

        function handleTouchCameraAndPinchEnd(event) {
            // Comprobar si el dedo que controlaba la cámara se ha levantado
            let cameraTouchEnded = false;
            if (touchIdentifierCamera !== null) {
                for (let i = 0; i < event.changedTouches.length; i++) {
                    if (event.changedTouches[i].identifier === touchIdentifierCamera) {
                        cameraTouchEnded = true;
                        break;
                    }
                }
            }
            if (cameraTouchEnded || (isDragging && event.touches.length === 0)) {
                isDragging = false;
                touchIdentifierCamera = null;
                document.body.classList.remove('dragging');
            }

            // Comprobar si uno de los dedos del pinch se ha levantado
            let pinchTouchEnded = false;
            if (touchIdentifierPinch1 !== null || touchIdentifierPinch2 !== null) {
                for (let i = 0; i < event.changedTouches.length; i++) {
                    if (event.changedTouches[i].identifier === touchIdentifierPinch1 ||
                        event.changedTouches[i].identifier === touchIdentifierPinch2) {
                        pinchTouchEnded = true;
                        break;
                    }
                }
            }
            if (pinchTouchEnded || (initialPinchDistance !== null && event.touches.length < 2)) {
                initialPinchDistance = null;
                touchIdentifierPinch1 = null;
                touchIdentifierPinch2 = null;
                if (!isDragging) { // Solo quitar 'dragging' si no hay otra acción activa
                    document.body.classList.remove('dragging');
                }
            }
            // Si no quedan dedos en la pantalla, asegurarse de resetear todo
            if (event.touches.length === 0) {
                isDragging = false;
                touchIdentifierCamera = null;
                initialPinchDistance = null;
                touchIdentifierPinch1 = null;
                touchIdentifierPinch2 = null;
                document.body.classList.remove('dragging');
            }
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Crear avatar para representar al usuario
        function createAvatar() {
            // Cambiar la geometría de cono a esfera
            // El radio de la esfera sería aproximadamente 1 para mantener un tamaño similar
            const geometry = new THREE.SphereGeometry(1, 16, 12); // Esfera con 16 segmentos horizontales y 12 verticales
            
            // Mantener el mismo material con las propiedades existentes
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x4488ff,
                emissive: 0x112244,
                transparent: true,
                opacity: 0.6,
                shininess: 30,
                flatShading: false
            });
            
            avatarObject = new THREE.Mesh(geometry, material);
            avatarObject.position.set(0, 0, 0);
            
            // No necesitamos rotar la esfera en el eje X como hacíamos con el cono
            // ya que una esfera es simétrica en todos los ejes
            // avatarObject.rotation.x = Math.PI / 2; // Esta línea se elimina
            
            avatarObject.castShadow = true;
            scene.add(avatarObject);
            
            // Añadir un pequeño punto de luz al avatar (mantener igual)
            const avatarLight = new THREE.PointLight(0x4488ff, 0.7, 10);
            avatarLight.position.set(0, 0, 0);
            avatarObject.add(avatarLight);
            
            // Actualizar posición inicial de la cámara
            updateCameraPosition();
        }

        // Crear fondo estelar mejorado
        function createStarBackground() {
            // Estrellas lejanas más numerosas
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: false
            });
            
            const starsVertices = [];
            for (let i = 0; i < 20000; i++) {
                const x = THREE.MathUtils.randFloatSpread(2000);
                const y = THREE.MathUtils.randFloatSpread(2000);
                const z = THREE.MathUtils.randFloatSpread(2000);
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
            
            // Nebulosas distantes mejoradas
            for (let i = 0; i < 12; i++) {
                createNebula();
            }
        }
        // Almacenar las nebulosas para animación
        const nebulaeObjects = [];
        // Crear una nebulosa con mejor apariencia
        function createNebula() {
            const geometry = new THREE.BufferGeometry();
            const particles = 3000;  // Más partículas para mejor densidad
            
            const positions = new Float32Array(particles * 3);
            const colors = new Float32Array(particles * 3);
            const sizes = new Float32Array(particles);
            
            // Más variedad de colores de nebulosas
            const nebulaTypes = [
                {hue: 0.6, sat: 0.7, name: "Azul"},        // Azul
                {hue: 0.3, sat: 0.5, name: "Verde"},       // Verde
                {hue: 0.05, sat: 0.8, name: "Naranja"},    // Naranja
                {hue: 0.75, sat: 0.6, name: "Púrpura"},    // Púrpura
                {hue: 0.95, sat: 0.7, name: "Rosa"},       // Rosa
                {hue: 0.15, sat: 0.65, name: "Ámbar"},     // Ámbar
                {hue: 0.52, sat: 0.5, name: "Turquesa"}    // Turquesa
            ];
            
            const selectedType = nebulaTypes[Math.floor(Math.random() * nebulaTypes.length)];
            const color = new THREE.Color();
            color.setHSL(selectedType.hue, selectedType.sat, 0.5);
            
            // Posición aleatoria de la nebulosa
            const position = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(1200),
                THREE.MathUtils.randFloatSpread(1200),
                THREE.MathUtils.randFloatSpread(1200)
            );
            
            // Crear nebulosa más grande
            const nebulaSize = 80 + Math.random() * 150;
            
            // Definir forma más natural
            for (let i = 0; i < particles; i++) {
                // Distribución gaussiana para forma más realista
                let radius = Math.random();
                radius = Math.pow(radius, 1.5) * nebulaSize; // Distribución que favorece el centro
                
                // Forma esférica con aplastamiento
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                // Distorsión para crear forma de nebulosa
                const distortion = 0.6 + Math.random() * 0.8;
                
                // Coordenadas en polares
                const x = radius * Math.sin(phi) * Math.cos(theta) * distortion;
                const y = radius * Math.sin(phi) * Math.sin(theta) * 0.5; // Aplanar en Y
                const z = radius * Math.cos(phi) * distortion;
                
                // Posiciones
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Color con variación sutil
                const hue = selectedType.hue + (Math.random() - 0.5) * 0.1;
                const c = new THREE.Color().setHSL(hue, selectedType.sat, 0.5 + Math.random() * 0.2);
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
                
                // Tamaños variables
                sizes[i] = 2 + Math.pow(Math.random(), 2) * 12;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Material con mejor mezcla
            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.25,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const nebula = new THREE.Points(geometry, material);
            
            // Posición global de la nebulosa
            nebula.position.copy(position);
            
            // Parámetros de rotación y movimiento únicos para cada nebulosa
            const nebulaData = {
                object: nebula,
                // Rotación lenta y aleatoria en cada eje
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.002,
                    y: (Math.random() - 0.5) * 0.002,
                    z: (Math.random() - 0.5) * 0.002
                },
                // Movimiento en elipse lento
                movementPath: {
                    center: position.clone(),
                    amplitude: {
                        x: 20 + Math.random() * 50,
                        y: 20 + Math.random() * 50,
                        z: 20 + Math.random() * 50
                    },
                    phase: {
                        x: Math.random() * Math.PI * 2,
                        y: Math.random() * Math.PI * 2,
                        z: Math.random() * Math.PI * 2
                    },
                    speed: {
                        x: (Math.random() - 0.5) * 0.005,
                        y: (Math.random() - 0.5) * 0.005,
                        z: (Math.random() - 0.5) * 0.005
                    }
                }
            };
            
            // Añadir a la escena
            scene.add(nebula);
            
            // Almacenar para animación
            nebulaeObjects.push(nebulaData);
        }

        // Modificar la función animate para animar las nebulosas
        function animateNebulae() {
            const time = Date.now() * 0.001; // Tiempo muy lento para movimiento suave
            
            nebulaeObjects.forEach(nebulaData => {
                const { object, rotationSpeed, movementPath } = nebulaData;
                
                // Rotación
                object.rotation.x += rotationSpeed.x;
                object.rotation.y += rotationSpeed.y;
                object.rotation.z += rotationSpeed.z;
                
                // Movimiento en elipse
                object.position.x = movementPath.center.x + 
                    Math.sin(time * movementPath.speed.x + movementPath.phase.x) * movementPath.amplitude.x;
                
                object.position.y = movementPath.center.y + 
                    Math.cos(time * movementPath.speed.y + movementPath.phase.y) * movementPath.amplitude.y;
                
                object.position.z = movementPath.center.z + 
                    Math.sin(time * movementPath.speed.z + movementPath.phase.z) * movementPath.amplitude.z;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        
        
        
        // 1. INTERCAMBIAR LA ASIGNACIÓN DE TECLAS EN LA FUNCIÓN onKeyDown

        function onKeyDown(event) {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Lógica de control 3D (con prioridad máxima)
            if (event.code === 'Digit3' || event.code === 'Numpad3') {
                isStereoMode = !isStereoMode;
                console.log("Modo Cross-Eyed:", isStereoMode ? "Activado" : "Desactivado");
                if (!isStereoMode) resetStereoStateToNormal(); // (opcional, pero ayuda)
                return; // importante para que no siga procesando esta tecla
                }

            if (isStereoMode) {
                if (event.code === 'Digit9' || event.code === 'Numpad9') {
                    // Aumentamos la separación sin un límite superior estricto
                    eyeSeparation += 0.01; 
                    console.log("Separación de Ojos:", eyeSeparation.toFixed(4));
                    return; 
                }
                if (event.code === 'Digit0' || event.code === 'Numpad0') {
                    // Eliminamos el tope de '0.01' para permitir valores negativos
                    eyeSeparation -= 0.01;
                    console.log("Separación de Ojos:", eyeSeparation.toFixed(4));
                    return;
                }
            

            }


            // Comprobación del sintetizador (ahora está después de los controles 3D)
            if (window.alienSynth && window.alienSynth.isKeyInhibited(event.key.toLowerCase())) {
                return;
            }


            // AÑADIDO: Verificamos si estamos en modo órbita
            if (isOrbitingNebula) {
                
                // --- Lógica de controles MIENTRAS se está en órbita ---
                const orbitSpeedIncrement = 0.002; // Velocidad de movimiento en la órbita
                const distanceChangeSpeed = 0.8;   // Velocidad para acercarse/alejarse

                switch (event.code) {
                    case 'KeyW':
                        orbitDistance -= ORBIT_ZOOM_SPEED;
                        // Añadimos los límites para que no se acerque o aleje infinitamente
                        orbitDistance = Math.max(MIN_ORBIT_DISTANCE, Math.min(MAX_ORBIT_DISTANCE, orbitDistance));
                        break;
                    case 'KeyS':
                        orbitDistance += ORBIT_ZOOM_SPEED;
                        // Repetimos los mismos límites aquí
                        orbitDistance = Math.max(MIN_ORBIT_DISTANCE, Math.min(MAX_ORBIT_DISTANCE, orbitDistance));
                        break;
                    case 'KeyA':
                        // Aumentamos la velocidad orbital hacia la izquierda
                        playerOrbitSpeed = orbitSpeedIncrement;
                        break;
                    case 'KeyD':
                        // Aumentamos la velocidad orbital hacia la derecha
                        playerOrbitSpeed = -orbitSpeedIncrement;
                        break;
                    case 'Space':
                        // Activamos el hipersalto (que acelerará todo en 'animate')
                        hyperspaceModeActive = true;
                        break;
                    case 'KeyC': // La tecla C para entrar en órbita ya está manejada, la dejamos por si acaso
                        if (event.shiftKey) { 
                            isOrbitingNebula = false;
                            orbitingNebulaInstance = null;
                            if (galaxies[username] && galaxies[username].pixelGalaxy) {
                                galaxies[username].pixelGalaxy.pixelObject.visible = true;
                            }
                        }            
                        break;
                    // Dentro del switch del modo órbita, por ejemplo, después del case 'KeyC'
                    case 'KeyV':
                        cycleViewMode();
                        break;

                    
                    // --- FIN DEL BLOQUE A AÑADIR ---


                    // --- ¡NUEVAS LÍNEAS AQUÍ! ---
                    case 'Digit1': // Tecla '1'
                        if (currentOrbitType !== 'fixed') {
                            console.log("Cambiando a modo de órbita 'fija'.");
                            currentOrbitType = 'fixed';
                            // Opcional: Si quieres que la cámara se reinicie al frente del avatar en modo fijo:
                            // pitchAngle = 0;
                            // yawAngle = avatarObject.rotation.y;
                        }
                        break;
                    case 'Digit2': // Tecla '2'
                        if (currentOrbitType !== 'comet') {
                            console.log("Cambiando a modo de órbita 'cometa'.");
                            currentOrbitType = 'comet';
                        }
                        break;
                    
                        
                        
                }

            } else {
                // --- Lógica de controles en VUELO LIBRE (tu código original) ---
                switch (event.code) {
                    case 'KeyW':
                        if (currentViewMode === 'thirdPerson') { moveBackward = true; } else { moveForward = true; }
                        break;
                    case 'KeyS':
                        if (currentViewMode === 'thirdPerson') { moveForward = true; } else { moveBackward = true; }
                        break;
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'KeyD':
                        moveRight = true;
                        break;
                    case 'KeyZ':
                        moveUp = true;
                        break;
                    case 'KeyX':
                        moveDown = true;
                        break;
                    case 'KeyT':
                        toggleTeleportPanel();
                        break;
                    case 'KeyV':
                        if (!(window.alienSynth && window.alienSynth.isKeyInhibited('p'))) { cycleViewMode(); }
                        break;
                    case 'KeyQ':
                        rotateCameraLeft = true;
                        break;
                    case 'KeyE':
                        rotateCameraRight = true;
                        break;
                    case 'Space':
                        hyperspaceModeActive = true;
                        if (hyperspaceEffect) { hyperspaceEffect.toggleHyperspace(true); }
                        break;
                    case 'KeyC':
                        if (event.shiftKey) {
                            isOrbitingNebula = false;
                            orbitingNebulaInstance = null;
                            if (galaxies[username] && galaxies[username].pixelGalaxy) {
                                galaxies[username].pixelGalaxy.pixelObject.visible = true;
                            }
                        } else {
                            if (!isOrbitingNebula) {
                                const RANGO_DE_INTERACCION_ORBITA = 400;
                                let pulsarMasCercano = null;
                                let distanciaMinima = Infinity;

                                for (const pulsarId in gestorDePulsares.activos) {
                                    const pulsar = gestorDePulsares.activos[pulsarId];
                                    if (!pulsar.nebula.particlesObject.visible) continue;
                                    const distancia = avatarObject.position.distanceTo(pulsar.nebula.particlesObject.position);
                                    if (distancia < distanciaMinima) {
                                        distanciaMinima = distancia;
                                        pulsarMasCercano = pulsar;
                                    }
                                }

                                if (pulsarMasCercano && distanciaMinima < RANGO_DE_INTERACCION_ORBITA) {
                                    console.log("Iniciando órbita alrededor de:", pulsarMasCercano.id);
                                    isOrbitingNebula = true;
                                    orbitingNebulaInstance = pulsarMasCercano;
                                    orbitDistance = distanciaMinima;
                                    
                                    const dirToPulsar = new THREE.Vector3().subVectors(orbitingNebulaInstance.nebula.initialStaticPosition, avatarObject.position);
                                    orbitAngle = Math.atan2(dirToPulsar.z, dirToPulsar.x);

                                    if (galaxies[username] && galaxies[username].pixelGalaxy) {
                                        galaxies[username].pixelGalaxy.pixelObject.visible = false;
                                    }
                                }
                            }
                        }
                        break;
                }
            }
        }
            
        

        // REEMPLAZA TU onKeyUp ENTERA CON ESTA VERSIÓN
            function onKeyUp(event) {
                // Si estamos en órbita, manejamos las teclas de órbita
                if (isOrbitingNebula) {
                    switch (event.code) {
                        case 'KeyA':
                        case 'KeyD':
                            // Al soltar A o D, la velocidad orbital vuelve a cero
                            playerOrbitSpeed = 0.0;
                            break;
                        case 'Space':
                            // Desactivamos el hipersalto
                            hyperspaceModeActive  = false;
                            break;
                    }
                } else {
                    // Lógica de VUELO LIBRE (tu código original)
                    switch (event.code) {
                        case 'KeyW':
                            if (currentViewMode === 'thirdPerson') { moveBackward = false; } else { moveForward = false; }
                            break;
                        case 'KeyS':
                            if (currentViewMode === 'thirdPerson') { moveForward = false; } else { moveBackward = false; }
                            break;
                        case 'KeyA':
                            moveLeft = false;
                            break;
                        case 'KeyD':
                            moveRight = false;
                            break;
                        case 'KeyZ':
                            moveUp = false;
                            break;
                        case 'KeyX':
                            moveDown = false;
                            break;
                        case 'KeyQ':
                            rotateCameraLeft = false;
                            break;
                        case 'KeyE':
                            rotateCameraRight = false;
                            break;
                        case 'Space':
                            hyperspaceModeActive = false;
                            if (hyperspaceEffect) { hyperspaceEffect.toggleHyperspace(false); }
                            break;
                    }
                }
            }
        
        // MEJORADO: Control del mouse para mejor navegación
        function onMouseDown(event) {
            console.log("--- INICIO DEL CLIC ---"); // Chivato 1: Para saber que la función se ejecuta.

            if (audioContext && audioContext.state === 'suspended') {
           audioContext.resume();
    }
                // Mantenemos las verificaciones de siempre
            if (isTouchDevice && joystickActive) return;
            if (isTouchDevice && isDragging && touchIdentifierCamera !== null) return;
            if (isClickOnMenu(event)) return;
            if (event.button !== 0) return;

            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };

            // --- LÓGICA DE DETECCIÓN CORRECTA ---
            mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
            mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.layers.set(CLICKABLE_LAYER); // <-- AÑADE ESTA LÍNEA

            raycaster.setFromCamera(mousePosition, camera);

            // 1. Creamos la lista de blancos buscando en gestorDePulsares.activos
            const clickableTargets = [];
            for (const pulsarId in gestorDePulsares.activos) {
                const pulsar = gestorDePulsares.activos[pulsarId];
                // Asegurarnos de que el pulsar y su blanco invisible existan
                if (pulsar && pulsar.nebula && pulsar.nebula.nebulaClickTarget) {
                    clickableTargets.push(pulsar.nebula.nebulaClickTarget);
                }
            }

            // Chivato 2: Para saber cuántos púlsares está intentando detectar.
             console.log("Púlsares encontrados para hacer clic:", clickableTargets.length);


            // Si hay blancos que comprobar, lanzamos el rayo
            if (clickableTargets.length > 0) {
                const intersects = raycaster.intersectObjects(clickableTargets);

                if (intersects.length > 0) {
                    console.log("¡ÉXITO! El rayo ha chocado con un objeto:", intersects[0].object);

                    // ¡Click sobre un púlsar!
                    const clickedTarget = intersects[0].object;
                    // Usamos la referencia que guardamos para saber qué púlsar es
                    draggedPulsar = clickedTarget.parentNebula;

                    if (draggedPulsar) {
                                        // Chivato 4: Confirma que hemos "agarrado" el púlsar.
                        console.log("Púlsar 'agarrado' exitosamente:", draggedPulsar);

                        draggedPulsar.isBeingDragged = true;
                        draggedPulsar.momentumVelocity.set(0, 0, 0);
                    }
        } else {
            console.log("FALLO: El rayo fue lanzado, pero no chocó con ningún blanco.");
        }
    } else {
        console.log("AVISO: No hay púlsares activos en la lista de clicables.");
    }
     console.log("--- FIN DEL CLIC ---");
}
        
        function isClickOnMenu(event) {
            // Verificar si el clic fue dentro del menú de configuración
            const settingsMenu = document.getElementById('settingsMenu');
            if (settingsMenu.style.display === 'block') {
                const rect = settingsMenu.getBoundingClientRect();
                if (event.clientX >= rect.left && event.clientX <= rect.right &&
                    event.clientY >= rect.top && event.clientY <= rect.bottom) {
                    return true;
                }
            }
            return false;
        }
        
        function onMouseUp(event) {
            // Verificaciones para controles táctiles
            if (isTouchDevice && joystickActive) return;
            if (isTouchDevice && isDragging && touchIdentifierCamera !== null) return;

            // Lógica para soltar el púlsar
            if (draggedPulsar) {
                draggedPulsar.isBeingDragged = false;
                draggedPulsar = null;
            }

            // Desactivamos el arrastre general
            isDragging = false;
        }
        
        function onMouseMove(event) {
            // Mantenemos las verificaciones para dispositivos táctiles
            if (isTouchDevice && (joystickActive || touchIdentifierCamera !== null)) return;

            // Solo hacemos algo si el botón del ratón está presionado
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                if (isOrbitingNebula) {
                // --- ¡REEMPLAZA ESTE BLOQUE COMPLETO! ---
                if (currentOrbitType === 'fixed') {
                    // MODO FIJO: El ratón controla la rotación de la CÁMARA
                    yawAngle -= deltaX * mouseSensitivity;
                    pitchAngle -= deltaY * mouseSensitivity * 0.5;
                    pitchAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchAngle));
                    // Nota: Aquí NO se actualiza avatarObject.rotation.y, ya que el avatar
                    // se mantiene mirando al centro del púlsar en este modo, y la cámara
                    // rota independientemente.
            } else { // currentOrbitType === 'comet'
                // MODO COMETA: El ratón controla directamente el ÁNGULO de la ÓRBITA
                const orbitMouseSensitivity = 0.005;
                orbitAngle -= deltaX * orbitMouseSensitivity;
            }
            // --- FIN DEL REEMPLAZO ---


                } else {
                    // --- MODO VUELO LIBRE: El comportamiento se mantiene como lo tenías ---
                    yawAngle -= deltaX * mouseSensitivity;
                    pitchAngle -= deltaY * mouseSensitivity * 0.5;
                    pitchAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchAngle));
                    avatarObject.rotation.y = yawAngle;
                }

                // Actualizamos la posición previa del ratón para el siguiente fotograma
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }

            // Actualizamos la posición de la cámara solo en vuelo libre,
            // ya que en modo órbita se calcula dentro de animate().
            if (!isOrbitingNebula) {
                updateCameraPosition();
            }
        }





        
        function onMouseWheel(event) {
            const zoomSpeed = 0.5;
            const delta = Math.sign(event.deltaY) * zoomSpeed;
            
            // AÑADIDO: Si estamos orbitando, la rueda cambia la distancia de la órbita
            if (isOrbitingNebula) {
                orbitDistance += delta * 5; // Aumentamos el multiplicador para que se sienta más rápido
                // Añadimos límites para no alejarse o acercarse demasiado
                orbitDistance = Math.max(MIN_ORBIT_DISTANCE, Math.min(MAX_ORBIT_DISTANCE, orbitDistance));
            } else {
                // Lógica de VUELO LIBRE (tu código original)
                if (currentViewMode === 'thirdPerson') {
                    cameraOffset.z += delta;
                    cameraOffset.z = Math.max(5, Math.min(30, cameraOffset.z));
                } else if (currentViewMode === 'birdEye') {
                    cameraOffset.y += delta;
                    cameraOffset.y = Math.max(10, Math.min(50, cameraOffset.y));
                }
            }

            // Ya no llamamos a updateCameraPosition() aquí, se maneja en el bucle animate
        }

        
        function updateCameraPosition() {
            switch (currentViewMode) {
                case 'firstPerson':
                    // Primera persona: cámara en la posición del avatar
                    camera.position.copy(avatarObject.position);
                    camera.position.y += 1.7; // Altura de los ojos
                    
                    // Mirar en la dirección que apunta el avatar con inclinación
                    camera.quaternion.setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    break;
                    
                case 'thirdPerson':
                    // Tercera persona: cámara detrás y arriba del avatar
                    const offsetVector = new THREE.Vector3(
                        -Math.sin(yawAngle) * Math.cos(pitchAngle) * cameraOffset.z,
                        cameraOffset.y + Math.sin(pitchAngle) * cameraOffset.z,
                        -Math.cos(yawAngle) * Math.cos(pitchAngle) * cameraOffset.z
                    );
                    
                    camera.position.copy(avatarObject.position).add(offsetVector);
                    
                    // Mirar hacia el avatar con inclinación
                    cameraTarget.copy(avatarObject.position);
                    cameraTarget.y += 1; // Mirar un poco arriba del centro del avatar
                    camera.lookAt(cameraTarget);
                    break;
                    
                case 'birdEye':
                    // MODIFICADO: Vista de pájaro con soporte para rotación
                    // Posicionar la cámara en alto sobre el avatar pero permitiendo rotación
                    const birdEyeHeight = cameraOffset.y;
                    const birdEyeRadius = cameraOffset.z * 0.5; // Reducido para estar más centrado
                    
                    // Usar la rotación horizontal (yawAngle) para girar alrededor del avatar
                    camera.position.copy(avatarObject.position);
                    camera.position.y += birdEyeHeight;
                    camera.position.x += Math.sin(yawAngle) * birdEyeRadius;
                    camera.position.z += Math.cos(yawAngle) * birdEyeRadius;
                    
                    // Usar pitchAngle para ajustar la inclinación (limitada para vista de pájaro)
                    const birdEyePitch = Math.max(-Math.PI/2, Math.min(-Math.PI/6, pitchAngle));
                    
                    // Calcular el punto de mira con base en la rotación
                    cameraTarget.copy(avatarObject.position);
                    // Ajustar el punto de mira para que mire "adelante" del avatar según la rotación
                    cameraTarget.x += Math.sin(yawAngle) * 5 * Math.sin(birdEyePitch + Math.PI/2);
                    cameraTarget.z += Math.cos(yawAngle) * 5 * Math.sin(birdEyePitch + Math.PI/2);
                    // Ajustar altura del punto de mira según inclinación
                    cameraTarget.y += Math.cos(birdEyePitch + Math.PI/2) * 5;
                    
                    camera.lookAt(cameraTarget);
                    break;
            }
        }


        
        function cycleViewMode() {
            switch (currentViewMode) {
                case 'firstPerson':
                    setViewMode('thirdPerson');
                    break;
                case 'thirdPerson':
                    setViewMode('birdEye');
                    break;
                case 'birdEye':
                    setViewMode('firstPerson');
                    break;
            }
        }
        
        function setViewMode(mode) {
            currentViewMode = mode;
            
            switch (mode) {
                case 'firstPerson':
                    avatarObject.visible = false;
                    // No reset pitchAngle
                    break;
                case 'thirdPerson':
                    avatarObject.visible = true;
                    cameraOffset.set(0, 10, 20);
                    // No reset pitchAngle
                    break;
                case 'birdEye':
                    avatarObject.visible = true;
                    cameraOffset.set(0, 30, 5);
                    // Ajustar pitchAngle para vista de pájaro (mira hacia abajo)
                    pitchAngle = -Math.PI/3; // Aproximadamente -60 grados
            break;
    }
    
    updateCameraPosition();
}
        // AÑADIR ESTA NUEVA FUNCIÓN PARA EL RADAR
        // -------------------------------------------------------------------
        function updateNebulaRadar() {
            if (!nebulaRadarElement) return;

            // El radar apuntará al pulsar que orbitamos, o si no, al que está sonando.
            const targetPulsar = orbitingNebulaInstance || gestorDePulsares.pulsarAudible;

            if (!targetPulsar) {
                if(radarArrowElement) radarArrowElement.style.opacity = '0';
                if(radarDotElement) radarDotElement.style.opacity = '0';
                return;
            }

            // El resto de la función es igual, pero ahora usa 'targetPulsar'
            const radarRadius = nebulaRadarElement.offsetWidth / 2;
            const dotRadius = radarDotElement.offsetWidth / 2;
            const nebulaPos = targetPulsar.nebula.initialStaticPosition;
            const nebulaDirWorld = new THREE.Vector3().subVectors(nebulaPos, avatarObject.position);
            const cameraInverseMatrix = new THREE.Matrix4().copy(camera.matrixWorldInverse);
            const nebulaDirCameraSpace = nebulaDirWorld.clone().applyMatrix4(cameraInverseMatrix);
            const angleToTarget = Math.atan2(nebulaDirCameraSpace.x, -nebulaDirCameraSpace.z);

            radarArrowElement.style.opacity = '1';
            radarArrowElement.style.transform = `rotate(${angleToTarget}rad)`;
            
            const distOnRadarPlane = Math.sqrt(nebulaDirCameraSpace.x * nebulaDirCameraSpace.x + nebulaDirCameraSpace.z * nebulaDirCameraSpace.z);
            const maxDistForDotInside = radarRadius - dotRadius - 2;

            let dotX, dotY;
            if (nebulaDirCameraSpace.z > 0 || distOnRadarPlane > maxDistForDotInside * 1.5) {
                dotX = Math.sin(angleToTarget) * maxDistForDotInside;
                dotY = -Math.cos(angleToTarget) * maxDistForDotInside;
                radarDotElement.style.opacity = '0.8';
            } else {
                const screenX = (nebulaDirCameraSpace.x / -nebulaDirCameraSpace.z) * radarRadius * 1.2;
                const screenY = (nebulaDirCameraSpace.y / -nebulaDirCameraSpace.z) * radarRadius * 1.2;
                const distFromCenter = Math.sqrt(screenX * screenX + screenY * screenY);
                if (distFromCenter > maxDistForDotInside) {
                    const scale = maxDistForDotInside / distFromCenter;
                    dotX = screenX * scale;
                    dotY = screenY * scale;
                } else {
                    dotX = screenX;
                    dotY = screenY;
                }
                radarDotElement.style.opacity = '1';
            }
            radarDotElement.style.transform = `translate(${dotX}px, ${dotY}px)`;
        }


        function gestionarAudioYAnimacionPulsares(deltaTime) {
            const RANGO_DE_VISIBILIDAD = 4000;
            const FADE_DURATION = 1500;
            const time = Date.now() * 0.001; // ¡NUEVO! Variable de tiempo para la animación

            let pulsarMasCercanoAudible = null;
            let distanciaMinima = Infinity;

            // --- PRIMERA PASADA: GESTIONAR ESTADOS Y ENCONTRAR CANDIDATO ---
            for (const pulsarId in gestorDePulsares.activos) {
                const pulsar = gestorDePulsares.activos[pulsarId];
                if (!pulsar || !pulsar.nebula) continue;

                // ¡NUEVO! Actualizamos la posición orbital del púlsar en cada fotograma
                pulsar.nebula.updateOrbitalPosition(time);

                // ¡CAMBIO! La distancia ahora se calcula a la posición dinámica actual
                const distancia = avatarObject.position.distanceTo(pulsar.nebula.particlesObject.position);

                if (distancia > gestorDePulsares.zonaDeCarga) {
                    if (pulsar.isLoaded) {
                        pulsar.tiempoGuardado = pulsar.audio.currentTime;
                        pulsar.audio.pause();
                        pulsar.audio.src = '';
                        pulsar.isLoaded = false;
                        pulsar.isPlaying = false;
                    }
                    pulsar.nebula.particlesObject.visible = (distancia <= RANGO_DE_VISIBILIDAD);
                    continue;
                }
                
                pulsar.nebula.particlesObject.visible = true;

                if (!pulsar.isLoaded) {
                    pulsar.audio.src = pulsar.url;

                    try {
                        if (!pulsar.positionalAudio) {
                            pulsar.positionalAudio = new THREE.PositionalAudio(audioListener);
                        }
                        pulsar.positionalAudio.setRefDistance(40);
                        pulsar.positionalAudio.setRolloffFactor(1.0);
                        pulsar.positionalAudio.setMaxDistance(3000);

                        const preAmpGain = audioListener.context.createGain();
                        preAmpGain.gain.setValueAtTime(pulsarVolumeMultiplier, audioListener.context.currentTime);
                        pulsar.preAmpGain = preAmpGain; // <-- AÑADE ESTA LÍNEA

                        if (!pulsar.mediaSource) {
                            pulsar.mediaSource = audioListener.context.createMediaElementSource(pulsar.audio);
                        }
                        
                        pulsar.mediaSource.disconnect();
                        pulsar.mediaSource.connect(preAmpGain);
                        preAmpGain.connect(pulsar.analyser);
                        pulsar.positionalAudio.setNodeSource(pulsar.analyser);

                    } catch (e) {
                        console.error("Error al configurar la cadena de audio:", e);
                    }
                    
                    pulsar.isLoaded = true;
                }
                
                let freqData = new Uint8Array(pulsar.analyser.frequencyBinCount);
                if (pulsar.isLoaded) pulsar.analyser.getByteFrequencyData(freqData);
                pulsar.nebula.update(freqData, new Uint8Array(pulsar.analyser.fftSize), deltaTime);

                if (distancia <= gestorDePulsares.zonaAudible) {
                    if (distancia < distanciaMinima) {
                        distanciaMinima = distancia;
                        pulsarMasCercanoAudible = pulsar;
                    }
                }
            }

            // --- SEGUNDA PASADA: APLICAR REGLA DEL "ÚNICO SONIDO" CON FADES ---
            if (gestorDePulsares.pulsarAudible !== pulsarMasCercanoAudible) {
                if (gestorDePulsares.pulsarAudible) {
                    const pulsarAnterior = gestorDePulsares.pulsarAudible;
                    pulsarAnterior.tiempoGuardado = pulsarAnterior.audio.currentTime;
                    fadeOutAudio(pulsarAnterior.audio, FADE_DURATION);
                    pulsarAnterior.isPlaying = false;
                }

                if (pulsarMasCercanoAudible) {
                    if (pulsarMasCercanoAudible.tiempoGuardado > 0) {
                        pulsarMasCercanoAudible.audio.currentTime = pulsarMasCercanoAudible.tiempoGuardado;
                    }
                    pulsarMasCercanoAudible.audio.play().catch(e => console.error("Error al reproducir:", e));
                    fadeInAudio(pulsarMasCercanoAudible.audio, FADE_DURATION, 1.0);
                    pulsarMasCercanoAudible.isPlaying = true;
                }
                
                gestorDePulsares.pulsarAudible = pulsarMasCercanoAudible;
            }
        }

        // hasta aqui perfecto andrés

        // --- NUEVAS FUNCIONES PARA FADE-IN Y FADE-OUT DE AUDIO ---

        /**
         * Aumenta gradualmente el volumen de un elemento de audio.
         * @param {HTMLAudioElement} audioElement - El elemento de audio a modificar.
         * @param {number} duration - La duración del fade en milisegundos.
         * @param {number} targetVolume - El volumen final (entre 0.0 y 1.0).
         */
         function fadeInAudio(audioElement, duration, targetVolume) {
            // Si ya hay un fade en curso, lo cancelamos para empezar uno nuevo.
            if (audioElement.fadeInterval) {
                clearInterval(audioElement.fadeInterval);
            }

            audioElement.volume = 0;
            const stepTime = 50; // ms por cada paso de volumen
            const volumeStep = targetVolume / (duration / stepTime);

            audioElement.fadeInterval = setInterval(() => {
                if (audioElement.volume < targetVolume) {
                    audioElement.volume = Math.min(targetVolume, audioElement.volume + volumeStep);
                } else {
                    audioElement.volume = targetVolume;
                    clearInterval(audioElement.fadeInterval);
                    audioElement.fadeInterval = null;
                }
            }, stepTime);
        }

        /**
         * Disminuye gradualmente el volumen de un elemento de audio y lo pausa al final.
         * @param {HTMLAudioElement} audioElement - El elemento de audio a modificar.
         * @param {number} duration - La duración del fade en milisegundos.
         */
        function fadeOutAudio(audioElement, duration) {
            // Si ya hay un fade en curso, lo cancelamos.
            if (audioElement.fadeInterval) {
                clearInterval(audioElement.fadeInterval);
            }

            const initialVolume = audioElement.volume;
            const stepTime = 50; // ms por cada paso
            const volumeStep = initialVolume / (duration / stepTime);

            audioElement.fadeInterval = setInterval(() => {
                if (audioElement.volume > 0) {
                    audioElement.volume = Math.max(0, audioElement.volume - volumeStep);
                } else {
                    audioElement.volume = 0;
                    clearInterval(audioElement.fadeInterval);
                    audioElement.fadeInterval = null;
                    audioElement.pause(); // Pausamos el audio solo cuando el volumen llega a cero.
                }
            }, stepTime);
        }

        function resetStereoStateToNormal() {
            const w = window.innerWidth, h = window.innerHeight;
            renderer.setScissorTest(false);
            renderer.setViewport(0, 0, w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            }

// -------------------------------------------------------------------                  
        // CORRECCIÓN EN LA FUNCIÓN ANIMATE PARA ASEGURAR UNA ANIMACIÓN FLUIDA
        // REEMPLAZAR TU FUNCIÓN ANIMATE ACTUAL POR ESTA VERSIÓN COMPLETA
        // -------------------------------------------------------------------
        // REEMPLAZA TU animate ENTERA CON ESTA VERSIÓN
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // El cálculo de velocidad y dirección se queda como lo tienes
            const speed = 0.2;
            const direction = new THREE.Vector3(-Math.sin(yawAngle), 0, -Math.cos(yawAngle));
            let currentSpeedFactor = 1.0;
            // El efecto visual de hipersalto solo en vuelo libre o en modo cometa
            if (hyperspaceEffect && (hyperspaceModeActive || currentOrbitType === 'comet')) {
                currentSpeedFactor = hyperspaceEffect.update(direction);
            }

            const adjustedSpeed = speed * currentSpeedFactor;

            // --- LÓGICA DE CONTROL PRINCIPAL: ÓRBITA VS. VUELO LIBRE ---
            if (isOrbitingNebula && orbitingNebulaInstance) {
                // Si estamos orbitando un púlsar
                const targetPulsarPos = orbitingNebulaInstance.nebula.particlesObject.position; // Usar la posición dinámica del púlsar

                if (currentOrbitType === 'fixed') {
                    // --- MODO ÓRBITA FIJA (el antiguo, con cámara libre) ---

            // 1. El avatar se posiciona en el círculo de órbita
            const newAvatarX = targetPulsarPos.x + orbitDistance * Math.cos(orbitAngle);
            const newAvatarZ = targetPulsarPos.z + orbitDistance * Math.sin(orbitAngle);
            // Suavizamos el movimiento del avatar hacia la posición orbital deseada
            avatarObject.position.lerp(new THREE.Vector3(newAvatarX, avatarObject.position.y, newAvatarZ), 0.05);

            // 2. El avatar SIEMPRE mira al púlsar en este modo
            avatarObject.lookAt(targetPulsarPos);

            // 3. La órbita avanza lentamente por sí misma (ORBIT_SPEED)
            // y se ajusta con A/D (playerOrbitSpeed)
            orbitAngle += (ORBIT_SPEED + playerOrbitSpeed) * deltaTime * 100 * (hyperspaceModeActive ? 8.0 : 1.0);

            // 4. Permitir rotación de la cámara con Q/E en modo fijo
            if (rotateCameraLeft) { yawAngle -= cameraRotationSpeed; }
            if (rotateCameraRight) { yawAngle += cameraRotationSpeed; }

            // --- LÓGICA DE CÁMARA ESPECÍFICA PARA MODO ÓRBITA FIJA ---
            // La cámara se posiciona relativa al avatar, pero su rotación es independiente
            switch (currentViewMode) {
                case 'firstPerson':
                    camera.position.copy(avatarObject.position);
                    camera.position.y += 1.7; // Altura de los ojos
                    camera.quaternion.setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    break;

                case 'thirdPerson':
                    // Calcular offset de la cámara basado en yawAngle (rotación horizontal) y pitchAngle (inclinación vertical)
                    // Esto recrea el efecto de "inercia" al mover el ratón o con Q/E
                    const tempQuaternionThird = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    // El offset se aplica en la dirección de la cámara, no del avatar
                    const offsetVectorThird = new THREE.Vector3(0, cameraOffset.y, cameraOffset.z).applyQuaternion(tempQuaternionThird);
                    camera.position.copy(avatarObject.position).add(offsetVectorThird);
                    camera.quaternion.copy(tempQuaternionThird); // La cámara mira en la dirección de yaw/pitch
                    break;

                case 'birdEye':
                    // Calcular offset de la cámara basado en yawAngle y pitchAngle
                    const tempQuaternionBird = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    // El offset se aplica en la dirección de la cámara
                    const birdEyeOffset = new THREE.Vector3(0, cameraOffset.y, cameraOffset.z * 0.5).applyQuaternion(tempQuaternionBird); // cameraOffset.z * 0.5 para estar más centrado
                    camera.position.copy(avatarObject.position).add(birdEyeOffset);
                    camera.quaternion.copy(tempQuaternionBird); // La cámara mira en la dirección de yaw/pitch
                    break;
            }

            // Asegúrate de que el efecto de hipersalto se desactive en este modo si estaba activo
            if (hyperspaceEffect) {
                hyperspaceEffect.toggleHyperspace(false); // Desactivar si se estaba usando en modo cometa
            }

        } else { // currentOrbitType === 'comet'
            // --- MODO ÓRBITA COMETA (el nuevo, el que te gusta) ---

            // 1. Aplicar controles de jugador a la órbita
            const hyperspaceOrbitFactor = hyperspaceModeActive ? 8.0 : 1.0;
            orbitAngle += (ORBIT_SPEED + playerOrbitSpeed) * deltaTime * 100 * hyperspaceOrbitFactor;

            // Limitar la distancia de la órbita para seguridad
            orbitDistance = Math.max(MIN_ORBIT_DISTANCE, Math.min(MAX_ORBIT_DISTANCE, orbitDistance));

            // 2. Calcular la nueva posición del AVATAR (con lerp para suavizar)
            const newAvatarX = targetPulsarPos.x + orbitDistance * Math.cos(orbitAngle);
            const newAvatarZ = targetPulsarPos.z + orbitDistance * Math.sin(orbitAngle);
            avatarObject.position.lerp(new THREE.Vector3(newAvatarX, avatarObject.position.y, newAvatarZ), 0.05);

            // 3. El avatar siempre mira al púlsar en este modo
            avatarObject.lookAt(targetPulsarPos);

            // 4. Lógica de CÁMARA ORBITAL MANUAL (para que siempre mire al púlsar)
            // La cámara se posiciona para mirar al púlsar desde la perspectiva del avatar.
            switch (currentViewMode) {
                case 'firstPerson':
                    camera.position.copy(avatarObject.position);
                    camera.position.y += 1.7; // Altura de los ojos
                    camera.lookAt(targetPulsarPos);
                    break;

                case 'thirdPerson':
                    const dirToAvatar = new THREE.Vector3().subVectors(avatarObject.position, targetPulsarPos).normalize();
                    const offsetBehind = dirToAvatar.multiplyScalar(cameraOffset.z);
                    camera.position.copy(avatarObject.position).add(offsetBehind);
                    camera.position.y += cameraOffset.y / 2;
                    camera.lookAt(targetPulsarPos);
                    break;

                case 'birdEye':
                    camera.position.copy(avatarObject.position);
                    camera.position.y += cameraOffset.y;
                    camera.lookAt(targetPulsarPos);
                    break;
            }
            // Asegúrate de que el efecto de hipersalto esté activo si corresponde
            if (hyperspaceEffect) {
                hyperspaceEffect.update(avatarObject.getWorldDirection(new THREE.Vector3()));
            }
        }
    } else {
        // --- MODO VUELO LIBRE (tu código original) ---
        const frontVector = direction.clone().normalize().multiplyScalar(adjustedSpeed);
        const rightVector = new THREE.Vector3(frontVector.z, 0, -frontVector.x);

        if (moveForward) avatarObject.position.add(frontVector);
        if (moveBackward) avatarObject.position.sub(frontVector);
        if (moveLeft) avatarObject.position.sub(rightVector);
        if (moveRight) avatarObject.position.add(rightVector);
        if (moveUp) avatarObject.position.y += adjustedSpeed;
        if (moveDown) avatarObject.position.y -= adjustedSpeed;

        // En vuelo libre, Q y E rotan el yawAngle del avatar
        if (rotateCameraLeft) { yawAngle -= cameraRotationSpeed; }
        if (rotateCameraRight) { yawAngle += cameraRotationSpeed; }

        // La cámara sigue al avatar normalmente
        updateCameraPosition();

        // Asegúrate de que el efecto de hipersalto esté activo si corresponde en vuelo libre
        if (hyperspaceEffect) {
            hyperspaceEffect.update(avatarObject.getWorldDirection(new THREE.Vector3()));
        }
    }

            // --- El resto de tus funciones de actualización ---
            updateCoordinatesDisplay();
            gestionarAudioYAnimacionPulsares(deltaTime);
            handlePlaylistFade(); // <--- AÑADE ESTA LLAMADA

            updateNebulaRadar();

            // Actualizamos TODAS las galaxias
            for (const id in galaxies) {
                if (id === username) {
                    // Esta es nuestra galaxia, la movemos con el avatar
                    galaxies[id].updatePosition(avatarObject.position.clone());
                }

                // Llamamos a .update() para TODAS, para que se animen
                // y la galaxia de los otros jugadores se mueva.
                const galaxy = galaxies[id];
                if (galaxy && typeof galaxy.update === 'function') {
                    galaxy.update();
                }
            }

            // --- INICIO DEL BLOQUE A AÑADIR ---
            // Actualizamos TODAS las galaxias (local y remotas)
            for (const id in galaxies) {
                const galaxy = galaxies[id];
                if (galaxy) {
                    // La posición ya se actualiza a través de 'updatePosition'
                    // cuando llega un mensaje 'move' del servidor (para remotos)
                    // o directamente aquí para el local.

                    if (id === username) {
                        // Actualizamos la posición de NUESTRA galaxia local
                        galaxy.updatePosition(avatarObject.position.clone());
                    } else {
                    // --- INICIO INTERPOLACIÓN PARA REMOTOS ---
                    if (galaxy.avatarMesh && !galaxy.isLocal) {
                   
                        // Mueve suavemente la esfera hacia la última posición recibida
                        galaxy.avatarMesh.position.lerp(galaxy.targetPosition, galaxy.interpolationFactor);

                        // Mueve las partículas junto con la esfera interpolada
                        if (galaxy.pixelGalaxy && galaxy.pixelGalaxy.pixelObject) {
                        galaxy.pixelGalaxy.pixelObject.position.copy(galaxy.avatarMesh.position);
                        }
                        // También podrías interpolar la rotación aquí (galaxy.avatarMesh.quaternion.slerp)
                    }
                    // --- FIN INTERPOLACIÓN ---
                    }

                    // Llamamos a .update() para TODAS para animar las partículas
                    galaxy.update();
                }
            }
            // --- FIN DEL BLOQUE A AÑADIR ---

            if (proceduralGenerator) {
                proceduralGenerator.update(avatarObject.position);
            }

            updatableSpecialFeatures.forEach(feature => {
                if (feature && typeof feature.update === 'function') {
                    feature.update(deltaTime);
                }
            });

            renderer.render(scene, camera);
            // --- LÓGICA DE RENDERIZADO (NORMAL O ESTÉREO MANUAL) ---
            if (isStereoMode) {
                const width = window.innerWidth;
                const height = window.innerHeight;

                if (isStereoMode) {
                    renderer.setScissorTest(true);

                    // 1. Ajustamos la cámara UNA SOLA VEZ para las vistas estrechas
                    camera.aspect = (width / 2) / height;
                    camera.updateProjectionMatrix();

                    // --- VISTA DERECHA (para ojo izquierdo en cross-eye) ---
                    camera.position.x += eyeSeparation / 2;
                    renderer.setScissor(0, 0, width / 2, height);
                    renderer.setViewport(0, 0, width / 2, height);
                    renderer.render(scene, camera);
                    camera.position.x -= eyeSeparation / 2; // Reset

                    // --- VISTA IZQUIERDA (para ojo derecho en cross-eye) ---
                    camera.position.x -= eyeSeparation / 2;
                    renderer.setScissor(width / 2, 0, width / 2, height);
                    renderer.setViewport(width / 2, 0, width / 2, height);
                    renderer.render(scene, camera);
                    camera.position.x += eyeSeparation / 2; // Reset

                    renderer.setScissorTest(false);

                } else {
                    // 2. Nos aseguramos de que la cámara tenga el aspect ratio correcto en modo normal
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();

                    renderer.setViewport(0, 0, width, height);
                    renderer.render(scene, camera);
                }
            }


        }

        
        function updateCoordinatesDisplay() {
            const x = avatarObject.position.x.toFixed(2);
            const y = avatarObject.position.y.toFixed(2);
            const z = avatarObject.position.z.toFixed(2);
            coordsElement.textContent = `X: ${x}, Y: ${y}, Z: ${z}`;
        }
        
        function updateTeleportCoords() {
            document.getElementById('teleportX').value = avatarObject.position.x.toFixed(2);
            document.getElementById('teleportY').value = avatarObject.position.y.toFixed(2);
            document.getElementById('teleportZ').value = avatarObject.position.z.toFixed(2);
        }
        
        function toggleTeleportPanel() {
            const panel = document.getElementById('teleportPanel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                updateTeleportCoords();
            }
        }
        
        function teleportToCoords() {
            const x = parseFloat(document.getElementById('teleportX').value);
            const y = parseFloat(document.getElementById('teleportY').value);
            const z = parseFloat(document.getElementById('teleportZ').value);
            
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                avatarObject.position.set(x, y, z);
                updateCameraPosition();
                document.getElementById('teleportPanel').style.display = 'none';
            }
        }

        function toggleSettingsMenu() {
            const menu = document.getElementById('settingsMenu');
            if (menu.style.display === 'block') {
                menu.style.display = 'none';
            } else {
                menu.style.display = 'block';
            }
        }

        
        function connectToNetwork() {
            // --- ¡AÑADE ESTE BLOQUE AL INICIO! ---
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
                console.log('AudioContext REANUDADO por el botón Conectar.');
            }
            // --- FIN DEL BLOQUE AÑADIDO ---
            const oldUsername = username; // <--- AÑADIR ESTA LÍNEA
            // Obtenemos el nombre de usuario del input
            const newUsername = document.getElementById('usernameInput').value.trim();
            if (newUsername) {
                username = newUsername;
            }
            // <--- INICIO DEL BLOQUE NUEVO (AÑADIR TODO ESTO) ---
            if (oldUsername !== username && galaxies[oldUsername]) {
                console.log(`Cambiando nombre de galaxia local de ${oldUsername} a ${username}`);
                
                galaxies[username] = galaxies[oldUsername]; 
                galaxies[username].id = username;           
                delete galaxies[oldUsername];             
            }
            // <--- FIN DEL BLOQUE NUEVO ---

            console.log(`Intentando conectar a ws://localhost:8080 como ${username}`);

            // Conectamos al servidor local que creamos
            socket = new WebSocket('wss://musicosmosonline.onrender.com');

            // ---- Definimos los "oyentes" del socket ----

            // 1. Cuando la conexión se abre
            socket.onopen = () => {
                console.log('¡Conectado al servidor de Musicosmos!');
                document.getElementById('connectButton').textContent = 'Conectado';
                document.getElementById('connectButton').disabled = true;

                // Empezamos a enviar nuestra posición 10 veces por segundo
                setInterval(sendPosition, 50);
            };

            // 2. Cuando recibimos un mensaje del servidor
            socket.onmessage = (event) => {
                    
                // --- AÑADE ESTAS LÍNEAS ---
                //console.log("<-- RECIBIDO:", event.data); 
                const data = JSON.parse(event.data);
               // console.log("    Data parseada:", data);
               // console.log("    Mi username local:", username);
               // console.log("    Comparando data.id (" + data.id + ") === username (" + username + ") ? ", data.id === username);
                // --- FIN LÍNEAS AÑADIDAS ---TODO BIEN HASTA AQUI!!

                // Ignoramos nuestros propios mensajes (que el servidor nos reenvía)
                if (data.id === username) return; // <-- ¡ESTA ES LA CORRECCIÓN!

                // Si no tenemos una galaxia para este jugador, la creamos
                if (!galaxies[data.id]) {
                    console.log('Nuevo jugador detectado:', data.id);
                    // Creamos una galaxia en una posición inicial (0,0,0), se actualizará en un instante
                    galaxies[data.id] = new Galaxy(data.id, new THREE.Vector3(0, 0, 0), false); // false = es Remoto

                    // Actualizamos la lista de jugadores
                    const container = document.getElementById('playersOnline');
                    const playerItem = document.createElement('div');
                    playerItem.className = 'midi-device-item';
                    playerItem.id = `player-item-${data.id}`;
                    playerItem.textContent = `Jugador ${data.id}`; // Podríamos pasar el username aquí
                    container.appendChild(playerItem);
                }

                // --- ESTE ES EL NÚCLEO ---
                // Actualizamos la galaxia del otro jugador basándonos en el mensaje
                const playerGalaxy = galaxies[data.id];
                if (!playerGalaxy) return;

                switch (data.type) {
                    case 'move': // <--- ¡MOVIDO AQUÍ DENTRO!
                        // Mueve el avatar del otro jugador
                        playerGalaxy.targetPosition.set(data.x, data.y, data.z);
                        // Aquí también podrías actualizar la rotación si la envías
                        break; // <--- ¡IMPORTANTE EL BREAK!
                        case 'note_on':
                        console.log(`%cNOTA RECIBIDA de ${data.id}`, 'color: #00ff00; font-weight: bold;');
                        console.log(`   Nota: ${data.note}, Vel: ${data.velocity}`);

                        const PLAYER_AUDIO_BUBBLE = 200; // Distancia de activación

                        if (!playerGalaxy || !playerGalaxy.avatarMesh) {
                             console.log(`   ERROR: No se encontró la galaxia o el avatar para ${data.id}`);
                             break; // Salir si algo falta
                        }

                        // --- VERIFICACIÓN DE DISTANCIA ---
                        const miPosicion = avatarObject.position;
                        const otraPosicion = playerGalaxy.avatarMesh.position;
                        const distancia = miPosicion.distanceTo(otraPosicion);
                        console.log(`   Mi Pos: X=${miPosicion.x.toFixed(0)}, Z=${miPosicion.z.toFixed(0)}`);
                        console.log(`   Pos de ${data.id}: X=${otraPosicion.x.toFixed(0)}, Z=${otraPosicion.z.toFixed(0)}`);
                        console.log(`   Distancia calculada: ${distancia.toFixed(1)} unidades`);
                        // --- FIN VERIFICACIÓN ---

                        // Aplicar efecto visual siempre
                        playerGalaxy.addNote(data.note, data.velocity);

                        // Comprobar si está dentro de la burbuja de audio
                        if (distancia <= PLAYER_AUDIO_BUBBLE) {
                            console.log(`   ✅ DENTRO de la burbuja (${PLAYER_AUDIO_BUBBLE}u). Reproduciendo audio 3D.`);
                            playerGalaxy.playNote(data.note, data.velocity);
                        } else {
                            console.log(`   ❌ FUERA de la burbuja (${PLAYER_AUDIO_BUBBLE}u). NO se reproduce audio.`);
                            // Opcional: Asegurarnos de detener cualquier nota que pudiera haber quedado sonando
                            // playerGalaxy.stopNote(data.note); // Descomenta si sospechas que las notas no se detienen bien
                        }
                        break; // Fin del case 'note_on'
                    case 'note_off':
                        // --- ¡AÑADE ESTAS LÍNEAS AQUÍ! ---
                        console.log(`%c¡NOTA APAGADA!`, 'color: #ff0000; font-size: 12px;');
                        console.log(`   Jugador: ${data.id}, Nota: ${data.note}`);
                        // --- FIN DE LAS LÍNEAS ---
                        // Apagamos la nota en la galaxia del otro jugador
                        playerGalaxy.removeNote(data.note);
                        playerGalaxy.stopNote(data.note);
                        break;
                    case 'disconnect':
                        // El jugador se fue, eliminamos su galaxia
                        console.log('Jugador desconectado:', data.id);
                        if (playerGalaxy) {
                            playerGalaxy.dispose();
                            delete galaxies[data.id];
                        }
                        const item = document.getElementById(`player-item-${data.id}`);
                        if (item) item.remove();
                        break;
                }
            };

            // 3. Cuando la conexión se cierra
            socket.onclose = () => {
                console.log('Desconectado del servidor.');
                document.getElementById('connectButton').textContent = 'Conectar';
                document.getElementById('connectButton').disabled = false;
            };

            // 4. Si hay un error
            socket.onerror = (error) => {
                console.error('Error de WebSocket:', error);
                document.getElementById('connectButton').textContent = 'Error';
                document.getElementById('connectButton').disabled = false;
            };
        }

        // Nueva función para ENVIAR nuestra posición
        function sendPosition() {
            if (socket && socket.readyState === WebSocket.OPEN && avatarObject) {
                const data = {
                    type: 'move',
                    id: username,
                    x: avatarObject.position.x,
                    y: avatarObject.position.y,
                    z: avatarObject.position.z,
                    yaw: yawAngle,
                    pitch: pitchAngle
                };
                // --- AÑADE ESTA LÍNEA ---
               // console.log("--> ENVIANDO (move):", JSON.stringify(data)); 
                // --- FIN LÍNEA AÑADIDA ---
                socket.send(JSON.stringify(data));
            }
        }

        // Nueva función para ENVIAR nuestras notas
        function sendNote(command, note, velocity) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const data = {
                    type: command, // 'note_on' o 'note_off'
                    id: username, // <-- ¡AÑADE ESTA LÍNEA!
                    note: note,
                    velocity: velocity
                };
               // console.log("--> ENVIANDO (" + command + "):", JSON.stringify(data));
                socket.send(JSON.stringify(data));
            }
        }
        
       
        
        function updatePlayersList() {
            const container = document.getElementById('playersOnline');
            container.innerHTML = '';
            
            const playerCount = Object.keys(otherPlayers).length + 1;
            container.innerHTML = `<p>Jugadores en línea: ${playerCount}</p>`;
            
            const localItem = document.createElement('div');
            localItem.className = 'midi-device-item active';
            localItem.textContent = `${username} (Tú)`;
            container.appendChild(localItem);
            
            for (const playerId in otherPlayers) {
                const playerItem = document.createElement('div');
                playerItem.className = 'midi-device-item';
                playerItem.textContent = playerId;
                container.appendChild(playerItem);
            }
        }

        function initMIDI() {
            if (navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess({ sysex: false })
                    .then(onMIDISuccess, onMIDIFailure);
            } else {
                midiStatusElement.textContent = 'Tu navegador no soporta Web MIDI API';
            }
        }

        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Quitar 'active' de todos los botones y contenidos
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));

                    // Añadir 'active' al botón clickeado y a su contenido correspondiente
                    button.classList.add('active');
                    const targetTabId = button.getAttribute('data-tab');
                    document.getElementById(targetTabId).classList.add('active');
                });
            });
        }

        function onMIDISuccess(access) {
            midiAccess = access;
            midiStatusElement.textContent = 'MIDI conectado. Selecciona dispositivos en la configuración.';
            
            midiAccess.addEventListener('statechange', updateDeviceList);
            
            updateDeviceList();
        }

        function onMIDIFailure(error) {
            midiStatusElement.textContent = `Error al acceder a MIDI: ${error}`;
        }

        function updateDeviceList() {
            if (!midiAccess) return;
            
            const container = document.getElementById('midiDevicesContainer');
            container.innerHTML = '';
            
            let deviceCount = 0;
            
            midiAccess.inputs.forEach(input => {
                deviceCount++;
                
                const deviceItem = document.createElement('div');
                deviceItem.className = 'midi-device-item';
                deviceItem.dataset.id = input.id;
                
                const deviceName = document.createElement('span');
                deviceName.textContent = input.name || `Dispositivo ${deviceCount}`;
                deviceItem.appendChild(deviceName);
                
                const toggleBtn = document.createElement('div');
                toggleBtn.className = 'toggle-button';
                if (activeInputs.has(input.id)) {
                    toggleBtn.classList.add('active');
                    deviceItem.classList.add('active');
                }
                deviceItem.appendChild(toggleBtn);
                
                // Mejorado: Manejando separadamente el clic en el dispositivo
                deviceItem.addEventListener('click', function(e) {
                    e.stopPropagation(); // Evita que el clic cierre el menú
                    toggleMIDIInput(input.id);
                    toggleBtn.classList.toggle('active');
                    deviceItem.classList.toggle('active');
                });
                
                container.appendChild(deviceItem);
            });
            
            if (deviceCount === 0) {
                container.innerHTML = '<p>No se encontraron dispositivos MIDI</p>';
            }
            
            midiStatusElement.textContent = `${deviceCount} dispositivo(s) MIDI encontrado(s). ${activeInputs.size} activo(s).`;
        }
        
        function toggleMIDIInput(inputId) {
            const input = midiAccess.inputs.get(inputId);
            
            if (activeInputs.has(inputId)) {
                input.removeEventListener('midimessage', onMIDIMessage);
                activeInputs.delete(inputId);
                console.log(`Dispositivo MIDI desactivado: ${input.name}`);
            } else {
                input.addEventListener('midimessage', onMIDIMessage);
                activeInputs.add(inputId);
                console.log(`Dispositivo MIDI activado: ${input.name}`);
            }
            
            midiStatusElement.textContent = `${midiAccess.inputs.size} dispositivo(s) MIDI encontrado(s). ${activeInputs.size} activo(s).`;
        }

        // Mejora en la función onMIDIMessage para manejar eventos MIDI de manera más robusta
        // Función mejorada para procesar mensajes MIDI
        function onMIDIMessage(event) {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            try {
                const status = event.data[0] & 0xF0; 
                const channel = event.data[0] & 0x0F;
                const data1 = event.data[1];
                const data2 = event.data.length > 2 ? event.data[2] : 0;
                
                // Definir constantes de audio aquí (puedes ajustarlas)
                const attackTime = 0.05;
                const releaseTime = 0.3;
                const waveform = 'sine'; // O la forma de onda que prefieras

                if (status === 0x90 && data2 > 0) {
                    // Note On (tecla presionada)
                    const note = data1;
                    const velocity = data2;
                    
                    if (galaxies[username]) {
                        const galaxy = galaxies[username];

                        // --- INICIO DE LA CORRECCIÓN (AUDIO 3D LOCAL) ---
                        if (galaxy.positionalAudio && !galaxy.activeAudioNotes[note]) {
                            const frequency = midiToFrequency(note);
                            if (!frequency) return; // Salir si la nota no es válida

                            const oscillator = audioContext.createOscillator();
                            oscillator.type = waveform;
                            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

                            const gainNode = audioContext.createGain();
                            const targetVolume = (velocity / 127) * 0.7; // Volumen basado en la velocidad
                            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(targetVolume, audioContext.currentTime + attackTime);

                            oscillator.connect(gainNode);
                            gainNode.connect(galaxy.positionalAudio.gain); // Conectar al audio 3D local
                            oscillator.start();
                            
                            galaxy.activeAudioNotes[note] = { oscillator, gainNode };
                        }
                        // --- FIN DE LA CORRECCIÓN ---

                        // Esto ya lo tenías (visuals y red)
                        galaxy.addNote(note, velocity);
                        sendNote('note_on', note, velocity); 
                        
                        const noteName = getNoteNameFromMIDI(note);
                        midiStatusElement.textContent = `Nota: ${noteName} (${note}), Velocidad: ${velocity}`;
                        
                        window.lastActiveNote = note;
                        window.lastActiveVelocity = velocity;
                    }
                } 
                else if ((status === 0x80) || (status === 0x90 && data2 === 0)) {
                    // Note Off (tecla liberada)
                    const note = data1;
                    
                    if (galaxies[username]) {
                        const galaxy = galaxies[username];

                        // --- INICIO DE LA CORRECCIÓN (DETENER AUDIO 3D LOCAL) ---
                        if (galaxy.activeAudioNotes[note]) {
                            const { oscillator, gainNode } = galaxy.activeAudioNotes[note];
                            const now = audioContext.currentTime;
                            
                            gainNode.gain.cancelScheduledValues(now);
                            gainNode.gain.setValueAtTime(gainNode.gain.value, now); 
                            gainNode.gain.exponentialRampToValueAtTime(0.001, now + releaseTime); 

                            oscillator.stop(now + releaseTime + 0.05); 

                            setTimeout(() => {
                                try {
                                    oscillator.disconnect();
                                    gainNode.disconnect();
                                } catch(e) { /* Ignorar */ }
                            }, (releaseTime + 0.1) * 1000); 

                            delete galaxy.activeAudioNotes[note];
                        }
                        // --- FIN DE LA CORRECCIÓN ---

                        // Esto ya lo tenías (visuals y red)
                        galaxy.removeNote(note);
                        sendNote('note_off', note, 0);
                        
                        if (note === window.lastActiveNote) {
                            window.lastActiveNote = null;
                        }
                    }
                }
                else if (status === 0xB0) {
                    // Control Change (CC)
                    const controllerNumber = data1;
                    const value = data2;
                    
                    if (controllerNumber === 7 || controllerNumber === 11 || controllerNumber === 1) {
                        processVolumeChange(value);
                    }
                }
            } catch (error) {
                console.error("Error al procesar mensaje MIDI:", error);
            }
        }

        // Añade la función processVolumeChange pero sin redeclarar variables
        function processVolumeChange(value) {
            // Actualizar el volumen actual (usar window para acceder a variable global)
            window.currentMIDIVolume = value;
            
            // Actualizar visualización
            midiStatusElement.textContent = `Volumen: ${value}`;
            
            // Si hay una galaxia activa, actualizar su tamaño basado en el volumen
            if (galaxies[username] && galaxies[username].pixelGalaxy) {
                // Calcular el factor de escala inverso (volumen bajo = galaxia grande)
                const volumeNormalized = value / 127;
                const inversedVolume = 1 - volumeNormalized;
                
                // Aplicar el cambio de volumen a través del factor de escala MIDI
                galaxies[username].pixelGalaxy.midiScaleFactor = 0.6 + inversedVolume * 0.8;
                
                // Ajustar el tamaño objetivo
                galaxies[username].pixelGalaxy.adjustTargetExpansion();
                
                // Si hay una nota activa, actualizar también los efectos visuales
                if (window.lastActiveNote !== null) {
                    // Recrear el efecto visual pero manteniendo la nota y usando el nuevo volumen
                    galaxies[username].pixelGalaxy.pulseCore(window.lastActiveNote, value);
                }
            }
        }

        // Clase mejorada para el sintetizador alienígena
        class AlienSynthKeyboard {
            constructor(listener) { // <-- ¡Argumento añadido!
                // Inicialización de variables de estado
                this.isMinimized = false;
                this.isConfigOpen = false;
                this.isRebinding = false;
                this.selectedKey = null;
                this.baseOctave = 7;
                this.currentOctave = 7;
                this.velocity = 78;
                this.attackTime = 0.05;
                this.releaseTime = 0.3;
                this.currentWaveform = 'sine';
                this.currentRootNote = 0; // C por defecto
                this.currentScale = 'chromatic';
                this.activeKeys = new Set();
                this.activeNotes = {};
                this.inhibitKeyP = false; //
                
                // ++ AÑADE ESTE BLOQUE ++
                // Mapeo de la tecla física a su código de evento (event.code).
                // Lo definimos aquí para que sea accesible por toda la clase.
                this.keyToCode = {
                    't': 'KeyT', 'y': 'KeyY', 'u': 'KeyU', 'i': 'KeyI', 'o': 'KeyO', 'p': 'KeyP', '´': 'Quote', '+': 'BracketRight',
                    'g': 'KeyG', 'h': 'KeyH', 'j': 'KeyJ', 'k': 'KeyK', 'l': 'KeyL', 'ñ': 'Semicolon', '{': 'BracketLeft',
                    'b': 'KeyB', 'n': 'KeyN', 'm': 'KeyM', ',': 'Comma', '.': 'Period', '-': 'Slash'
                }; 
                
                // Cargar configuración guardada o usar valores predeterminados
                this.loadSavedConfig();
                
                // Definiciones de escalas musicales
                this.scales = {
                    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
                    major: [0, 2, 4, 5, 7, 9, 11],
                    minor: [0, 2, 3, 5, 7, 8, 10],
                    pentatonic: [0, 2, 4, 7, 9],
                    blues: [0, 3, 5, 6, 7, 10],
                    harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
                    dorian: [0, 2, 3, 5, 7, 9, 10],
                    phrygian: [0, 1, 3, 5, 7, 8, 10],
                    lydian: [0, 2, 4, 6, 7, 9, 11],
                    mixolydian: [0, 2, 4, 5, 7, 9, 10]
                };
                
                // Inicializar Web Audio API
                this.initAudio(listener);
                // Obtener referencias a elementos DOM
                this.keyboardElement = document.getElementById('virtualKeyboard');
                this.headerElement = document.querySelector('.synth-header');
                this.settingsButton = document.getElementById('synthSettings');
                this.closeConfigButton = document.getElementById('closeConfigPanel');
                this.configPanel = document.getElementById('synthConfigPanel');
                this.octaveDown = document.getElementById('octaveDown');
                this.octaveUp = document.getElementById('octaveUp');
                this.currentOctaveDisplay = document.getElementById('currentOctave');
                this.velocitySlider = document.getElementById('virtualVelocity');
                this.volumeDisplay = document.getElementById('displayVolume');
                this.currentNoteDisplay = document.getElementById('currentNote');
                this.currentScaleDisplay = document.getElementById('currentScale');
                this.attackKnob = document.getElementById('knobAttack');
                this.releaseKnob = document.getElementById('knobRelease');
                this.scaleSelector = document.getElementById('scaleSelector');
                this.rootNoteSelector = document.getElementById('rootNoteSelector');
                this.keyBindingStatus = document.getElementById('keyBindingStatus');
                this.resetKeyBindingsButton = document.getElementById('resetKeyBindings');
                this.saveConfigButton = document.getElementById('saveConfig');
                this.synthKeyboardContainer = document.getElementById('synthKeyboard');
                
                // Generar el teclado dinámicamente basado en la escala seleccionada
                this.generateKeyboard();
                
                // Inicializar Event Listeners
                this.initializeEventListeners();
                
                // Inicializar posición de los knobs
                this.updateKnobPosition('attack', this.attackTime);
                this.updateKnobPosition('release', this.releaseTime);
                
                 // Actualizar visualización
                this.updateScaleDisplay();
            }

            // ++ AÑADE ESTA FUNCIÓN COMPLETA A LA CLASE ++
            _createDefaultMapping() {
                const mapping = {};
                const keyChars = Object.keys(this.keyToCode); // ['t', 'y', 'u', ...]
                for (let i = 0; i < keyChars.length; i++) {
                    const char = keyChars[i];
                    mapping[char] = i; // Asigna el índice: mapping['t'] = 0, mapping['y'] = 1, etc.
                }
                return mapping;
            }
            
            // Cargar configuración guardada
            loadSavedConfig() {
                try {
                    const savedConfig = localStorage.getItem('alienSynthConfig');
                    if (savedConfig) {
                        const config = JSON.parse(savedConfig);
                        this.currentScale = config.scale || 'chromatic';
                        this.currentRootNote = config.rootNote || 0;
                        this.currentOctave = config.octave || 4;
                        this.attackTime = config.attack || 0.05;
                        this.releaseTime = config.release || 0.3;
                        this.velocity = config.velocity || 78;
                        
                        // Cargar mapeo de teclas personalizado si existe
                        if (config.keyMapping) {
                            this.customKeyMapping = config.keyMapping;
                        } else {
                            this.customKeyMapping = this._createDefaultMapping();

                        }
                    } else {
                        this.customKeyMapping = this._createDefaultMapping();

                    }
                } catch (e) {
                    console.error('Error al cargar configuración del sintetizador:', e);
                    this.customKeyMapping = this._createDefaultMapping();

                }
            }
            
            // Guardar configuración actual
            saveConfig() {
                try {
                    const config = {
                        scale: this.currentScale,
                        rootNote: this.currentRootNote,
                        octave: this.currentOctave,
                        attack: this.attackTime,
                        release: this.releaseTime,
                        velocity: this.velocity,
                        keyMapping: this.customKeyMapping
                    };
                    
                    localStorage.setItem('alienSynthConfig', JSON.stringify(config));
                    return true;
                } catch (e) {
                    console.error('Error al guardar configuración del sintetizador:', e);
                    return false;
                }
            }
            
            // Inicializar Web Audio API
            // Inicializar Web Audio API
            // Inicializar Web Audio API
            initAudio(listener) { // <-- Acepta el listener principal
                try {
                    if (!listener || !listener.context) {
                        console.error("AlienSynth no recibió un AudioListener válido!");
                        // Como fallback, crea uno, pero no es lo ideal
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        this.masterGain = this.audioContext.createGain();
                        this.masterGain.connect(this.audioContext.destination);
                        return;
                    }
                    
                    // 1. Usa el contexto de audio existente (¡Esto estaba bien!)
                    this.audioContext = listener.context; 
                    
                    // 2. Crea el nodo de ganancia maestro para el synth (¡Esto estaba bien!)
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.7; // Volumen predeterminado
                    
                    // 3. ¡LA CORRECCIÓN! Conecta el gain del synth DIRECTAMENTE A LA SALIDA (destination)
                    //    No debe pasar por el 'listener.gain', que es para el audio 3D.
                    this.masterGain.connect(this.audioContext.destination); 
                    
                    console.log('Sistema de audio del synth conectado al context.destination principal.');
                } catch (e) {
                    console.error('Error al inicializar el sistema de audio:', e);
                }
            }
            
            // Crear una nota con audio
            createAudioNote(frequency) {
                // Crear oscilador
                const oscillator = this.audioContext.createOscillator();
                oscillator.type = this.currentWaveform;
                oscillator.frequency.value = frequency;
                
                // Crear nodo de ganancia para esta nota
                const noteGain = this.audioContext.createGain();
                noteGain.gain.value = 0;
                
                // Conectar oscilador -> noteGain -> masterGain -> salida
                oscillator.connect(noteGain);
                noteGain.connect(this.masterGain);
                
                // Configurar ataque
                const now = this.audioContext.currentTime;
                noteGain.gain.setValueAtTime(0, now);
                noteGain.gain.linearRampToValueAtTime(this.velocity / 127, now + this.attackTime);
                
                // Iniciar oscilador
                oscillator.start();
                
                return { oscillator, noteGain };
            }
            
            // Detener una nota
            stopAudioNote(noteObj) {
                const now = this.audioContext.currentTime;
                
                // Aplicar release
                noteObj.noteGain.gain.cancelScheduledValues(now);
                noteObj.noteGain.gain.setValueAtTime(noteObj.noteGain.gain.value, now);
                noteObj.noteGain.gain.exponentialRampToValueAtTime(0.001, now + this.releaseTime);
                
                // Detener oscilador después del release
                setTimeout(() => {
                    try {
                        noteObj.oscillator.stop();
                        noteObj.oscillator.disconnect();
                        noteObj.noteGain.disconnect();
                    } catch (e) {
                        // Ignorar errores si ya se ha detenido
                    }
                }, this.releaseTime * 1000);
            }
            
            // Convertir número MIDI a frecuencia
            midiToFrequency(midiNote) {
                return 440 * Math.pow(2, (midiNote - 69) / 12);
            }
            
            
            
            // Generar el teclado en el DOM basado en la escala actual
            generateKeyboard() {
                if (!this.synthKeyboardContainer) return;
                this.synthKeyboardContainer.innerHTML = ''; // Limpiar teclado anterior

                const rows = [
                    ['t', 'y', 'u', 'i', 'o', 'p', '´', '+'],
                    ['g', 'h', 'j', 'k', 'l', 'ñ', '{'],
                    ['b', 'n', 'm', ',', '.', '-']
                ];

                const scaleNotes = this.getScaleNotes();
                let noteCounter = 0;

                rows.forEach((rowKeys, rowIndex) => {
                    const rowElement = document.createElement('div');
                    rowElement.className = 'keyboard-row';
                    if (rowIndex === 1) rowElement.style.marginLeft = '20px';
                    if (rowIndex === 2) rowElement.style.marginLeft = '45px';

                    rowKeys.forEach(keyChar => {
                        const noteValue = scaleNotes[noteCounter % scaleNotes.length];
                        const isBlack = [1, 3, 6, 8, 10].includes(noteValue % 12);
                        
                        const keyElement = document.createElement('div');
                        keyElement.className = `key ${isBlack ? 'black' : 'white'}`;
                        keyElement.dataset.note = noteValue;
                        
                        const eventCode = this.keyToCode[keyChar]; 
                        if (eventCode) {
                            keyElement.dataset.code = eventCode;
                        }
                        
                        // --- ESTA ES LA LÍNEA CORREGIDA Y LIMPIA ---
                        keyElement.innerHTML = `${this.getNoteNameFromValue(noteValue)}<span class="key-binding">${keyChar.toUpperCase()}</span>`;

                        keyElement.addEventListener('mousedown', () => {
                            // --- ¡AÑADE ESTE BLOQUE AL INICIO! ---
                            if (this.audioContext && this.audioContext.state === 'suspended') {
                                this.audioContext.resume();
                                console.log('AudioContext REANUDADO por el clic en AlienSynth.');
                            }
                            // --- FIN DEL BLOQUE AÑADIDO ---
                            if (!this.isRebinding) {
                                const adjustedNote = this.getAdjustedNote(noteValue);
                                this.playNote(adjustedNote);
                                keyElement.classList.add('active');
                            }
                        });

                        const stopHandler = () => {
                            if (!this.isRebinding) {
                                const adjustedNote = this.getAdjustedNote(noteValue);
                                this.stopNote(adjustedNote);
                                keyElement.classList.remove('active');
                            }
                        };
                        
                        keyElement.addEventListener('mouseup', stopHandler);
                        keyElement.addEventListener('mouseleave', (e) => {
                            if (e.buttons === 1) stopHandler();
                        });

                        rowElement.appendChild(keyElement);
                        noteCounter++;
                    });

                    this.synthKeyboardContainer.appendChild(rowElement);
                });
            }


            
            // Obtener las notas de la escala actual con la nota raíz aplicada
            getScaleNotes() {
                const scaleIntervals = this.scales[this.currentScale];
                const notes = [];
                
                // Generar 3 octavas de notas para tener suficientes
                for (let octave = 0; octave < 3; octave++) {
                    for (const interval of scaleIntervals) {
                        const note = (this.currentRootNote + interval + octave * 12) % 36;
                        notes.push(note);
                    }
                }
                
                // Ordenar y eliminar duplicados
                return [...new Set(notes)].sort((a, b) => a - b);
            }
            
            // Ajustar nota según la octava actual
            getAdjustedNote(noteValue) {
                return noteValue + ((this.currentOctave - 3) * 12);
            }
            
            // Obtener nombre de nota a partir del valor relativo
            getNoteNameFromValue(noteValue) {
                const noteIndex = (noteValue + this.currentRootNote) % 12;
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return noteNames[noteIndex];
            }
            
            // Inicializar todos los event listeners
            initializeEventListeners() {
                // Botón para minimizar/maximizar
                this.headerElement.addEventListener('click', (event) => {
                // Nos aseguramos de que el clic no sea en un botón dentro del encabezado
                if (event.target.tagName !== 'BUTTON' && !event.target.closest('button')) {
                    this.toggleMinimize();
                }
            });                
                // Botón de configuración
                    this.settingsButton.addEventListener('click', () => this.toggleConfigPanel());
                
                // Botón de cerrar configuración
                this.closeConfigButton.addEventListener('click', () => this.toggleConfigPanel());
                
                // Controles de octava
                this.octaveDown.addEventListener('click', () => this.changeOctave(-1));
                this.octaveUp.addEventListener('click', () => this.changeOctave(1));
                
                // Control de volumen (velocidad MIDI)
                this.velocitySlider.addEventListener('input', () => {
                    this.velocity = parseInt(this.velocitySlider.value);
                    this.volumeDisplay.textContent = this.velocity;
                });
                
                // Selector de escala
                this.scaleSelector.addEventListener('change', () => {
                    this.currentScale = this.scaleSelector.value;
                    this.updateScaleDisplay();
                    this.generateKeyboard();
                });
                
                // Selector de nota raíz
                this.rootNoteSelector.addEventListener('change', () => {
                    this.currentRootNote = parseInt(this.rootNoteSelector.value);
                    this.updateScaleDisplay();
                    this.generateKeyboard();
                });
                
                // Botón para resetear asignaciones de teclas
                this.resetKeyBindingsButton.addEventListener('click', () => {
                    this.customKeyMapping = this._createDefaultMapping();
                    this.generateKeyboard();
                    this.keyBindingStatus.textContent = "Asignaciones de teclas restauradas";
                });
                
                // Botón para guardar configuración
                this.saveConfigButton.addEventListener('click', () => {
                    if (this.saveConfig()) {
                        this.keyBindingStatus.textContent = "Configuración guardada correctamente";
                        this.toggleConfigPanel();
                    } else {
                        this.keyBindingStatus.textContent = "Error al guardar la configuración";
                    }
                });
                
                // Knobs (diales) - Attack y Release
                this.setupKnobControl(this.attackKnob, 'attack', 0.01, 0.5);
                this.setupKnobControl(this.releaseKnob, 'release', 0.1, 2.0);
                
                // Botones de selección de forma de onda
                const waveButtons = document.querySelectorAll('.wave-button');
                waveButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        // Desactivar todos los botones
                        waveButtons.forEach(btn => btn.classList.remove('active'));
                        // Activar el botón seleccionado
                        button.classList.add('active');
                        // Cambiar forma de onda
                        this.currentWaveform = button.getAttribute('data-wave');
                    });
                });
                
                // Iniciar modo de reasignación de teclas
                this.keyboardElement.addEventListener('click', (e) => {
                    // Solo para iniciar audio en Chrome, no para reasignar teclas
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                });
                
                // Eventos para el teclado físico
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                // Evento para asignar nueva tecla
                document.addEventListener('keypress', (e) => {
                    if (this.isRebinding && this.selectedKey) {
                        e.preventDefault();
                        
                        const keyChar = e.key.toLowerCase();
                        const keyIndex = parseInt(this.selectedKey.dataset.index);
                        
                        // Verificar si la tecla ya está asignada
                        for (const [key, index] of Object.entries(this.customKeyMapping)) {
                            if (key === keyChar) {
                                this.customKeyMapping[key] = null; // Desasignar la tecla anterior
                            }
                        }
                        
                        // Asignar la nueva tecla
                        this.customKeyMapping[keyChar] = keyIndex;
                        
                        // Actualizar visualización
                        this.selectedKey.querySelector('.key-binding').textContent = keyChar.toUpperCase();
                        this.keyBindingStatus.textContent = `Tecla ${keyChar.toUpperCase()} asignada a ${this.getNoteNameFromValue(parseInt(this.selectedKey.dataset.note))}`;
                        
                        // Finalizar reasignación
                        this.selectedKey.classList.remove('rebinding');
                        this.selectedKey = null;
                        this.isRebinding = false;
                    }
                });
                
                // Inicializar selectores
                this.scaleSelector.value = this.currentScale;
                this.rootNoteSelector.value = this.currentRootNote;
            }
            
            // Configurar control para los knobs (diales)
            setupKnobControl(knobElement, paramName, minValue, maxValue) {
                let isDragging = false;
                let startY;
                let startValue;
                
                // Valor inicial
                if (paramName === 'attack') {
                    startValue = this.attackTime;
                } else if (paramName === 'release') {
                    startValue = this.releaseTime;
                }
                
                // Evento mousedown
                knobElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startValue = paramName === 'attack' ? this.attackTime : this.releaseTime;
                    
                    // Capturar el mouse
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    
                    // Prevenir selección de texto
                    e.preventDefault();
                });
                
                // Función para manejar mousemove
                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    
                    // Calcular delta Y (movimiento invertido para que hacia arriba aumente el valor)
                    const deltaY = startY - e.clientY;
                    const sensitivity = 0.005; // Sensibilidad del knob
                    
                    // Calcular nuevo valor basado en el rango
                    let newValue = startValue + (deltaY * sensitivity);
                    newValue = Math.max(minValue, Math.min(maxValue, newValue));
                    
                    // Actualizar valor según el parámetro
                    if (paramName === 'attack') {
                        this.attackTime = newValue;
                    } else if (paramName === 'release') {
                        this.releaseTime = newValue;
                    }
                    
                    // Actualizar posición visual del knob
                    this.updateKnobPosition(paramName, newValue);
                };
                
                // Función para manejar mouseup
                const onMouseUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
            }
            
            // Actualizar la posición visual de los knobs
            updateKnobPosition(paramName, value) {
                const knobElement = paramName === 'attack' ? this.attackKnob : this.releaseKnob;
                const minValue = paramName === 'attack' ? 0.01 : 0.1;
                const maxValue = paramName === 'attack' ? 0.5 : 2.0;
                
                // Calcular ángulo basado en el valor (0 a 270 grados)
                const range = maxValue - minValue;
                const normalizedValue = (value - minValue) / range;
                const angle = normalizedValue * 270; // Rango de 270 grados
                
                // Actualizar la rotación del knob
                knobElement.style.transform = `rotate(${angle}deg)`;
            }
            
            // Actualizar visualización de la escala actual
            updateScaleDisplay() {
                // Obtener nombre legible de la escala
                const scaleNames = {
                    chromatic: 'CROMÁTICA',
                    major: 'MAYOR',
                    minor: 'MENOR',
                    pentatonic: 'PENTATÓNICA',
                    blues: 'BLUES',
                    harmonicMinor: 'MENOR ARMÓNICA',
                    dorian: 'DÓRICA',
                    phrygian: 'FRIGIA',
                    lydian: 'LIDIA',
                    mixolydian: 'MIXOLIDIA'
                };
                
                // Obtener nombre de la nota raíz
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const rootName = noteNames[this.currentRootNote];
                
                // Actualizar visualización
                this.currentScaleDisplay.textContent = `${rootName} ${scaleNames[this.currentScale]}`;
            }
            
            // Minimizar/maximizar el teclado
            toggleMinimize() {
                this.isMinimized = !this.isMinimized;
                if (this.isMinimized) {
                    this.keyboardElement.classList.add('minimized');
                    
                    // Si el panel de configuración está abierto, cerrarlo
                    if (this.isConfigOpen) {
                        this.toggleConfigPanel();
                    }
                } else {
                    this.keyboardElement.classList.remove('minimized');
                }
            }
            
            // Abrir/cerrar panel de configuración
            toggleConfigPanel() {
                this.isConfigOpen = !this.isConfigOpen;
                
                if (this.isConfigOpen) {
                    this.configPanel.style.display = 'block';
                    this.isRebinding = false;
                    this.keyBindingStatus.textContent = 'Listo para reasignar';
                    
                    // Si está minimizado, expandirlo
                    if (this.isMinimized) {
                        this.toggleMinimize();
                    }
                } else {
                    this.configPanel.style.display = 'none';
                    
                    // Si estaba en modo reasignación, cancelarlo
                    if (this.selectedKey) {
                        this.selectedKey.classList.remove('rebinding');
                        this.selectedKey = null;
                        this.isRebinding = false;
                    }
                }
            }
            
            // Cambiar octava
            changeOctave(delta) {
                this.currentOctave = Math.max(1, Math.min(7, this.currentOctave + delta));
                this.currentOctaveDisplay.textContent = this.currentOctave;
            }
            
            // Manejar eventos keydown del teclado físico
            handleKeyDown(e) {
                // Evitar repetición de tecla mantenida
                if (e.repeat) return;
                
                // Evitar capturar teclas cuando se está escribiendo en un input o en modo reasignación
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || this.isRebinding) return;

                 // 3. AÑADE el siguiente bloque en su lugar. Es más corto y eficiente.
    
                // Buscamos directamente la tecla virtual que corresponde al CÓDIGO de la tecla física.
                const keyElement = this.synthKeyboardContainer.querySelector(`.key[data-code="${e.code}"]`);

            // Si encontramos una tecla y no está ya activa...
                 if (keyElement && !keyElement.classList.contains('active')) {
                // Prevenir comportamiento predeterminado (scrolling, etc.)
                // También previene la acción de la tecla 'p' si está mapeada, sin necesidad de la lógica anterior.
                e.preventDefault(); 
                
                // El resto de tu lógica original se mantiene casi idéntica:
                const noteValue = parseInt(keyElement.dataset.note);
                const adjustedNote = this.getAdjustedNote(noteValue);
                
                // Marcar la tecla virtual como activa
                keyElement.classList.add('active');
                
                // Tocar la nota
                this.playNote(adjustedNote);
            }
                
        }
            
            // Manejar eventos keyup del teclado físico
            handleKeyUp(e) {
                // Evitar capturar teclas cuando se está escribiendo en un input o en modo reasignación
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || this.isRebinding) return;
                
               // Buscamos la tecla virtual usando el código de la tecla física.
                const keyElement = this.synthKeyboardContainer.querySelector(`.key[data-code="${e.code}"]`);

            // Si encontramos una tecla...
                 if (keyElement) {
                // Tu lógica original se mantiene:
                const noteValue = parseInt(keyElement.dataset.note);
                const adjustedNote = this.getAdjustedNote(noteValue);
                
                // Desmarcar la tecla virtual
                keyElement.classList.remove('active');
                
                // Detener la nota
                this.stopNote(adjustedNote);
            }
            }
            
            // Tocar una nota (audio + efecto visual + integración con galaxias)
            // Tocar una nota (audio + efecto visual + integración con galaxias)
            playNote(noteNumber) {
                // Evitar tocar la misma nota dos veces
                if (this.activeKeys.has(noteNumber)) return;
                
                this.activeKeys.add(noteNumber);
                
                // Actualizar visualización
                const noteName = this.getNoteNameFromMIDI(noteNumber);
                this.currentNoteDisplay.textContent = noteName;
                
                // Verificar que la galaxia del usuario existe
                if (galaxies[username]) {
                    // --- ¡LÓGICA DE AUDIO 3D AÑADIDA! ---
                    // 1. Crear el sonido 3D desde nuestra galaxia local
                    const galaxy = galaxies[username];
                    if (galaxy.positionalAudio && !galaxy.activeAudioNotes[noteNumber]) {
                        const frequency = this.midiToFrequency(noteNumber);
                        const oscillator = this.audioContext.createOscillator();
                        oscillator.type = this.currentWaveform;
                        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);

                        const gainNode = this.audioContext.createGain();
                        const targetVolume = (this.velocity / 127) * 0.7;
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(targetVolume, this.audioContext.currentTime + this.attackTime);

                        oscillator.connect(gainNode);
                        gainNode.connect(galaxy.positionalAudio.gain); // Conectar al audio 3D local
                        oscillator.start();
                        
                        galaxy.activeAudioNotes[noteNumber] = { oscillator, gainNode };
                    }
                    
                    // 2. Añadir la nota a la galaxia (mismo método que usa el MIDI hardware)
                    galaxy.addNote(noteNumber, this.velocity);

                    // 3. Enviar la nota al servidor
                    sendNote('note_on', noteNumber, this.velocity);
                    
                    if (midiStatusElement) {
                        midiStatusElement.textContent = `Nota: ${noteName} (${noteNumber}), Velocidad: ${this.velocity}`;
                    }
                }
            }
            
            // Detener una nota
            stopNote(noteNumber) {
                this.activeKeys.delete(noteNumber);
                
                // Verificar que la galaxia del usuario existe
                if (galaxies[username]) {
                    const galaxy = galaxies[username];

                    // --- ¡LÓGICA DE AUDIO 3D AÑADIDA! ---
                    // 1. Detener el sonido 3D local
                    if (galaxy.activeAudioNotes[noteNumber]) {
                        const { oscillator, gainNode } = galaxy.activeAudioNotes[noteNumber];
                        const now = this.audioContext.currentTime;
                        
                        gainNode.gain.cancelScheduledValues(now);
                        gainNode.gain.setValueAtTime(gainNode.gain.value, now); 
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + this.releaseTime); 

                        oscillator.stop(now + this.releaseTime + 0.05); 

                        setTimeout(() => {
                            try {
                                oscillator.disconnect();
                                gainNode.disconnect();
                            } catch(e) { /* Ignorar */ }
                        }, (this.releaseTime + 0.1) * 1000); 

                        delete galaxy.activeAudioNotes[noteNumber];
                    }
                    
                    // 2. Eliminar la nota de la galaxia (visual)
                    galaxy.removeNote(noteNumber);

                    // 3. Enviar la nota al servidor
                    sendNote('note_off', noteNumber, 0);
                }
                
                // Actualizar visualización
                if (this.activeKeys.size === 0) {
                    this.currentNoteDisplay.textContent = '--';
                }
            }
            
            // Obtener nombre de nota a partir del número MIDI
            getNoteNameFromMIDI(midiNote) {
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const octave = Math.floor(midiNote / 12) - 1;
                const noteName = noteNames[midiNote % 12];
                return `${noteName}${octave}`;
            }
            
            // Verificar si una tecla debe ser inhibida (como la P)
            isKeyInhibited(key) {
                if (key === 'p' && this.inhibitKeyP) {
                    return true;
                }
                return false;
            }
        }

         // Agregar un event listener al documento para cerrar el menú al hacer clic fuera
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('settingsMenu');
            const settingsButton = document.getElementById('btnSettings');
            
            // Si el menú está abierto y el clic no fue dentro del menú ni en el botón de configuración
            if (menu.style.display === 'block' && 
                !menu.contains(event.target) && 
                event.target !== settingsButton) {
                menu.style.display = 'none';
            }
        });   

        // Evitar que los clics dentro del menú cierren el menú
        document.getElementById('settingsMenu').addEventListener('click', function(event) {
            event.stopPropagation(); // Evita que el clic se propague al documento
        });

        // Iniciar todo cuando el DOM esté cargado
        document.addEventListener('DOMContentLoaded', function() {
            // Inicializaciones originales
            init();
            initMIDI();
            
            // Inicializar el sintetizador virtual alienígena
            const alienSynth = new AlienSynthKeyboard(audioListener);            
            // Exportar a una variable global para acceso desde otras partes del código
            window.alienSynth = alienSynth;

            // --- CÓDIGO AÑADIDO: Minimizar sintetizador al hacer clic fuera ---
        document.addEventListener('click', function(event) {
            const keyboardElement = document.getElementById('virtualKeyboard');
            const settingsMenu = document.getElementById('settingsMenu'); // Referencia al menú de configuración principal
            const synth = window.alienSynth; // Accedemos a la instancia global

            // Si no existe el sintetizador o su elemento, no hacemos nada
            if (!synth || !keyboardElement) {
                return;
            }

            // Condición para minimizar:
            // 1. El sintetizador debe estar abierto (no minimizado).
            // 2. El clic NO debe ser dentro del propio sintetizador.
            // 3. El clic NO debe ser dentro del menú de configuración principal (para no cerrarlo al mismo tiempo).
            const isClickOutsideSynth = !keyboardElement.contains(event.target);
            const isClickOutsideSettings = !settingsMenu.contains(event.target);

            if (!synth.isMinimized && isClickOutsideSynth && isClickOutsideSettings) {
                synth.toggleMinimize(); // Llamamos a la función para minimizarlo
            }
        });
        // --- FIN DEL CÓDIGO AÑADIDO ---
            
            // Asegurar que la función getNoteNameFromMIDI esté disponible globalmente si es necesario
            if (typeof window.getNoteNameFromMIDI !== 'function') {
                window.getNoteNameFromMIDI = function(midiNote) {
                    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                    const octave = Math.floor(midiNote / 12) - 1;
                    const noteName = noteNames[midiNote % 12];
                    return `${noteName}${octave}`;
                };
            }
        });

    </script>
        <!-- Teclado MIDI Virtual Compacto y Transparente -->
        <div id="virtualKeyboard" class="alien-synth compact minimized">
            <div class="synth-header">
            <div class="synth-logo">
                <span class="alien-text">XENO</span><span class="alien-glow">SYNTH</span>
            </div>
            <div class="synth-controls">
                <button id="synthSettings" class="alien-button settings-btn" title="Configuración">⚙</button>
            </div>
        </div>
        
        <div class="synth-body">
            <div class="synth-display">
                <div class="display-screen">
                    <div class="display-left">
                        <div class="display-octave">OCT: <span id="currentOctave">4</span></div>
                        <div class="display-velocity">VOL: <span id="displayVolume">78</span></div>
                    </div>
                    <div class="display-right">
                        <div class="display-note" id="currentNote">--</div>
                        <div class="display-scale">SCALE: <span id="currentScale">CHROMATIC</span></div>
                    </div>
                </div>
            </div>
            
            <div class="synth-panel">
                <div class="panel-section">
                    <div class="control-knob">
                        <div class="knob-ring"></div>
                        <div class="knob" id="knobAttack">
                            <div class="knob-indicator"></div>
                        </div>
                        <div class="knob-label">ATTACK</div>
                    </div>
                    <div class="control-knob">
                        <div class="knob-ring"></div>
                        <div class="knob" id="knobRelease">
                            <div class="knob-indicator"></div>
                        </div>
                        <div class="knob-label">RELEASE</div>
                    </div>
                    <div class="control-group">
                        <label>OCTAVE</label>
                        <div class="control-buttons">
                            <button id="octaveDown" class="alien-small-button">-</button>
                            <button id="octaveUp" class="alien-small-button">+</button>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="control-slider">
                        <label>VOLUME</label>
                        <input type="range" id="virtualVelocity" min="1" max="127" value="78">
                    </div>
                    <div class="wave-selector">
                        <label>WAVEFORM</label>
                        <div class="wave-buttons">
                            <button class="wave-button active" data-wave="sine">◠◡</button>
                            <button class="wave-button" data-wave="square">▮▯</button>
                            <button class="wave-button" data-wave="sawtooth">◸</button>
                            <button class="wave-button" data-wave="triangle">◺◿</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="keyboard-container">
                <!-- Contenedor simplificado para las teclas - se generan dinámicamente con JS -->
                <div id="synthKeyboard" class="synth-keyboard">
                    <!-- Las teclas se generarán dinámicamente -->
                </div>
            </div>
        </div>
        
        <!-- Panel de configuración del sintetizador -->
        <div id="synthConfigPanel" class="synth-config-panel">
            <div class="config-header">
                <h3>Configuración del Sintetizador</h3>
                <button id="closeConfigPanel" class="alien-button">✕</button>
            </div>
            <div class="config-body">
                <div class="config-section">
                    <h4>Escala Musical</h4>
                    <select id="scaleSelector" class="alien-select">
                        <option value="chromatic">Cromática (Todas las notas)</option>
                        <option value="major">Mayor</option>
                        <option value="minor">Menor</option>
                        <option value="pentatonic">Pentatónica Mayor</option>
                        <option value="blues">Blues</option>
                        <option value="harmonicMinor">Menor Armónica</option>
                        <option value="dorian">Modo Dórico</option>
                        <option value="phrygian">Modo Frigio</option>
                        <option value="lydian">Modo Lidio</option>
                        <option value="mixolydian">Modo Mixolidio</option>
                    </select>
                </div>
                
                <div class="config-section">
                    <h4>Nota Base</h4>
                    <select id="rootNoteSelector" class="alien-select">
                        <option value="0">C (Do)</option>
                        <option value="1">C# (Do#)</option>
                        <option value="2">D (Re)</option>
                        <option value="3">D# (Re#)</option>
                        <option value="4">E (Mi)</option>
                        <option value="5">F (Fa)</option>
                        <option value="6">F# (Fa#)</option>
                        <option value="7">G (Sol)</option>
                        <option value="8">G# (Sol#)</option>
                        <option value="9">A (La)</option>
                        <option value="10">A# (La#)</option>
                        <option value="11">B (Si)</option>
                    </select>
                </div>
                
                <div class="config-section">
                    <h4>Personalización de Teclas</h4>
                    <div class="key-binding-info">
                        <p>Clica en una tecla del teclado y luego presiona la tecla en tu teclado físico para reasignarla.</p>
                    </div>
                    <div class="key-binding-status">
                        <span id="keyBindingStatus">Listo para reasignar</span>
                    </div>
                    <button id="resetKeyBindings" class="alien-config-button">Restaurar asignaciones predeterminadas</button>
                </div>
                
                <div class="config-section">
                    <button id="saveConfig" class="alien-config-button save-btn">Guardar Configuración</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Estilos para el sintetizador compacto y transparente -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&family=Rajdhani:wght@500&display=swap');

        /* Animaciones */
        @keyframes glow {
            0% { text-shadow: 0 0 10px rgba(98, 215, 255, 0.5), 0 0 20px rgba(98, 215, 255, 0.2); }
            50% { text-shadow: 0 0 15px rgba(98, 215, 255, 0.8), 0 0 30px rgba(98, 215, 255, 0.5); }
            100% { text-shadow: 0 0 10px rgba(98, 215, 255, 0.5), 0 0 20px rgba(98, 215, 255, 0.2); }
        }

        @keyframes pulse {
            0% { opacity: 0.9; box-shadow: 0 0 10px rgba(98, 215, 255, 0.7); }
            50% { opacity: 1; box-shadow: 0 0 20px rgba(98, 215, 255, 1); }
            100% { opacity: 0.9; box-shadow: 0 0 10px rgba(98, 215, 255, 0.7); }
        }

        /* Estilos principales */
        .alien-synth {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 450px; /* Reducido de 580px */
            background: rgba(10, 15, 34, 0.01); /* Mayor transparencia */
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(98, 215, 255, 0.3);
            color: #c7e5ff;
            font-family: 'Orbitron', sans-serif;
            z-index: 300;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(98, 215, 255, 0.3);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            padding-bottom: 8px;
        }
        
        .alien-synth.compact {
            max-height: calc(100vh - 100px); /* Evitar que ocupe toda la pantalla */
        }

        .alien-synth.minimized {
            height: 45px !important;
            width: 250px;
        }

        .alien-synth.minimized .synth-body {
            height: 0;
            opacity: 0;
        }

        .synth-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: rgba(16, 23, 46, 0.8);
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            border-bottom: 1px solid rgba(98, 215, 255, 0.4);
        }

        .synth-logo {
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .alien-text {
            color: #62d7ff;
        }

        .alien-glow {
            color: #ffffff;
            animation: glow 2s infinite;
        }

        .synth-controls {
            display: flex;
            gap: 8px;
        }

        .alien-button {
            background: none;
            border: 1px solid rgba(98, 215, 255, 0.4);
            color: #62d7ff;
            font-size: 14px;
            width: 28px;
            height: 28px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .alien-button:hover {
            background-color: rgba(98, 215, 255, 0.2);
            box-shadow: 0 0 10px rgba(98, 215, 255, 0.4);
        }

        .alien-synth.minimized .alien-button .alien-icon {
            transform: rotate(180deg);
        }

        .alien-small-button {
            background: rgba(16, 23, 46, 0.9);
            border: 1px solid rgba(98, 215, 255, 0.4);
            color: #62d7ff;
            font-size: 12px;
            width: 22px;
            height: 22px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .alien-small-button:hover {
            background-color: rgba(98, 215, 255, 0.2);
        }

        .synth-body {
            transition: all 0.5s;
            overflow: hidden;
        }

        /* Display del sintetizador */
        .synth-display {
            padding: 8px 12px;
            background: rgba(8, 12, 24, 0.6);
            border-bottom: 1px solid rgba(98, 215, 255, 0.3);
        }

        .display-screen {
            background: linear-gradient(180deg, rgba(8, 31, 40, 0.8), rgba(10, 25, 35, 0.8));
            border-radius: 5px;
            border: 1px solid rgba(98, 215, 255, 0.5);
            padding: 8px 12px;
            height: 60px; /* Reducido de 70px */
            color: #62d7ff;
            font-family: 'Rajdhani', sans-serif;
            display: flex;
            flex-wrap: wrap;
            position: relative;
        }

        .display-left, .display-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .display-octave, .display-velocity, .display-note, .display-scale {
            font-size: 14px;
            padding: 3px 0;
        }

        .display-note {
            font-size: 20px;
            font-weight: bold;
            text-align: right;
        }

        .display-scale {
            text-align: right;
        }

        /* Panel de control */
        .synth-panel {
            display: flex;
            background: rgba(16, 23, 46, 0.5);
            padding: 10px; /* Reducido de 15px */
            border-bottom: 1px solid rgba(98, 215, 255, 0.3);
        }

        .panel-section {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Reducido de 15px */
            align-items: center;
            justify-content: space-around;
        }

        .control-knob {
            position: relative;
            width: 40px; /* Reducido de 50px */
            height: 60px; /* Reducido de 70px */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .knob-ring {
            width: 32px; /* Reducido de 40px */
            height: 32px; /* Reducido de 40px */
            border-radius: 50%;
            border: 1px solid rgba(98, 215, 255, 0.5);
            position: relative;
        }

        .knob {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 24px; /* Reducido de 30px */
            height: 24px; /* Reducido de 30px */
            border-radius: 50%;
            background: linear-gradient(145deg, rgba(20, 30, 60, 0.9), rgba(25, 40, 80, 0.9));
            box-shadow: 0 0 5px rgba(98, 215, 255, 0.3);
            cursor: pointer;
        }

        .knob-indicator {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px; /* Reducido de 10px */
            background-color: #62d7ff;
            border-radius: 1px;
        }

        .knob-label {
            margin-top: 6px; /* Reducido de 8px */
            font-size: 8px; /* Reducido de 10px */
            text-align: center;
            color: #c7e5ff;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px; /* Reducido de 5px */
        }

        .control-group label {
            font-size: 8px; /* Reducido de 10px */
            color: #c7e5ff;
        }

        .control-buttons {
            display: flex;
            gap: 4px; /* Reducido de 5px */
        }

        .control-slider {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 4px; /* Reducido de 5px */
        }

        .control-slider label {
            font-size: 8px; /* Reducido de 10px */
            color: #c7e5ff;
            text-align: center;
        }

        #virtualVelocity {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(98, 215, 255, 0.3);
            border-radius: 2px;
            outline: none;
        }

        #virtualVelocity::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px; /* Reducido de 15px */
            height: 12px; /* Reducido de 15px */
            border-radius: 50%;
            background: linear-gradient(145deg, #62d7ff, #4aa9cc);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(98, 215, 255, 0.5);
        }

        #virtualVelocity::-moz-range-thumb {
            width: 12px; /* Reducido de 15px */
            height: 12px; /* Reducido de 15px */
            border-radius: 50%;
            background: linear-gradient(145deg, #62d7ff, #4aa9cc);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(98, 215, 255, 0.5);
        }

        .wave-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px; /* Reducido de 5px */
            width: 100%;
        }

        .wave-selector label {
            font-size: 8px; /* Reducido de 10px */
            color: #c7e5ff;
        }

        .wave-buttons {
            display: flex;
            gap: 3px; /* Reducido de 5px */
            justify-content: center;
        }

        .wave-button {
            width: 25px; /* Reducido de 30px */
            height: 20px; /* Reducido de 25px */
            background: rgba(16, 23, 46, 0.9);
            border: 1px solid rgba(98, 215, 255, 0.4);
            border-radius: 3px;
            color: #62d7ff;
            font-size: 11px; /* Reducido de 12px */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wave-button.active {
            background-color: rgba(98, 215, 255, 0.3);
            box-shadow: 0 0 8px rgba(98, 215, 255, 0.5);
        }

        /* Teclado */
        .keyboard-container {
            padding: 8px 10px; /* Reducido de 10px 15px */
            background: rgba(12, 18, 35, 0.6);
        }

         /* Pega estas nuevas reglas en tu CSS */
         .synth-keyboard {
            display: flex;
            flex-direction: column; /* Apila las filas verticalmente */
            align-items: center;  /* Centra las filas */
            gap: 4px;             /* Espacio entre filas */
        }

        .keyboard-row {
            display: flex;
            justify-content: center; /* Centra las teclas en la fila */
        }


        .key {
            position: relative;
            height: 40px; /* Reducido de 50px */
            width: 36px; /* Reducido de 50px */
            margin: 0 1px; /* Reducido de 2px */
            border-radius: 4px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            font-size: 10px; /* Reducido de 12px */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
            padding-bottom: 6px; /* Reducido de 8px */
            user-select: none;
        }

        .key.white {
            background: linear-gradient(180deg, #f2f9ff, #d9e9ff);
            border: 1px solid rgba(98, 215, 255, 0.7);
            color: #1f2d59;
            box-shadow: 0 4px 0 rgba(98, 215, 255, 0.3);
            z-index: 1;
        }

        .key.black {
            background: linear-gradient(180deg, #313b5e, #1c2340);
            border: 1px solid rgba(98, 215, 255, 0.5);
            color: #c7e5ff;
            box-shadow: 0 3px 0 rgba(11, 16, 33, 0.8);
            z-index: 2;
            height: 34px; /* Más pequeñas que las blancas */
            margin-top: 0;
        }

        .key.white:hover {
            background: linear-gradient(180deg, #ffffff, #e9f5ff);
            box-shadow: 0 4px 0 rgba(98, 215, 255, 0.5);
        }

        .key.black:hover {
            background: linear-gradient(180deg, #3a4573, #232b4f);
            box-shadow: 0 3px 0 rgba(16, 23, 46, 0.8);
        }

        .key.white:active, .key.white.active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(98, 215, 255, 0.3);
        }

        .key.black:active, .key.black.active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 rgba(11, 16, 33, 0.8);
        }

        .key-binding {
            position: absolute;
            top: 3px;
            right: 4px;
            font-size: 7px; /* Reducido de 9px */
            opacity: 0.7;
        }

        .key.rebinding {
            border: 2px solid #ff62b5;
            box-shadow: 0 0 10px rgba(255, 98, 181, 0.5);
        }

        /* Panel de configuración */
        .synth-config-panel {
            position: absolute;
            top: 45px;
            right: 0;
            width: 100%;
            background: rgba(10, 15, 34, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(98, 215, 255, 0.5);
            box-shadow: 0 0 20px rgba(98, 215, 255, 0.3);
            z-index: 301;
            display: none;
            overflow: auto;
            max-height: 70vh;
        }

        .config-header {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(98, 215, 255, 0.3);
        }

        .config-header h3 {
            margin: 0;
            font-size: 16px;
            color: #62d7ff;
        }

        .config-body {
            padding: 15px;
        }

        .config-section {
            margin-bottom: 15px;
        }

        .config-section h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #c7e5ff;
        }

        .alien-select {
            width: 100%;
            padding: 6px 10px;
            background: rgba(16, 23, 46, 0.9);
            border: 1px solid rgba(98, 215, 255, 0.4);
            border-radius: 4px;
            color: #c7e5ff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            appearance: none;
            cursor: pointer;
        }

        .alien-select:focus {
            outline: none;
            border-color: #62d7ff;
            box-shadow: 0 0 8px rgba(98, 215, 255, 0.5);
        }

        .key-binding-info p {
            font-size: 12px;
            line-height: 1.4;
            margin: 0 0 8px 0;
        }

        .key-binding-status {
            background: rgba(16, 23, 46, 0.6);
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .alien-config-button {
            background: rgba(16, 23, 46, 0.9);
            border: 1px solid rgba(98, 215, 255, 0.4);
            border-radius: 4px;
            color: #c7e5ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .alien-config-button:hover {
            background: rgba(25, 35, 70, 0.9);
            box-shadow: 0 0 8px rgba(98, 215, 255, 0.5);
        }

        .save-btn {
            background: rgba(25, 60, 100, 0.9);
            width: 100%;
        }

        .save-btn:hover {
            background: rgba(35, 75, 120, 0.9);
        }
    </style>
</body>

</html>
