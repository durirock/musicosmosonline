Mycelium mind ¬∑ HTML
Copiar

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mycelium Mind - Mapas Mentales 3D</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Fira+Code:wght@300;400&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>

    <style>
        :root {
            --primary-glow: #4DDBFF;
            --secondary-glow: #0077FF;
            --accent-warm: #FF6B4D;
            --accent-green: #4DFF88;
            --accent-purple: #9D4DFF;
            --text-color: #EAEAEA;
            --bg-color: #02040a;
            --glass-bg: rgba(2, 4, 10, 0.85);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Fira Code', monospace;
            cursor: crosshair;
            touch-action: none;
        }

        #webgl-container, #css-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }

        #css-container { pointer-events: none; }
        #css-container > div { pointer-events: auto; }

        #coordinates {
            position: fixed;
            top: 20px; left: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 0.75em;
            z-index: 100;
        }

        #coordinates .coord-label { color: rgba(255, 255, 255, 0.5); }
        #coordinates .coord-value {
            color: var(--primary-glow);
            min-width: 40px;
            display: inline-block;
            text-align: right;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.7);
            z-index: 100;
            text-align: center;
            transition: opacity 0.5s ease;
            max-width: 90%;
        }

        #instructions.hidden { opacity: 0; pointer-events: none; }

        #instructions kbd {
            background: rgba(77, 219, 255, 0.2);
            border: 1px solid var(--primary-glow);
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0 2px;
        }

        #stats-panel {
            position: fixed;
            top: 70px; left: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 12px;
            padding: 15px 20px;
            font-size: 0.8em;
            z-index: 100;
        }

        #stats-panel h3 {
            font-family: 'Cinzel', serif;
            color: var(--primary-glow);
            font-size: 1em;
            margin-bottom: 8px;
            letter-spacing: 2px;
        }

        #stats-panel .stat {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 4px 0;
            color: rgba(255, 255, 255, 0.7);
        }

        #stats-panel .stat-value { color: var(--primary-glow); }

        .action-buttons {
            position: fixed;
            top: 20px; right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .action-btn {
            width: 50px; height: 50px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 12px;
            color: var(--primary-glow);
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            background: rgba(77, 219, 255, 0.2);
            border-color: var(--primary-glow);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(77, 219, 255, 0.3);
        }

        .idea-node {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 2px solid var(--primary-glow);
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 40px;
            max-width: 400px;
            box-shadow: 0 0 20px rgba(77, 219, 255, 0.4);
            cursor: grab;
            transition: box-shadow 0.3s ease, border-color 0.3s ease;
            user-select: none;
            display: inline-block;
        }

        .idea-node:hover { box-shadow: 0 0 35px rgba(77, 219, 255, 0.6); }
        .idea-node.selected {
            border-color: var(--accent-warm);
            box-shadow: 0 0 40px rgba(255, 107, 77, 0.6);
        }
        .idea-node.editing {
            border-color: var(--accent-green);
            box-shadow: 0 0 50px rgba(77, 255, 136, 0.7);
            cursor: text;
        }
        .idea-node.dragging { cursor: grabbing; }
        .idea-node.ghost { 
            opacity: 0.4; 
            border-style: dashed; 
            pointer-events: none;
            background: rgba(77, 219, 255, 0.1);
        }
        
        .idea-node.connection-target {
            border-color: var(--accent-green);
            box-shadow: 0 0 50px rgba(77, 255, 136, 0.7);
            animation: pulse-green 0.5s ease infinite alternate;
        }

        .idea-node.disconnect-target {
            border-color: var(--accent-purple);
            box-shadow: 0 0 50px rgba(157, 77, 255, 0.7);
            animation: pulse-purple 0.5s ease infinite alternate;
        }

        @keyframes pulse-green {
            from { box-shadow: 0 0 30px rgba(77, 255, 136, 0.5); }
            to { box-shadow: 0 0 60px rgba(77, 255, 136, 0.8); }
        }

        @keyframes pulse-purple {
            from { box-shadow: 0 0 30px rgba(157, 77, 255, 0.5); }
            to { box-shadow: 0 0 60px rgba(157, 77, 255, 0.8); }
        }

        .idea-node .node-content {
            font-size: 13px;
            line-height: 1.4;
            color: var(--text-color);
            word-wrap: break-word;
            white-space: pre-wrap;
            outline: none;
        }

        #node-input-modal {
            position: fixed;
            display: none;
            z-index: 500;
            pointer-events: none;
        }

        #node-input-modal.visible { display: block; pointer-events: auto; }

        #node-input-modal .input-wrapper {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 2px solid var(--accent-green);
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 60px;
            max-width: 400px;
            box-shadow: 0 0 40px rgba(77, 255, 136, 0.5);
            display: inline-block;
        }

        #node-input {
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: 'Fira Code', monospace;
            font-size: 13px;
            line-height: 1.4;
            resize: none;
            outline: none;
            width: auto;
            min-width: 50px;
            max-width: 350px;
            overflow: hidden;
        }

        #connection-mode-indicator {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(77, 255, 136, 0.2);
            border: 1px solid var(--accent-green);
            border-radius: 20px;
            padding: 8px 20px;
            font-size: 0.8em;
            color: var(--accent-green);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease, background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }

        #connection-mode-indicator.visible { opacity: 1; }
        
        #connection-mode-indicator.disconnect {
            background: rgba(157, 77, 255, 0.2);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
        }

        /* Indicador de modo edici√≥n */
        #edit-mode-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(77, 255, 136, 0.2);
            border: 1px solid var(--accent-green);
            border-radius: 20px;
            padding: 8px 20px;
            font-size: 0.8em;
            color: var(--accent-green);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #edit-mode-indicator.visible { opacity: 1; }

        #help-tooltip {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--primary-glow);
            border-radius: 16px;
            padding: 30px 40px;
            max-width: 500px;
            z-index: 600;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #help-tooltip.visible { opacity: 1; pointer-events: auto; }
        #help-tooltip h2 {
            font-family: 'Cinzel', serif;
            color: var(--primary-glow);
            margin-bottom: 20px;
            text-align: center;
        }
        #help-tooltip .help-section { margin: 15px 0; }
        #help-tooltip .help-section h4 { color: var(--accent-green); margin-bottom: 8px; }
        #help-tooltip .help-section p { color: rgba(255, 255, 255, 0.7); font-size: 0.85em; line-height: 1.6; }
        #help-tooltip .close-help {
            position: absolute;
            top: 15px; right: 15px;
            background: none;
            border: none;
            color: var(--primary-glow);
            font-size: 1.5em;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="webgl-container"></div>
    <div id="css-container"></div>

    <div id="coordinates">
        <span class="coord-label">X:</span><span class="coord-value" id="coord-x">0</span>
        <span class="coord-label">Y:</span><span class="coord-value" id="coord-y">0</span>
        <span class="coord-label">Z:</span><span class="coord-value" id="coord-z">0</span>
    </div>

    <div id="instructions">
        <kbd>Doble click</kbd> crear idea ‚Ä¢ <kbd>Arrastrar sobre otra</kbd> conectar/desconectar<br>
        <kbd>W A S D</kbd> moverse ‚Ä¢ <kbd>Q E</kbd> rotar ‚Ä¢ <kbd>Z X</kbd> subir/bajar ‚Ä¢ <kbd>Mouse</kbd> girar c√°mara
    </div>

    <div id="stats-panel">
        <h3>MYCELIUM</h3>
        <div class="stat"><span>Nodos:</span><span class="stat-value" id="node-count">0</span></div>
        <div class="stat"><span>Conexiones:</span><span class="stat-value" id="connection-count">0</span></div>
    </div>

    <div class="action-buttons">
        <button class="action-btn" id="btn-help" title="Ayuda">?</button>
        <button class="action-btn" id="btn-center" title="Centrar vista">‚åñ</button>
        <button class="action-btn" id="btn-save" title="Guardar">üíæ</button>
        <button class="action-btn" id="btn-load" title="Cargar">üìÇ</button>
        <input type="file" id="file-input" accept=".mycelium,.json" style="display: none;">
    </div>

    <div id="node-input-modal">
        <div class="input-wrapper">
            <textarea id="node-input" placeholder="..." rows="1"></textarea>
        </div>
    </div>

    <div id="connection-mode-indicator">
        <span id="indicator-text">üîó Suelta para conectar</span>
    </div>

    <div id="edit-mode-indicator">
        ‚úèÔ∏è Modo edici√≥n - Escape para salir
    </div>

    <div id="help-tooltip">
        <button class="close-help" id="close-help">√ó</button>
        <h2>Mycelium Mind</h2>
        <div class="help-section">
            <h4>üå± Crear Ideas</h4>
            <p>Doble click donde quieras crear una nota. El nodo aparece exactamente ah√≠.</p>
        </div>
        <div class="help-section">
            <h4>üîó Conectar / Desconectar</h4>
            <p>Arrastra un nodo sobre otro:<br>
            <strong style="color:#4DFF88">Verde</strong> = crear conexi√≥n<br>
            <strong style="color:#9D4DFF">Morado</strong> = eliminar conexi√≥n existente</p>
        </div>
        <div class="help-section">
            <h4>üéÆ Navegaci√≥n</h4>
            <p><strong>WASD:</strong> Moverse ‚Ä¢ <strong>QE:</strong> Rotar ‚Ä¢ <strong>ZX:</strong> Subir/Bajar<br>
            <strong>Mouse:</strong> Girar c√°mara ‚Ä¢ <strong>Scroll:</strong> Zoom<br>
            <strong>Con nodo seleccionado:</strong> Orbita alrededor del nodo</p>
        </div>
        <div class="help-section">
            <h4>‚úèÔ∏è Editar</h4>
            <p>Doble click en nodo para editar (zoom autom√°tico). <strong>Delete:</strong> Eliminar.</p>
        </div>
    </div>

    <script>
        const CONFIG = {
            nodeScale: 0.012,
            connectionSegments: 20,
            connectionAmplitude: 0.2,
            cameraSpeed: 0.2,
            rotationSpeed: 0.012,
            mouseSensitivity: 0.002,
            zoomSpeed: 0.015,
            minZoom: 3,
            maxZoom: 100,
            connectionThreshold: 2.5,
            editZoomDistance: 6,
            transitionSpeed: 0.08
        };

        let scene, camera, webglRenderer, cssRenderer, clock;
        let avatarObject;
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let draggedNode = null;
        let ghostCSSObject = null; // Objeto fantasma CSS3D
        let potentialTarget = null;
        let targetAction = null;

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        let rotateLeft = false, rotateRight = false;

        let yawAngle = 0, pitchAngle = 0;
        let zoomDistance = 15;
        let isCameraDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        let isCreatingNode = false;
        let pendingNodeScreenPosition = null; // Guardar posici√≥n de PANTALLA

        // MODO EDICI√ìN
        let isEditingNode = false;
        let editingNode = null;

        // TRANSICI√ìN DE C√ÅMARA
        let isTransitioning = false;
        let transitionTarget = null;
        let transitionCallback = null;

        // √ìRBITA alrededor de nodo seleccionado
        let orbitCenter = null;
        let orbitDistance = 15;
        let orbitYaw = 0;
        let orbitPitch = 0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x02040a, 50, 200);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);

            const avatarGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const avatarMaterial = new THREE.MeshBasicMaterial({ visible: false });
            avatarObject = new THREE.Mesh(avatarGeometry, avatarMaterial);
            avatarObject.position.set(0, 0, 0);
            scene.add(avatarObject);

            webglRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            webglRenderer.setClearColor(0x02040a, 1);
            document.getElementById('webgl-container').appendChild(webglRenderer.domElement);

            cssRenderer = new THREE.CSS3DRenderer();
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('css-container').appendChild(cssRenderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);

            createSporeField();
            createReferenceGrid();
            initEventListeners();

            setTimeout(() => {
                document.getElementById('instructions').classList.add('hidden');
            }, 8000);

            updateStats();
        }

        function createSporeField() {
            const sporeCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(sporeCount * 3);
            const colors = new Float32Array(sporeCount * 3);

            for (let i = 0; i < sporeCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 300;
                positions[i3 + 1] = (Math.random() - 0.5) * 300;
                positions[i3 + 2] = (Math.random() - 0.5) * 300;

                const t = Math.random();
                colors[i3] = 0.3 + t * 0.2;
                colors[i3 + 1] = 0.8 + t * 0.2;
                colors[i3 + 2] = 1 - t * 0.4;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.12,
                vertexColors: true,
                transparent: true,
                opacity: 0.5
            });

            scene.add(new THREE.Points(geometry, material));
        }

        function createReferenceGrid() {
            const gridHelper = new THREE.GridHelper(150, 30, 0x1a3a4a, 0x0a1a2a);
            gridHelper.position.y = -20;
            gridHelper.material.opacity = 0.25;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        function initEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onMouseWheel);
            document.addEventListener('dblclick', onDoubleClick);
            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('click', onDocumentClick);

            document.getElementById('btn-help').addEventListener('click', toggleHelp);
            document.getElementById('btn-center').addEventListener('click', centerView);
            document.getElementById('btn-save').addEventListener('click', saveMap);
            document.getElementById('btn-load').addEventListener('click', () => document.getElementById('file-input').click());
            document.getElementById('file-input').addEventListener('change', loadMap);
            document.getElementById('close-help').addEventListener('click', toggleHelp);

            const nodeInput = document.getElementById('node-input');
            nodeInput.addEventListener('keydown', onNodeInputKeyDown);
            nodeInput.addEventListener('input', autoResizeInput);
            nodeInput.addEventListener('blur', onNodeInputBlur);
        }

        function onDocumentClick(event) {
            const helpTooltip = document.getElementById('help-tooltip');
            if (helpTooltip.classList.contains('visible')) {
                if (!event.target.closest('#help-tooltip') && !event.target.closest('#btn-help')) {
                    helpTooltip.classList.remove('visible');
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            // Si est√° editando, bloquear teclas de movimiento
            if (isEditingNode) {
                if (event.key === 'Escape') {
                    exitEditMode();
                }
                return; // Bloquear WASD, QE, ZX
            }
            
            if (isCreatingNode) return;
            
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyZ': moveUp = true; break;
                case 'KeyX': moveDown = true; break;
                case 'KeyQ': rotateLeft = true; break;
                case 'KeyE': rotateRight = true; break;
                case 'Delete':
                case 'Backspace':
                    if (selectedNode && !isCreatingNode && !isEditingNode) {
                        event.preventDefault();
                        deleteNode(selectedNode);
                    }
                    break;
                case 'Escape':
                    cancelNodeCreation();
                    deselectNode();
                    document.getElementById('help-tooltip').classList.remove('visible');
                    break;
            }
        }

        function onKeyUp(event) {
            if (isEditingNode) return;
            
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyZ': moveUp = false; break;
                case 'KeyX': moveDown = false; break;
                case 'KeyQ': rotateLeft = false; break;
                case 'KeyE': rotateRight = false; break;
            }
        }

        function onMouseDown(event) {
            if (event.target.closest('.action-btn, #help-tooltip, #stats-panel, #node-input-modal, #coordinates')) return;
            if (isEditingNode) return;
            
            updateMouse(event);
            
            if (event.button === 0) {
                const hit = raycastNodes();
                
                if (hit) {
                    selectNode(hit.node);
                    startDraggingNode(hit.node);
                } else {
                    deselectNode();
                    isCameraDragging = true;
                }
            } else if (event.button === 2) {
                isCameraDragging = true;
            }
            
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp() {
            if (draggedNode) finishDraggingNode();
            isCameraDragging = false;
        }

        function onMouseMove(event) {
            updateMouse(event);
            
            if (draggedNode) {
                updateGhostPosition(event);
                checkConnectionTarget();
            } else if (isCameraDragging && !isEditingNode) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                if (selectedNode && orbitCenter) {
                    // ORBITAR alrededor del nodo seleccionado
                    orbitYaw -= deltaX * CONFIG.mouseSensitivity;
                    orbitPitch -= deltaY * CONFIG.mouseSensitivity;
                    orbitPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, orbitPitch));
                } else {
                    // Movimiento normal
                    yawAngle -= deltaX * CONFIG.mouseSensitivity;
                    pitchAngle -= deltaY * CONFIG.mouseSensitivity;
                    pitchAngle = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitchAngle));
                }
            }
            
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseWheel(event) {
            if (selectedNode && orbitCenter) {
                orbitDistance += event.deltaY * CONFIG.zoomSpeed;
                orbitDistance = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, orbitDistance));
            } else {
                zoomDistance += event.deltaY * CONFIG.zoomSpeed;
                zoomDistance = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, zoomDistance));
            }
        }

        function onDoubleClick(event) {
            if (event.target.closest('.action-btn, #help-tooltip, #stats-panel, #coordinates, #node-input-modal')) return;
            if (isCreatingNode || isEditingNode) return;
            
            updateMouse(event);
            
            const hit = raycastNodes();
            if (hit) {
                // Editar nodo existente con zoom
                enterEditMode(hit.node);
                return;
            }
            
            // Crear nuevo nodo - guardar posici√≥n de PANTALLA
            pendingNodeScreenPosition = { x: event.clientX, y: event.clientY };
            showNodeInput(event.clientX, event.clientY);
        }

        function updateMouse(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function raycastNodes() {
            raycaster.setFromCamera(mouse, camera);
            
            const proxyObjects = nodes.map(n => n.proxyObject).filter(Boolean);
            const intersects = raycaster.intersectObjects(proxyObjects);
            
            if (intersects.length > 0) {
                const proxy = intersects[0].object;
                const node = nodes.find(n => n.proxyObject === proxy);
                return { node, intersection: intersects[0] };
            }
            return null;
        }

        // Convertir posici√≥n de pantalla a mundo 3D
        function screenToWorld(screenX, screenY) {
            const ndcX = (screenX / window.innerWidth) * 2 - 1;
            const ndcY = -(screenY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera({ x: ndcX, y: ndcY }, camera);
            
            // Plano a distancia fija frente a la c√°mara
            const distance = 8;
            const point = raycaster.ray.at(distance, new THREE.Vector3());
            
            return point;
        }

        function createNode(text, position) {
            const id = 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            const div = document.createElement('div');
            div.className = 'idea-node';
            div.dataset.nodeId = id;
            
            const content = document.createElement('div');
            content.className = 'node-content';
            content.textContent = text;
            content.contentEditable = false;
            
            div.appendChild(content);
            
            const cssObject = new THREE.CSS3DObject(div);
            cssObject.scale.set(CONFIG.nodeScale, CONFIG.nodeScale, CONFIG.nodeScale);
            cssObject.position.copy(position);
            
            const textLength = text.length;
            const proxyWidth = Math.max(60, Math.min(300, textLength * 7)) * CONFIG.nodeScale;
            const proxyHeight = Math.max(30, Math.ceil(textLength / 35) * 22) * CONFIG.nodeScale;
            
            const proxyGeometry = new THREE.PlaneGeometry(proxyWidth, proxyHeight);
            const proxyMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const proxyObject = new THREE.Mesh(proxyGeometry, proxyMaterial);
            proxyObject.position.copy(position);
            
            scene.add(cssObject);
            scene.add(proxyObject);
            
            const node = {
                id, text,
                position: position.clone(),
                cssObject, proxyObject,
                element: div,
                connections: []
            };
            
            nodes.push(node);
            updateStats();
            
            return node;
        }

        function selectNode(node) {
            if (selectedNode) selectedNode.element.classList.remove('selected');
            selectedNode = node;
            node.element.classList.add('selected');
            
            // Configurar √≥rbita alrededor de este nodo
            orbitCenter = node.position.clone();
            orbitDistance = camera.position.distanceTo(node.position);
            
            // Calcular √°ngulos actuales
            const dir = new THREE.Vector3().subVectors(camera.position, node.position).normalize();
            orbitYaw = Math.atan2(dir.x, dir.z);
            orbitPitch = Math.asin(dir.y);
        }

        function deselectNode() {
            if (selectedNode) {
                selectedNode.element.classList.remove('selected');
                selectedNode = null;
            }
            orbitCenter = null;
        }

        function deleteNode(node) {
            const connectionsToRemove = connections.filter(c => c.nodeA === node || c.nodeB === node);
            connectionsToRemove.forEach(c => {
                scene.remove(c.line);
                const idx = connections.indexOf(c);
                if (idx > -1) connections.splice(idx, 1);
                
                const idxA = c.nodeA.connections.indexOf(c);
                if (idxA > -1) c.nodeA.connections.splice(idxA, 1);
                const idxB = c.nodeB.connections.indexOf(c);
                if (idxB > -1) c.nodeB.connections.splice(idxB, 1);
            });
            
            scene.remove(node.cssObject);
            scene.remove(node.proxyObject);
            
            const idx = nodes.indexOf(node);
            if (idx > -1) nodes.splice(idx, 1);
            
            if (selectedNode === node) deselectNode();
            if (editingNode === node) exitEditMode();
            
            updateStats();
        }

        // ============ MODO EDICI√ìN ============
        function enterEditMode(node) {
            isEditingNode = true;
            editingNode = node;
            
            selectNode(node);
            node.element.classList.add('editing');
            
            document.getElementById('edit-mode-indicator').classList.add('visible');
            
            // Calcular distancia al nodo
            const distanceToNode = camera.position.distanceTo(node.position);
            
            if (distanceToNode > CONFIG.editZoomDistance * 2) {
                // Hacer zoom transicional
                transitionToNode(node, () => {
                    startEditing(node);
                });
            } else {
                startEditing(node);
            }
        }

        function transitionToNode(node, callback) {
            isTransitioning = true;
            transitionTarget = {
                position: node.position.clone(),
                distance: CONFIG.editZoomDistance
            };
            transitionCallback = callback;
        }

        function startEditing(node) {
            const content = node.element.querySelector('.node-content');
            content.contentEditable = true;
            content.focus();
            
            const range = document.createRange();
            range.selectNodeContents(content);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            content.addEventListener('blur', onEditBlur);
            content.addEventListener('keydown', onEditKeyDown);
        }

        function onEditBlur(event) {
            // Peque√±o delay para verificar si el foco se movi√≥ a otro elemento v√°lido
            setTimeout(() => {
                if (isEditingNode && editingNode) {
                    exitEditMode();
                }
            }, 100);
        }

        function onEditKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                exitEditMode();
            }
            if (event.key === 'Escape') {
                exitEditMode();
            }
            // Permitir todas las dem√°s teclas para escribir
            event.stopPropagation();
        }

        function exitEditMode() {
            if (!editingNode) return;
            
            const content = editingNode.element.querySelector('.node-content');
            content.contentEditable = false;
            content.removeEventListener('blur', onEditBlur);
            content.removeEventListener('keydown', onEditKeyDown);
            
            editingNode.text = content.textContent;
            updateNodeProxy(editingNode);
            
            editingNode.element.classList.remove('editing');
            
            document.getElementById('edit-mode-indicator').classList.remove('visible');
            
            isEditingNode = false;
            editingNode = null;
        }

        function updateNodeProxy(node) {
            const textLength = node.text.length;
            const proxyWidth = Math.max(60, Math.min(300, textLength * 7)) * CONFIG.nodeScale;
            const proxyHeight = Math.max(30, Math.ceil(textLength / 35) * 22) * CONFIG.nodeScale;
            
            node.proxyObject.geometry.dispose();
            node.proxyObject.geometry = new THREE.PlaneGeometry(proxyWidth, proxyHeight);
        }

        // ============ ARRASTRE Y CONEXIONES ============
        function startDraggingNode(node) {
            draggedNode = node;
            node.element.classList.add('dragging');
            
            // Crear fantasma CSS3D
            createGhostNode(node);
            
            const indicator = document.getElementById('connection-mode-indicator');
            indicator.classList.add('visible');
            indicator.classList.remove('disconnect');
            document.getElementById('indicator-text').textContent = 'üîó Arrastra sobre otro nodo';
        }

        function createGhostNode(node) {
            const ghostDiv = document.createElement('div');
            ghostDiv.className = 'idea-node ghost';
            ghostDiv.innerHTML = node.element.innerHTML;
            
            ghostCSSObject = new THREE.CSS3DObject(ghostDiv);
            ghostCSSObject.scale.copy(node.cssObject.scale);
            ghostCSSObject.position.copy(node.cssObject.position);
            
            scene.add(ghostCSSObject);
        }

        function updateGhostPosition(event) {
            if (!ghostCSSObject || !draggedNode) return;
            
            // Mover el fantasma siguiendo el cursor
            const worldPos = screenToWorld(event.clientX, event.clientY);
            ghostCSSObject.position.copy(worldPos);
        }

        function checkConnectionTarget() {
            if (!draggedNode) return;
            
            if (potentialTarget) {
                potentialTarget.element.classList.remove('connection-target', 'disconnect-target');
            }
            potentialTarget = null;
            targetAction = null;
            
            const indicator = document.getElementById('connection-mode-indicator');
            indicator.classList.remove('disconnect');
            document.getElementById('indicator-text').textContent = 'üîó Arrastra sobre otro nodo';
            
            const hit = raycastNodes();
            if (!hit || hit.node === draggedNode) return;
            
            const targetNode = hit.node;
            
            const existingConnection = connections.find(
                c => (c.nodeA === draggedNode && c.nodeB === targetNode) ||
                     (c.nodeA === targetNode && c.nodeB === draggedNode)
            );
            
            potentialTarget = targetNode;
            
            if (existingConnection) {
                targetAction = 'disconnect';
                targetNode.element.classList.add('disconnect-target');
                indicator.classList.add('disconnect');
                document.getElementById('indicator-text').textContent = '‚úÇÔ∏è Suelta para DESCONECTAR';
            } else {
                targetAction = 'connect';
                targetNode.element.classList.add('connection-target');
                document.getElementById('indicator-text').textContent = 'üîó Suelta para CONECTAR';
            }
        }

        function finishDraggingNode() {
            if (!draggedNode) return;
            
            draggedNode.element.classList.remove('dragging');
            
            // Remover fantasma
            if (ghostCSSObject) {
                scene.remove(ghostCSSObject);
                ghostCSSObject = null;
            }
            
            if (potentialTarget && targetAction) {
                if (targetAction === 'connect') {
                    createConnection(draggedNode, potentialTarget);
                } else if (targetAction === 'disconnect') {
                    removeConnection(draggedNode, potentialTarget);
                }
                potentialTarget.element.classList.remove('connection-target', 'disconnect-target');
            }
            
            potentialTarget = null;
            targetAction = null;
            draggedNode = null;
            
            document.getElementById('connection-mode-indicator').classList.remove('visible', 'disconnect');
        }

        function createConnection(nodeA, nodeB) {
            const existing = connections.find(
                c => (c.nodeA === nodeA && c.nodeB === nodeB) ||
                     (c.nodeA === nodeB && c.nodeB === nodeA)
            );
            if (existing) return;
            
            const curve = new THREE.CatmullRomCurve3(
                generateCurvePoints(nodeA.position, nodeB.position)
            );
            
            const geometry = new THREE.TubeGeometry(curve, CONFIG.connectionSegments, 0.02, 6, false);
            const material = new THREE.MeshBasicMaterial({
                color: 0x4DDBFF,
                transparent: true,
                opacity: 0.6
            });
            
            const line = new THREE.Mesh(geometry, material);
            scene.add(line);
            
            const connection = {
                id: 'conn_' + Date.now(),
                nodeA, nodeB,
                line, curve,
                phase: Math.random() * Math.PI * 2
            };
            
            connections.push(connection);
            nodeA.connections.push(connection);
            nodeB.connections.push(connection);
            
            updateStats();
            
            return connection;
        }

        function removeConnection(nodeA, nodeB) {
            const connection = connections.find(
                c => (c.nodeA === nodeA && c.nodeB === nodeB) ||
                     (c.nodeA === nodeB && c.nodeB === nodeA)
            );
            
            if (!connection) return;
            
            scene.remove(connection.line);
            
            const idx = connections.indexOf(connection);
            if (idx > -1) connections.splice(idx, 1);
            
            const idxA = nodeA.connections.indexOf(connection);
            if (idxA > -1) nodeA.connections.splice(idxA, 1);
            
            const idxB = nodeB.connections.indexOf(connection);
            if (idxB > -1) nodeB.connections.splice(idxB, 1);
            
            updateStats();
        }

        function generateCurvePoints(start, end) {
            const points = [];
            const perpendicular = new THREE.Vector3()
                .subVectors(end, start)
                .cross(new THREE.Vector3(0, 1, 0))
                .normalize();
            
            const distance = start.distanceTo(end);
            const amplitude = CONFIG.connectionAmplitude * distance;
            
            points.push(start.clone());
            
            for (let i = 1; i < 4; i++) {
                const t = i / 4;
                const point = new THREE.Vector3().lerpVectors(start, end, t);
                
                const wave = Math.sin(t * Math.PI) * amplitude;
                const noise = (Math.random() - 0.5) * amplitude * 0.2;
                
                point.add(perpendicular.clone().multiplyScalar(wave + noise));
                point.y += Math.sin(t * Math.PI * 2) * amplitude * 0.2;
                
                points.push(point);
            }
            
            points.push(end.clone());
            
            return points;
        }

        function animateConnections(time) {
            connections.forEach(connection => {
                const pulse = Math.sin(time * 2 + connection.phase) * 0.15 + 0.6;
                connection.line.material.opacity = pulse;
            });
        }

        // ============ INPUT DE NUEVO NODO ============
        function showNodeInput(screenX, screenY) {
            isCreatingNode = true;
            
            const modal = document.getElementById('node-input-modal');
            const input = document.getElementById('node-input');
            
            modal.style.left = screenX + 'px';
            modal.style.top = screenY + 'px';
            modal.classList.add('visible');
            
            input.value = '';
            input.style.width = '50px';
            input.style.height = 'auto';
            
            setTimeout(() => input.focus(), 10);
        }

        function autoResizeInput() {
            const input = document.getElementById('node-input');
            
            input.style.height = 'auto';
            input.style.width = 'auto';
            
            const textWidth = Math.max(50, Math.min(350, input.scrollWidth + 5));
            input.style.width = textWidth + 'px';
            input.style.height = input.scrollHeight + 'px';
        }

        function onNodeInputKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                confirmNodeCreation();
            }
            if (event.key === 'Escape') {
                cancelNodeCreation();
            }
            event.stopPropagation();
        }

        function onNodeInputBlur(event) {
            const input = document.getElementById('node-input');
            if (input.value.trim()) {
                confirmNodeCreation();
            } else {
                cancelNodeCreation();
            }
        }

        function confirmNodeCreation() {
            const input = document.getElementById('node-input');
            const text = input.value.trim();
            
            if (text && pendingNodeScreenPosition) {
                // Convertir posici√≥n de PANTALLA a MUNDO
                const worldPos = screenToWorld(pendingNodeScreenPosition.x, pendingNodeScreenPosition.y);
                createNode(text, worldPos);
            }
            
            cancelNodeCreation();
        }

        function cancelNodeCreation() {
            isCreatingNode = false;
            pendingNodeScreenPosition = null;
            document.getElementById('node-input-modal').classList.remove('visible');
        }

        function updateStats() {
            document.getElementById('node-count').textContent = nodes.length;
            document.getElementById('connection-count').textContent = connections.length;
        }

        function updateCoordinates() {
            document.getElementById('coord-x').textContent = Math.round(avatarObject.position.x);
            document.getElementById('coord-y').textContent = Math.round(avatarObject.position.y);
            document.getElementById('coord-z').textContent = Math.round(avatarObject.position.z);
        }

        function toggleHelp() {
            document.getElementById('help-tooltip').classList.toggle('visible');
        }

        function centerView() {
            if (nodes.length === 0) {
                avatarObject.position.set(0, 0, 0);
                return;
            }
            
            const center = new THREE.Vector3();
            nodes.forEach(n => center.add(n.position));
            center.divideScalar(nodes.length);
            
            avatarObject.position.copy(center);
            orbitCenter = null;
            deselectNode();
        }

        function saveMap() {
            const data = {
                version: '1.0',
                name: 'Mycelium Mind Map',
                created: new Date().toISOString(),
                nodes: nodes.map(n => ({
                    id: n.id,
                    text: n.text,
                    position: n.position.toArray()
                })),
                connections: connections.map(c => ({
                    nodeA: c.nodeA.id,
                    nodeB: c.nodeB.id
                })),
                camera: {
                    position: avatarObject.position.toArray(),
                    yaw: yawAngle,
                    pitch: pitchAngle,
                    zoom: zoomDistance
                }
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mycelium-mind-' + Date.now() + '.mycelium';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function loadMap(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    clearAll();
                    
                    const nodeMap = {};
                    data.nodes.forEach(n => {
                        const position = new THREE.Vector3().fromArray(n.position);
                        const node = createNode(n.text, position);
                        node.id = n.id;
                        nodeMap[n.id] = node;
                    });
                    
                    data.connections.forEach(c => {
                        const nodeA = nodeMap[c.nodeA];
                        const nodeB = nodeMap[c.nodeB];
                        if (nodeA && nodeB) {
                            createConnection(nodeA, nodeB);
                        }
                    });
                    
                    if (data.camera) {
                        avatarObject.position.fromArray(data.camera.position);
                        yawAngle = data.camera.yaw || 0;
                        pitchAngle = data.camera.pitch || 0;
                        zoomDistance = data.camera.zoom || 15;
                    }
                    
                } catch (err) {
                    console.error('Error loading file:', err);
                    alert('Error al cargar el archivo');
                }
            };
            reader.readAsText(file);
            
            event.target.value = '';
        }

        function clearAll() {
            connections.forEach(c => scene.remove(c.line));
            connections = [];
            
            nodes.forEach(n => {
                scene.remove(n.cssObject);
                scene.remove(n.proxyObject);
            });
            nodes = [];
            
            selectedNode = null;
            orbitCenter = null;
            updateStats();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Transici√≥n de c√°mara
            if (isTransitioning && transitionTarget) {
                const targetPos = transitionTarget.position.clone();
                const dir = new THREE.Vector3().subVectors(camera.position, targetPos).normalize();
                const targetCamPos = targetPos.clone().add(dir.multiplyScalar(transitionTarget.distance));
                
                camera.position.lerp(targetCamPos, CONFIG.transitionSpeed);
                
                if (camera.position.distanceTo(targetCamPos) < 0.1) {
                    isTransitioning = false;
                    if (transitionCallback) {
                        transitionCallback();
                        transitionCallback = null;
                    }
                }
            } else if (!isEditingNode) {
                updateMovement(delta);
                updateCamera();
            }
            
            updateCoordinates();
            
            nodes.forEach(node => {
                node.cssObject.lookAt(camera.position);
                node.proxyObject.lookAt(camera.position);
            });
            
            if (ghostCSSObject) {
                ghostCSSObject.lookAt(camera.position);
            }
            
            animateConnections(time);
            
            webglRenderer.render(scene, camera);
            cssRenderer.render(scene, camera);
        }

        function updateMovement(delta) {
            const speed = CONFIG.cameraSpeed;
            
            if (rotateLeft) {
                if (orbitCenter) {
                    orbitYaw += CONFIG.rotationSpeed;
                } else {
                    yawAngle += CONFIG.rotationSpeed;
                }
            }
            if (rotateRight) {
                if (orbitCenter) {
                    orbitYaw -= CONFIG.rotationSpeed;
                } else {
                    yawAngle -= CONFIG.rotationSpeed;
                }
            }
            
            if (!orbitCenter) {
                const direction = new THREE.Vector3(
                    -Math.sin(yawAngle),
                    0,
                    -Math.cos(yawAngle)
                );
                
                const right = new THREE.Vector3(
                    -Math.sin(yawAngle - Math.PI / 2),
                    0,
                    -Math.cos(yawAngle - Math.PI / 2)
                );
                
                if (moveForward) avatarObject.position.addScaledVector(direction, speed);
                if (moveBackward) avatarObject.position.addScaledVector(direction, -speed);
                if (moveLeft) avatarObject.position.addScaledVector(right, -speed);
                if (moveRight) avatarObject.position.addScaledVector(right, speed);
                if (moveUp) avatarObject.position.y += speed;
                if (moveDown) avatarObject.position.y -= speed;
            }
        }

        function updateCamera() {
            if (orbitCenter && selectedNode) {
                // Modo √≥rbita alrededor del nodo seleccionado
                const x = Math.sin(orbitYaw) * Math.cos(orbitPitch) * orbitDistance;
                const y = Math.sin(orbitPitch) * orbitDistance;
                const z = Math.cos(orbitYaw) * Math.cos(orbitPitch) * orbitDistance;
                
                camera.position.set(
                    orbitCenter.x + x,
                    orbitCenter.y + y,
                    orbitCenter.z + z
                );
                camera.lookAt(orbitCenter);
                
                // Actualizar posici√≥n del avatar
                avatarObject.position.copy(orbitCenter);
            } else {
                // Modo normal
                const quaternion = new THREE.Quaternion().setFromEuler(
                    new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ')
                );
                
                const offset = new THREE.Vector3(0, 0, zoomDistance);
                offset.applyQuaternion(quaternion);
                
                camera.position.copy(avatarObject.position).add(offset);
                camera.lookAt(avatarObject.position);
            }
        }
    </script>
</body>
</html>
