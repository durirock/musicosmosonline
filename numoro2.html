<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aureum Nebulae - Sacred Geometry</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', sans-serif;
            color: #00f2ff;
            user-select: none;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 10px #00f2ff, 0 0 20px #00f2ff;
        }
        canvas { display: block; }
        
        /* Controles Táctiles Minimalistas */
        .touch-zone {
            position: fixed;
            bottom: 40px;
            width: 100px;
            height: 100px;
            background: rgba(0, 242, 255, 0.03);
            border: 1px solid rgba(0, 242, 255, 0.15);
            border-radius: 50%;
            z-index: 1000;
            transition: opacity 1s ease;
            opacity: 0; 
            pointer-events: auto;
        }
        #joy-left { left: 30px; }
        #joy-right { right: 30px; }
        .knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 34px; height: 34px;
            margin: -17px;
            background: rgba(0, 242, 255, 0.2);
            border: 1px solid rgba(0, 242, 255, 0.4);
            border-radius: 50%;
            pointer-events: none;
        }

        #loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 2s ease;
            letter-spacing: 5px;
            font-size: 0.8rem;
            color: #fff;
            text-shadow: 0 0 10px #fff;
        }
    </style>
</head>
<body>

<div id="loading">
    <div style="margin-bottom: 20px;">SINTETIZANDO LUZ FRACTAL...</div>
</div>

<div id="ui">
    <h1 style="margin:0; font-size: 1rem; font-weight: 800; letter-spacing: 4px;">AUREUM NEBULAE</h1>
    <div id="stats" style="font-size: 0.7rem; margin-top: 5px; opacity: 0.9; font-weight: bold;">
        SECTOR: <span id="pos-info">0, 0, 0</span><br>
        PARTÍCULAS: <span id="part-count">0</span><br>
        <span id="stereo-status" style="color: #ffcc00;"></span>
    </div>
</div>

<!-- Contenedores de Joysticks -->
<div id="joy-left" class="touch-zone"><div class="knob" id="knob-left"></div></div>
<div id="joy-right" class="touch-zone"><div class="knob" id="knob-right"></div></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    const GOLDEN_ANGLE = (3 - Math.sqrt(5)) * Math.PI;
    const SECTOR_SIZE = 700;
    const PARTICLES_PER_SYSTEM = 12000;
    
    let scene, camera, renderer, clock, circleTexture;
    let sectors = new Map();
    const keys = {};
    let rotation = { x: 0, y: 0, z: 0 };

    // Configuración Estereoscópica
    let isStereoMode = false;
    let eyeSeparation = 1.2;

    // Gestión Táctil e Inactividad
    let isTouchDevice = false;
    let lastUserActionTime = Date.now();
    const joyLeft = { active: false, x: 0, y: 0 };
    const joyRight = { active: false, x: 0, y: 0 };

    function createCircleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.4, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        return new THREE.CanvasTexture(canvas);
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.0010);

        circleTexture = createCircleTexture();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 0, 150);

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        if(isTouchDevice) initTouchEvents();

        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onResize);
        renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());

        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => document.getElementById('loading').remove(), 2000);

        animate();
    }

    function updateStereoStatus() {
        const statusElement = document.getElementById('stereo-status');
        if (isStereoMode) {
            statusElement.innerText = `MODO ESTÉREO ACTIVO | PROFUNDIDAD: ${eyeSeparation.toFixed(1)}`;
        } else {
            statusElement.innerText = "";
        }
    }

    function onKeyDown(e) {
        keys[e.code] = true;
        lastUserActionTime = Date.now();
        
        if (e.code === 'Digit3' || e.code === 'Numpad3') {
            isStereoMode = !isStereoMode;
            updateStereoStatus();
            onResize(); 
        }

        if (isStereoMode) {
            if (e.code === 'Digit9' || e.code === 'Numpad9') {
                eyeSeparation += 0.1;
                updateStereoStatus();
            }
            if (e.code === 'Digit0' || e.code === 'Numpad0') {
                eyeSeparation = Math.max(0.1, eyeSeparation - 0.1);
                updateStereoStatus();
            }
        }
    }

    function initTouchEvents() {
        const handleStart = (e, joy, knobId) => {
            e.preventDefault();
            joy.active = true;
            lastUserActionTime = Date.now();
            updateJoy(e.targetTouches[0], joy, knobId);
        };
        const handleMove = (e, joy, knobId) => {
            e.preventDefault();
            if(!joy.active) return;
            lastUserActionTime = Date.now();
            updateJoy(e.targetTouches[0], joy, knobId);
        };
        const handleEnd = (joy, knobId) => {
            joy.active = false;
            joy.x = 0; joy.y = 0;
            document.getElementById(knobId).style.transform = `translate(0px, 0px)`;
        };
        const updateJoy = (touch, joy, knobId) => {
            const zone = document.getElementById(knobId).parentElement;
            const rect = zone.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let dx = (touch.clientX - centerX) / (rect.width / 2);
            let dy = (touch.clientY - centerY) / (rect.height / 2);
            const limit = Math.sqrt(dx*dx + dy*dy);
            if(limit > 1) { dx /= limit; dy /= limit; }
            joy.x = dx; joy.y = dy;
            document.getElementById(knobId).style.transform = `translate(${dx * 30}px, ${dy * 30}px)`;
        };

        const L = document.getElementById('joy-left'), R = document.getElementById('joy-right');
        L.addEventListener('touchstart', e => handleStart(e, joyLeft, 'knob-left'));
        L.addEventListener('touchmove', e => handleMove(e, joyLeft, 'knob-left'));
        L.addEventListener('touchend', () => handleEnd(joyLeft, 'knob-left'));
        R.addEventListener('touchstart', e => handleStart(e, joyRight, 'knob-right'));
        R.addEventListener('touchmove', e => handleMove(e, joyRight, 'knob-right'));
        R.addEventListener('touchend', () => handleEnd(joyRight, 'knob-right'));
        window.addEventListener('touchstart', () => { lastUserActionTime = Date.now(); }, {passive: true});
    }

    class GoldenNebula {
        constructor(ix, iy, iz) {
            this.id = `${ix},${iy},${iz}`;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLES_PER_SYSTEM * 3);
            const colors = new Float32Array(PARTICLES_PER_SYSTEM * 3);
            const sizes = new Float32Array(PARTICLES_PER_SYSTEM);

            const seed = Math.abs(Math.sin(ix * 12.98 + iy * 78.23 + iz * 45.16) * 43758.54);
            this.seed = seed;
            this.hueBase = (seed * 0.7) % 1;
            this.breathSpeed = 0.5 + (seed % 0.8);
            this.breathPhase = seed * Math.PI;

            const complexity = 2 + Math.floor(seed * 6);
            const tightness = 0.8 + (seed % 0.4);
            const baseRadius = 180 * (0.5 + (seed % 1.5));

            for (let i = 0; i < PARTICLES_PER_SYSTEM; i++) {
                const t = i / PARTICLES_PER_SYSTEM;
                const phi = Math.acos(1 - 2 * t * tightness);
                const theta = i * GOLDEN_ANGLE;
                const petalMod = 1 + (0.2 + (seed % 0.5)) * Math.sin(theta * complexity + seed);
                const r = baseRadius * Math.sqrt(t) * petalMod;
                
                positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i*3+2] = r * Math.cos(phi) + Math.sin(i * 0.05 + seed) * 15;

                const color = new THREE.Color().setHSL((this.hueBase + t * 0.15) % 1, 1.0, 0.75);
                colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
                sizes[i] = (Math.random() * 5 + 2) * (1 - t * 0.4);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            this.points = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 4, map: circleTexture, vertexColors: true, transparent: true,
                opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true
            }));
            this.points.position.set(ix * SECTOR_SIZE, iy * SECTOR_SIZE, iz * SECTOR_SIZE);
            this.points.rotation.set(seed, seed, seed);
            scene.add(this.points);
        }
        update(time) {
            const pulse = 1 + Math.sin(time * this.breathSpeed + this.breathPhase) * 0.15;
            this.points.scale.set(pulse, pulse, pulse);
            this.points.rotation.y += 0.0005;
            this.points.rotation.z += 0.0002;
            this.points.material.opacity = 0.8 + Math.sin(time * this.breathSpeed * 2) * 0.2;
        }
        dispose() {
            this.points.geometry.dispose();
            this.points.material.dispose();
            scene.remove(this.points);
        }
    }

    function updateSectors() {
        const cx = Math.round(camera.position.x / SECTOR_SIZE);
        const cy = Math.round(camera.position.y / SECTOR_SIZE);
        const cz = Math.round(camera.position.z / SECTOR_SIZE);
        const activeIds = new Set();

        for (let x = cx - 1; x <= cx + 1; x++) {
            for (let y = cy - 1; y <= cy + 1; y++) {
                for (let z = cz - 1; z <= cz + 1; z++) {
                    const id = `${x},${y},${z}`;
                    activeIds.add(id);
                    if (!sectors.has(id)) sectors.set(id, new GoldenNebula(x, y, z));
                }
            }
        }
        sectors.forEach((s, id) => { if(!activeIds.has(id)) { s.dispose(); sectors.delete(id); } });
        document.getElementById('pos-info').innerText = `${cx}, ${cy}, ${cz}`;
        document.getElementById('part-count').innerText = (sectors.size * PARTICLES_PER_SYSTEM).toLocaleString();
    }

    function onMouseMove(e) {
        if (document.pointerLockElement === renderer.domElement) {
            rotation.y -= e.movementX * 0.0012;
            rotation.x -= e.movementY * 0.0012;
            rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));
            lastUserActionTime = Date.now();
        }
    }

    function onResize() {
        const w = window.innerWidth, h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = (isStereoMode ? w / 2 : w) / h;
        camera.updateProjectionMatrix();
    }

    function handleInput(dt) {
        const moveMult = (keys['Space'] ? 600 : 160) * dt;
        const rotMult = 2.2 * dt;

        const mFwd = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0) - (joyLeft.active ? joyLeft.y : 0);
        const mSide = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0) + (joyLeft.active ? joyLeft.x : 0);
        const mVert = (keys['KeyZ'] ? 1 : 0) - (keys['KeyX'] ? 1 : 0) - (joyRight.active ? joyRight.y : 0);
        const rYaw = (keys['KeyE'] ? 1 : 0) - (keys['KeyQ'] ? 1 : 0) - (joyRight.active ? joyRight.x : 0);

        const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const rgt = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        const upp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

        camera.position.addScaledVector(fwd, mFwd * moveMult);
        camera.position.addScaledVector(rgt, mSide * moveMult);
        camera.position.addScaledVector(upp, mVert * moveMult);
        rotation.y += rYaw * rotMult;
        
        camera.rotation.order = 'YXZ';
        camera.rotation.set(rotation.x, rotation.y, rotation.z);

        if (isTouchDevice) {
            const opacity = Date.now() - lastUserActionTime > 5000 ? '0' : '1';
            document.getElementById('joy-left').style.opacity = opacity;
            document.getElementById('joy-right').style.opacity = opacity;
        }
    }

    function render() {
        const w = window.innerWidth, h = window.innerHeight;
        if (isStereoMode) {
            renderer.setScissorTest(true);
            camera.position.x += eyeSeparation;
            renderer.setScissor(0, 0, w / 2, h);
            renderer.setViewport(0, 0, w / 2, h);
            renderer.render(scene, camera);
            camera.position.x -= eyeSeparation * 2;
            renderer.setScissor(w / 2, 0, w / 2, h);
            renderer.setViewport(w / 2, 0, w / 2, h);
            renderer.render(scene, camera);
            camera.position.x += eyeSeparation;
            renderer.setScissorTest(false);
        } else {
            renderer.setViewport(0, 0, w, h);
            renderer.render(scene, camera);
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        handleInput(dt);
        updateSectors();
        sectors.forEach(s => s.update(clock.getElapsedTime()));
        render();
    }

    window.onload = init;
</script>
</body>
</html>
