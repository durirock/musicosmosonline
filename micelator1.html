<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mycelium Mind - Mapas Mentales 3D</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Fira+Code:wght@300;400&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>

    <style>
        :root {
            --primary-glow: #4DDBFF;
            --secondary-glow: #0077FF;
            --accent-warm: #FF6B4D;
            --accent-green: #4DFF88;
            --accent-purple: #9D4DFF;
            --text-color: #EAEAEA;
            --bg-color: #02040a;
            --glass-bg: rgba(2, 4, 10, 0.85);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Fira Code', monospace;
            cursor: crosshair;
            touch-action: none;
        }

        #webgl-container, #css-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }

        #css-container { pointer-events: none; }
        #css-container > div { pointer-events: auto; }

        #coordinates {
            position: fixed;
            top: 20px; left: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 0.75em;
            z-index: 100;
        }

        #coordinates .coord-label { color: rgba(255, 255, 255, 0.5); }
        #coordinates .coord-value {
            color: var(--primary-glow);
            min-width: 40px;
            display: inline-block;
            text-align: right;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.7);
            z-index: 100;
            text-align: center;
            transition: opacity 0.5s ease;
            max-width: 90%;
        }
        #instructions.hidden { opacity: 0; pointer-events: none; }

        #instructions kbd {
            background: rgba(77, 219, 255, 0.2);
            border: 1px solid var(--primary-glow);
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0 2px;
        }

        #stats-panel {
            position: fixed;
            top: 70px; left: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 12px;
            padding: 15px 20px;
            font-size: 0.8em;
            z-index: 100;
        }

        #stats-panel h3 {
            font-family: 'Cinzel', serif;
            color: var(--primary-glow);
            font-size: 1em;
            margin-bottom: 8px;
            letter-spacing: 2px;
        }

        #stats-panel .stat {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 4px 0;
            color: rgba(255, 255, 255, 0.7);
        }

        #stats-panel .stat-value { color: var(--primary-glow); }

        .action-buttons {
            position: fixed;
            top: 20px; right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .action-btn {
            width: 50px; height: 50px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 12px;
            color: var(--primary-glow);
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            background: rgba(77, 219, 255, 0.2);
            border-color: var(--primary-glow);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(77, 219, 255, 0.3);
        }

        .idea-node {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 2px solid var(--primary-glow);
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 40px;
            max-width: 400px;
            box-shadow: 0 0 20px rgba(77, 219, 255, 0.4);
            cursor: grab;
            transition: box-shadow 0.3s ease, border-color 0.3s ease;
            user-select: none;
            display: inline-block;
        }

        .idea-node:hover { box-shadow: 0 0 35px rgba(77, 219, 255, 0.6); }

        .idea-node.selected {
            border-color: var(--accent-warm);
            box-shadow: 0 0 40px rgba(255, 107, 77, 0.6);
        }

        .idea-node.editing {
            border-color: var(--accent-green);
            box-shadow: 0 0 50px rgba(77, 255, 136, 0.7);
            cursor: text;
        }

        .idea-node.dragging { cursor: grabbing; }

        .idea-node.ghost { 
            opacity: 0.4; 
            border-style: dashed; 
            pointer-events: none;
            background: rgba(77, 219, 255, 0.1);
        }
        
        .idea-node.connection-target {
            border-color: var(--accent-green);
            box-shadow: 0 0 50px rgba(77, 255, 136, 0.7);
            animation: pulse-green 0.5s ease infinite alternate;
        }

        .idea-node.disconnect-target {
            border-color: var(--accent-purple);
            box-shadow: 0 0 50px rgba(157, 77, 255, 0.7);
            animation: pulse-purple 0.5s ease infinite alternate;
        }

        @keyframes pulse-green {
            from { box-shadow: 0 0 30px rgba(77, 255, 136, 0.5); }
            to { box-shadow: 0 0 60px rgba(77, 255, 136, 0.8); }
        }

        @keyframes pulse-purple {
            from { box-shadow: 0 0 30px rgba(157, 77, 255, 0.5); }
            to { box-shadow: 0 0 60px rgba(157, 77, 255, 0.8); }
        }

        .idea-node .node-content {
            font-size: 13px;
            line-height: 1.4;
            color: var(--text-color);
            word-wrap: break-word;
            white-space: pre-wrap;
            outline: none;
        }

        #node-input-modal {
            position: fixed;
            display: none;
            z-index: 500;
            pointer-events: none;
        }
        #node-input-modal.visible { display: block; pointer-events: auto; }

        #node-input-modal .input-wrapper {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 2px solid var(--accent-green);
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 40px; 
            max-width: 400px;
            box-shadow: 0 0 40px rgba(77, 255, 136, 0.5);
            display: inline-block;
        }

        #node-input {
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: 'Fira Code', monospace;
            font-size: 13px;
            line-height: 1.4;
            resize: none;
            outline: none;
            width: auto;
            min-width: 20px;
            max-width: 350px;
            overflow: hidden;
        }

        #connection-mode-indicator {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(77, 255, 136, 0.2);
            border: 1px solid var(--accent-green);
            border-radius: 20px;
            padding: 8px 20px;
            font-size: 0.8em;
            color: var(--accent-green);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease, background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        #connection-mode-indicator.visible { opacity: 1; }
        
        #connection-mode-indicator.disconnect {
            background: rgba(157, 77, 255, 0.2);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
        }

        #edit-mode-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(77, 255, 136, 0.2);
            border: 1px solid var(--accent-green);
            border-radius: 20px;
            padding: 8px 20px;
            font-size: 0.8em;
            color: var(--accent-green);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #edit-mode-indicator.visible { opacity: 1; }

        /* ============ JOYPADS ============ */
        .joypad {
            position: fixed;
            bottom: 30px;
            width: 100px;
            height: 100px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 50%;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.5s ease;
            touch-action: none;
        }
        .joypad.visible {
            opacity: 1;
        }
        .joypad.left {
            left: 30px;
        }
        .joypad.right {
            right: 30px;
        }
        .joypad-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            background: var(--primary-glow);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(77, 219, 255, 0.5);
            transition: transform 0.1s ease;
        }
        .joypad-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
        }
        .joypad-labels span {
            position: absolute;
        }
        .joypad-labels .top { top: 8px; left: 50%; transform: translateX(-50%); }
        .joypad-labels .bottom { bottom: 8px; left: 50%; transform: translateX(-50%); }
        .joypad-labels .left { left: 8px; top: 50%; transform: translateY(-50%); }
        .joypad-labels .right { right: 8px; top: 50%; transform: translateY(-50%); }

        #help-tooltip {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--primary-glow);
            border-radius: 16px;
            padding: 30px 40px;
            max-width: 500px;
            z-index: 600;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #help-tooltip.visible { opacity: 1; pointer-events: auto; }

        #help-tooltip h2 {
            font-family: 'Cinzel', serif;
            color: var(--primary-glow);
            margin-bottom: 20px;
            text-align: center;
        }

        #help-tooltip .help-section { margin: 15px 0; }
        #help-tooltip .help-section h4 { color: var(--accent-green); margin-bottom: 8px; }
        #help-tooltip .help-section p { color: rgba(255, 255, 255, 0.7); font-size: 0.85em; line-height: 1.6; }

        #help-tooltip .close-help {
            position: absolute;
            top: 15px; right: 15px;
            background: none;
            border: none;
            color: var(--primary-glow);
            font-size: 1.5em;
            cursor: pointer;
        }

        @media (min-width: 769px) {
            .joypad { display: none !important; }
        }
    </style>
</head>
<body>
    <div id="webgl-container"></div>
    <div id="css-container"></div>

    <div id="coordinates">
        <span class="coord-label">X:</span><span class="coord-value" id="coord-x">0</span>
        <span class="coord-label">Y:</span><span class="coord-value" id="coord-y">0</span>
        <span class="coord-label">Z:</span><span class="coord-value" id="coord-z">0</span>
    </div>

    <div id="instructions">
        <kbd>Doble click</kbd> crear idea ‚Ä¢ <kbd>Arrastrar sobre otro</kbd> conectar ‚Ä¢ <kbd>Arrastrar al vac√≠o</kbd> mover<br>
        <kbd>W A S D</kbd> moverse ‚Ä¢ <kbd>Q E</kbd> rotar ‚Ä¢ <kbd>Z X</kbd> subir/bajar
    </div>

    <div id="stats-panel">
        <h3>MYCELIUM</h3>
        <div class="stat"><span>Nodos:</span><span class="stat-value" id="node-count">0</span></div>
        <div class="stat"><span>Conexiones:</span><span class="stat-value" id="connection-count">0</span></div>
    </div>

    <div class="action-buttons">
        <button class="action-btn" id="btn-help" title="Ayuda">?</button>
        <button class="action-btn" id="btn-center" title="Centrar vista">‚åñ</button>
        <button class="action-btn" id="btn-save" title="Guardar">üíæ</button>
        <button class="action-btn" id="btn-load" title="Cargar">üìÇ</button>
        <input type="file" id="file-input" accept=".mycelium,.json" style="display: none;">
    </div>

    <div id="node-input-modal">
        <div class="input-wrapper">
            <textarea id="node-input" placeholder="..." rows="1"></textarea>
        </div>
    </div>

    <div id="connection-mode-indicator">
        <span id="indicator-text">üîó Suelta para conectar</span>
    </div>

    <div id="edit-mode-indicator">
        ‚úèÔ∏è Modo edici√≥n - Toca fuera para salir
    </div>

    <!-- JOYPADS -->
    <div class="joypad left" id="joypad-left">
        <div class="joypad-inner" id="joypad-left-inner"></div>
        <div class="joypad-labels">
            <span class="top">‚ñ≤</span>
            <span class="bottom">‚ñº</span>
            <span class="left">‚óÑ</span>
            <span class="right">‚ñ∫</span>
        </div>
    </div>
    <div class="joypad right" id="joypad-right">
        <div class="joypad-inner" id="joypad-right-inner"></div>
        <div class="joypad-labels">
            <span class="top">‚Üë</span>
            <span class="bottom">‚Üì</span>
            <span class="left">‚ü≤</span>
            <span class="right">‚ü≥</span>
        </div>
    </div>

    <div id="help-tooltip">
        <button class="close-help" id="close-help">√ó</button>
        <h2>Mycelium Mind</h2>
        <div class="help-section">
            <h4>üå± Crear Ideas</h4>
            <p>Doble tap donde quieras crear una nota.</p>
        </div>
        <div class="help-section">
            <h4>üîó Conectar / Desconectar</h4>
            <p>Arrastra un nodo sobre otro para conectar.<br>
            <strong style="color:#4DFF88">Verde</strong> = crear conexi√≥n<br>
            <strong style="color:#9D4DFF">Morado</strong> = eliminar conexi√≥n</p>
        </div>
        <div class="help-section">
            <h4>‚ú• Mover Nodos</h4>
            <p>Arrastra un nodo y su√©ltalo en un espacio vac√≠o para cambiarlo de lugar.</p>
        </div>
        <div class="help-section">
            <h4>üéÆ Controles T√°ctiles</h4>
            <p><strong>Joypad izquierdo:</strong> Adelante/Atr√°s/Lados<br>
            <strong>Joypad derecho:</strong> Arriba/Abajo + Rotar<br>
            <strong>Con nodo seleccionado:</strong> Orbita alrededor</p>
        </div>
        <div class="help-section">
            <h4>‚úèÔ∏è Editar</h4>
            <p>Doble tap en nodo para editar.</p>
        </div>
    </div>

    <script>
        const CONFIG = {
            nodeScale: 0.012,
            connectionSegments: 20,
            connectionAmplitude: 0.2,
            cameraSpeed: 0.2,
            rotationSpeed: 0.015,
            mouseSensitivity: 0.002,
            zoomSpeed: 0.015,
            minZoom: 3,
            maxZoom: 100,
            connectionThreshold: 2.5,
            editZoomDistance: 6,
            transitionSpeed: 0.08,
            joypadHideDelay: 5000,
            cameraSmoothing: 0.1,
            creationDistance: 5,
            autoSaveInterval: 5000 // 5 segundos
        };

        let scene, camera, webglRenderer, cssRenderer, clock;
        let avatarObject;
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let draggedNode = null;
        let ghostCSSObject = null;
        let potentialTarget = null;
        let targetAction = null;
        
        // Manejador de archivo para guardado persistente (API moderna)
        let currentFileHandle = null;

        // Nuevo: Plano para arrastrar nodos manteniendo su profundidad
        let dragPlane = new THREE.Plane();

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        let rotateLeft = false, rotateRight = false;

        // Joypad values (-1 to 1)
        let joypadLeftX = 0, joypadLeftY = 0;
        let joypadRightX = 0, joypadRightY = 0;
        let joypadHideTimer = null;

        let yawAngle = 0, pitchAngle = 0;
        let zoomDistance = 15;
        let isCameraDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        let isCreatingNode = false;
        let pendingNodeScreenPosition = null;

        let isEditingNode = false;
        let editingNode = null;

        let isTransitioning = false;
        let transitionTarget = null;
        let transitionCallback = null;

        // √ìrbita
        let orbitCenter = null;
        let orbitDistance = 15;
        let orbitYaw = 0;
        let orbitPitch = 0;

        // Smooth Camera Vectors
        let currentLookAt = new THREE.Vector3();
        
        // Touch
        let lastTapTime = 0;
        let touchStartPos = null;
        let activeTouches = {};

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x02040a, 50, 200);

            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);

            const avatarGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const avatarMaterial = new THREE.MeshBasicMaterial({ visible: false });
            avatarObject = new THREE.Mesh(avatarGeometry, avatarMaterial);
            avatarObject.position.set(0, 0, 0);
            scene.add(avatarObject);
            
            // Inicializar currentLookAt
            currentLookAt.copy(avatarObject.position);

            webglRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            webglRenderer.setClearColor(0x02040a, 1);
            document.getElementById('webgl-container').appendChild(webglRenderer.domElement);

            cssRenderer = new THREE.CSS3DRenderer();
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('css-container').appendChild(cssRenderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);

            createSporeField();
            createStarField(); 
            createReferenceGrid();
            initEventListeners();
            initJoypads();

            // Cargar datos de localStorage si existen
            loadFromLocalStorage();

            // Iniciar ciclo de autoguardado
            setInterval(autoSave, CONFIG.autoSaveInterval);

            setTimeout(() => {
                document.getElementById('instructions').classList.add('hidden');
            }, 8000);

            updateStats();
        }

        // ============ SISTEMA DE GUARDADO ACTUALIZADO ============

        function getMapData() {
            return {
                version: '1.0',
                name: 'Mycelium Mind Map',
                created: new Date().toISOString(),
                nodes: nodes.map(n => ({
                    id: n.id,
                    text: n.text,
                    position: n.position.toArray()
                })),
                connections: connections.map(c => ({
                    nodeA: c.nodeA.id,
                    nodeB: c.nodeB.id
                })),
                camera: {
                    position: avatarObject.position.toArray(),
                    yaw: yawAngle,
                    pitch: pitchAngle,
                    zoom: zoomDistance
                }
            };
        }

        async function autoSave() {
            const data = getMapData();
            
            // 1. Guardar siempre en LocalStorage como backup de sesi√≥n
            localStorage.setItem('mycelium_autosave', JSON.stringify(data));

            // 2. Si hay un archivo cargado v√≠a FileSystem API, guardar silenciosamente
            if (currentFileHandle) {
                try {
                    const writable = await currentFileHandle.createWritable();
                    await writable.write(JSON.stringify(data, null, 2));
                    await writable.close();
                } catch (err) {
                    console.error("Error en autoguardado de archivo:", err);
                    // Si falla por permisos, no avisamos al usuario para no interrumpir, 
                    // simplemente confiamos en el localStorage.
                }
            }
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('mycelium_autosave');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    applyMapData(data);
                } catch (e) {
                    console.error("Error cargando sesi√≥n previa:", e);
                }
            }
        }

        async function saveMap() {
            const data = getMapData();
            
            // Si ya tenemos un archivo abierto, guardamos directamente sobre √©l
            if (currentFileHandle) {
                try {
                    const writable = await currentFileHandle.createWritable();
                    await writable.write(JSON.stringify(data, null, 2));
                    await writable.close();
                    return;
                } catch (err) {
                    console.error("Error al sobreescribir:", err);
                }
            }

            // Si no hay archivo o falla la sobreescritura, probamos la API moderna para elegir ubicaci√≥n
            if (window.showSaveFilePicker) {
                try {
                    currentFileHandle = await window.showSaveFilePicker({
                        suggestedName: 'mi-mapa-mental.mycelium',
                        types: [{
                            description: 'Mycelium Mind File',
                            accept: { 'application/json': ['.mycelium', '.json'] },
                        }],
                    });
                    const writable = await currentFileHandle.createWritable();
                    await writable.write(JSON.stringify(data, null, 2));
                    await writable.close();
                } catch (err) {
                    console.log("Guardado cancelado o fallido:", err);
                    // Fallback al m√©todo tradicional de descarga si el usuario cancela o falla
                    downloadFallback(data);
                }
            } else {
                downloadFallback(data);
            }
        }

        function downloadFallback(data) {
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mapa-' + Date.now() + '.mycelium';
            a.click();
            URL.revokeObjectURL(url);
        }

        async function loadMap(event) {
            // Intentamos usar la API moderna para mantener el v√≠nculo con el archivo
            if (window.showOpenFilePicker) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Mycelium Mind File',
                            accept: { 'application/json': ['.mycelium', '.json'] },
                        }],
                        multiple: false
                    });
                    currentFileHandle = handle;
                    const file = await handle.getFile();
                    const text = await file.text();
                    applyMapData(JSON.parse(text));
                    return;
                } catch (err) {
                    console.log("Carga cancelada:", err);
                }
            }

            // Fallback tradicional si no hay API o cancela
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    applyMapData(JSON.parse(e.target.result));
                } catch (err) {
                    alert('Error al cargar el archivo');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function applyMapData(data) {
            clearAll();
            const nodeMap = {};
            data.nodes.forEach(n => {
                const position = new THREE.Vector3().fromArray(n.position);
                const node = createNode(n.text, position);
                node.id = n.id;
                nodeMap[n.id] = node;
            });
            data.connections.forEach(c => {
                const nodeA = nodeMap[c.nodeA];
                const nodeB = nodeMap[c.nodeB];
                if (nodeA && nodeB) createConnection(nodeA, nodeB);
            });
            if (data.camera) {
                avatarObject.position.fromArray(data.camera.position);
                yawAngle = data.camera.yaw || 0;
                pitchAngle = data.camera.pitch || 0;
                zoomDistance = data.camera.zoom || 15;
            }
        }

        // ============ FIN SISTEMA DE GUARDADO ============

        function createStarField() {
            const starCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const r = 300 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i*3+2] = r * Math.cos(phi);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.6,
                transparent: true,
                opacity: 0.8
            });
            scene.add(new THREE.Points(geometry, material));
        }

        function createSporeField() {
            const sporeCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(sporeCount * 3);
            const colors = new Float32Array(sporeCount * 3);
            for (let i = 0; i < sporeCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 300;
                positions[i3 + 1] = (Math.random() - 0.5) * 300;
                positions[i3 + 2] = (Math.random() - 0.5) * 300;
                const t = Math.random();
                colors[i3] = 0.3 + t * 0.2;
                colors[i3 + 1] = 0.8 + t * 0.2;
                colors[i3 + 2] = 1 - t * 0.4;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({
                size: 0.12,
                vertexColors: true,
                transparent: true,
                opacity: 0.5
            });
            scene.add(new THREE.Points(geometry, material));
        }

        function createReferenceGrid() {
            const gridHelper = new THREE.GridHelper(150, 30, 0x1a3a4a, 0x0a1a2a);
            gridHelper.position.y = -20;
            gridHelper.material.opacity = 0.25;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        function initJoypads() {
            const joypadLeft = document.getElementById('joypad-left');
            const joypadRight = document.getElementById('joypad-right');
            const innerLeft = document.getElementById('joypad-left-inner');
            const innerRight = document.getElementById('joypad-right-inner');
            setupJoypad(joypadLeft, innerLeft, (x, y) => {
                joypadLeftX = x; joypadLeftY = y;
            });
            setupJoypad(joypadRight, innerRight, (x, y) => {
                joypadRightX = x; joypadRightY = y;
            });
        }

        function setupJoypad(container, inner, callback) {
            let isActive = false;
            let startX, startY;
            const maxDistance = 30;
            container.addEventListener('touchstart', (e) => {
                e.preventDefault(); e.stopPropagation();
                isActive = true;
                const touch = e.touches[0];
                const rect = container.getBoundingClientRect();
                startX = rect.left + rect.width / 2;
                startY = rect.top + rect.height / 2;
                showJoypads();
            }, { passive: false });
            container.addEventListener('touchmove', (e) => {
                if (!isActive) return;
                e.preventDefault(); e.stopPropagation();
                const touch = e.touches[0];
                let dx = touch.clientX - startX;
                let dy = touch.clientY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > maxDistance) {
                    dx = (dx / distance) * maxDistance;
                    dy = (dy / distance) * maxDistance;
                }
                inner.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                callback(dx / maxDistance, -dy / maxDistance);
                showJoypads();
            }, { passive: false });
            container.addEventListener('touchend', (e) => {
                isActive = false;
                inner.style.transform = 'translate(-50%, -50%)';
                callback(0, 0);
                scheduleHideJoypads();
            });
        }

        function showJoypads() {
            document.getElementById('joypad-left').classList.add('visible');
            document.getElementById('joypad-right').classList.add('visible');
            if (joypadHideTimer) clearTimeout(joypadHideTimer);
        }

        function scheduleHideJoypads() {
            if (joypadHideTimer) clearTimeout(joypadHideTimer);
            joypadHideTimer = setTimeout(() => {
                document.getElementById('joypad-left').classList.remove('visible');
                document.getElementById('joypad-right').classList.remove('visible');
            }, CONFIG.joypadHideDelay);
        }

        function initEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onMouseWheel);
            document.addEventListener('dblclick', onDoubleClick);
            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('click', onDocumentClick);
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd, { passive: false });
            document.getElementById('btn-help').addEventListener('click', toggleHelp);
            document.getElementById('btn-center').addEventListener('click', centerView);
            document.getElementById('btn-save').addEventListener('click', saveMap);
            document.getElementById('btn-load').addEventListener('click', () => {
                if(window.showOpenFilePicker) { loadMap(); } 
                else { document.getElementById('file-input').click(); }
            });
            document.getElementById('file-input').addEventListener('change', loadMap);
            document.getElementById('close-help').addEventListener('click', toggleHelp);
            const nodeInput = document.getElementById('node-input');
            nodeInput.addEventListener('keydown', onNodeInputKeyDown);
            nodeInput.addEventListener('input', autoResizeInput);
            nodeInput.addEventListener('blur', onNodeInputBlur);
        }

        function onTouchStart(event) {
            if (event.target.closest('.action-btn, #help-tooltip, #stats-panel, #node-input-modal, #coordinates, .joypad')) return;
            if (isEditingNode) return;
            const touch = event.touches[0];
            touchStartPos = { x: touch.clientX, y: touch.clientY };
            updateMouseFromTouch(touch);
            const now = Date.now();
            if (now - lastTapTime < 300) {
                onDoubleTap(touch);
                lastTapTime = 0;
                return;
            }
            lastTapTime = now;
            const hit = raycastNodes();
            if (hit) {
                selectNode(hit.node);
                startDraggingNode(hit.node);
            } else {
                isCameraDragging = true;
            }
            event.preventDefault();
        }

        function onTouchMove(event) {
            if (event.target.closest('.joypad')) return;
            const touch = event.touches[0];
            updateMouseFromTouch(touch);
            if (draggedNode) {
                updateGhostPosition({ clientX: touch.clientX, clientY: touch.clientY });
                checkConnectionTarget();
            } else if (isCameraDragging && touchStartPos) {
                const deltaX = touch.clientX - touchStartPos.x;
                const deltaY = touch.clientY - touchStartPos.y;
                yawAngle -= deltaX * CONFIG.mouseSensitivity * 0.5;
                pitchAngle -= deltaY * CONFIG.mouseSensitivity * 0.5;
                pitchAngle = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitchAngle));
                touchStartPos = { x: touch.clientX, y: touch.clientY };
            }
            event.preventDefault();
        }

        function onTouchEnd() {
            if (draggedNode) finishDraggingNode();
            isCameraDragging = false;
            touchStartPos = null;
        }

        function onDoubleTap(touch) {
            updateMouseFromTouch(touch);
            const hit = raycastNodes();
            if (hit) {
                enterEditMode(hit.node);
                return;
            }
            pendingNodeScreenPosition = { x: touch.clientX, y: touch.clientY };
            showNodeInput(touch.clientX, touch.clientY);
        }

        function updateMouseFromTouch(touch) {
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        }

        function onDocumentClick(event) {
            const helpTooltip = document.getElementById('help-tooltip');
            if (helpTooltip.classList.contains('visible')) {
                if (!event.target.closest('#help-tooltip') && !event.target.closest('#btn-help')) {
                    helpTooltip.classList.remove('visible');
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (isEditingNode) {
                if (event.key === 'Escape') exitEditMode();
                return;
            }
            if (isCreatingNode) return;
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyZ': moveUp = true; break;
                case 'KeyX': moveDown = true; break;
                case 'KeyQ': rotateLeft = true; break;
                case 'KeyE': rotateRight = true; break;
                case 'Delete':
                case 'Backspace':
                    if (selectedNode && !isCreatingNode && !isEditingNode) {
                        event.preventDefault(); deleteNode(selectedNode);
                    }
                    break;
                case 'Escape':
                    cancelNodeCreation(); deselectNode();
                    document.getElementById('help-tooltip').classList.remove('visible');
                    break;
            }
        }

        function onKeyUp(event) {
            if (isEditingNode) return;
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyZ': moveUp = false; break;
                case 'KeyX': moveDown = false; break;
                case 'KeyQ': rotateLeft = false; break;
                case 'KeyE': rotateRight = false; break;
            }
        }

        function onMouseDown(event) {
            if (event.target.closest('.action-btn, #help-tooltip, #stats-panel, #node-input-modal, #coordinates')) return;
            if (isEditingNode) return;
            updateMouse(event);
            if (event.button === 0) {
                const hit = raycastNodes();
                if (hit) {
                    selectNode(hit.node); startDraggingNode(hit.node);
                } else {
                    deselectNode(); isCameraDragging = true;
                }
            } else if (event.button === 2) {
                isCameraDragging = true;
            }
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp() {
            if (draggedNode) finishDraggingNode();
            isCameraDragging = false;
        }

        function onMouseMove(event) {
            updateMouse(event);
            if (draggedNode) {
                updateGhostPosition(event); checkConnectionTarget();
            } else if (isCameraDragging && !isEditingNode) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                yawAngle -= deltaX * CONFIG.mouseSensitivity;
                pitchAngle -= deltaY * CONFIG.mouseSensitivity;
                pitchAngle = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitchAngle));
            }
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseWheel(event) {
            if (selectedNode && orbitCenter) {
                orbitDistance += event.deltaY * CONFIG.zoomSpeed;
                orbitDistance = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, orbitDistance));
            } else {
                zoomDistance += event.deltaY * CONFIG.zoomSpeed;
                zoomDistance = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, zoomDistance));
            }
        }

        function onDoubleClick(event) {
            if (event.target.closest('.action-btn, #help-tooltip, #stats-panel, #coordinates, #node-input-modal')) return;
            if (isCreatingNode || isEditingNode) return;
            updateMouse(event);
            const hit = raycastNodes();
            if (hit) {
                enterEditMode(hit.node);
                return;
            }
            pendingNodeScreenPosition = { x: event.clientX, y: event.clientY };
            showNodeInput(event.clientX, event.clientY);
        }

        function updateMouse(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function raycastNodes() {
            raycaster.setFromCamera(mouse, camera);
            const proxyObjects = nodes.map(n => n.proxyObject).filter(Boolean);
            const intersects = raycaster.intersectObjects(proxyObjects);
            if (intersects.length > 0) {
                const proxy = intersects[0].object;
                const node = nodes.find(n => n.proxyObject === proxy);
                return { node, intersection: intersects[0] };
            }
            return null;
        }

        function screenToWorld(screenX, screenY) {
            const ndcX = (screenX / window.innerWidth) * 2 - 1;
            const ndcY = -(screenY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera({ x: ndcX, y: ndcY }, camera);
            const distance = CONFIG.creationDistance; 
            return raycaster.ray.at(distance, new THREE.Vector3());
        }

        function createNode(text, position) {
            const id = 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const div = document.createElement('div');
            div.className = 'idea-node';
            div.dataset.nodeId = id;
            const content = document.createElement('div');
            content.className = 'node-content';
            content.textContent = text;
            div.appendChild(content);
            const cssObject = new THREE.CSS3DObject(div);
            cssObject.scale.set(CONFIG.nodeScale, CONFIG.nodeScale, CONFIG.nodeScale);
            cssObject.position.copy(position);
            const textLength = text.length;
            const proxyWidth = Math.max(60, Math.min(300, textLength * 7)) * CONFIG.nodeScale;
            const proxyHeight = Math.max(30, Math.ceil(textLength / 35) * 22) * CONFIG.nodeScale;
            const proxyGeometry = new THREE.PlaneGeometry(proxyWidth, proxyHeight);
            const proxyMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide });
            const proxyObject = new THREE.Mesh(proxyGeometry, proxyMaterial);
            proxyObject.position.copy(position);
            scene.add(cssObject);
            scene.add(proxyObject);
            const node = { id, text, position: position.clone(), cssObject, proxyObject, element: div, connections: [] };
            nodes.push(node);
            updateStats();
            return node;
        }

        function selectNode(node) {
            if (selectedNode) selectedNode.element.classList.remove('selected');
            selectedNode = node;
            node.element.classList.add('selected');
            orbitCenter = null; 
        }

        function deselectNode() {
            if (selectedNode) selectedNode.element.classList.remove('selected');
            selectedNode = null;
            orbitCenter = null;
        }

        function deleteNode(node) {
            const connectionsToRemove = connections.filter(c => c.nodeA === node || c.nodeB === node);
            connectionsToRemove.forEach(c => {
                scene.remove(c.line);
                const idx = connections.indexOf(c);
                if (idx > -1) connections.splice(idx, 1);
                const idxA = c.nodeA.connections.indexOf(c);
                if (idxA > -1) c.nodeA.connections.splice(idxA, 1);
                const idxB = c.nodeB.connections.indexOf(c);
                if (idxB > -1) c.nodeB.connections.splice(idxB, 1);
            });
            scene.remove(node.cssObject);
            scene.remove(node.proxyObject);
            const idx = nodes.indexOf(node);
            if (idx > -1) nodes.splice(idx, 1);
            if (selectedNode === node) deselectNode();
            if (editingNode === node) exitEditMode();
            updateStats();
        }

        function enterEditMode(node) {
            isEditingNode = true; editingNode = node;
            selectNode(node);
            node.element.classList.add('editing');
            document.getElementById('edit-mode-indicator').classList.add('visible');
            const distanceToNode = camera.position.distanceTo(node.position);
            if (distanceToNode > CONFIG.editZoomDistance + 2) {
                transitionToNode(node, () => startEditing(node));
            } else {
                startEditing(node);
            }
        }

        function transitionToNode(node, callback) {
            isTransitioning = true;
            transitionTarget = { position: node.position.clone(), distance: CONFIG.editZoomDistance };
            transitionCallback = callback;
        }

        function syncAvatarWithCamera() {
            avatarObject.position.copy(camera.position);
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            yawAngle = Math.atan2(-direction.x, -direction.z);
            pitchAngle = Math.asin(direction.y);
            const standardDist = 10;
            const forward = direction.clone().multiplyScalar(standardDist);
            avatarObject.position.add(forward);
            zoomDistance = standardDist;
        }

        function startEditing(node) {
            const content = node.element.querySelector('.node-content');
            content.contentEditable = true; content.focus();
            const range = document.createRange();
            range.selectNodeContents(content);
            const selection = window.getSelection();
            selection.removeAllRanges(); selection.addRange(range);
            content.addEventListener('blur', onEditBlur);
            content.addEventListener('keydown', onEditKeyDown);
        }

        function onEditBlur() {
            setTimeout(() => { if (isEditingNode && editingNode) exitEditMode(); }, 100);
        }

        function onEditKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); exitEditMode(); }
            if (event.key === 'Escape') exitEditMode();
            event.stopPropagation();
        }

        function exitEditMode() {
            if (!editingNode) return;
            const content = editingNode.element.querySelector('.node-content');
            content.contentEditable = false;
            content.removeEventListener('blur', onEditBlur);
            content.removeEventListener('keydown', onEditKeyDown);
            editingNode.text = content.textContent;
            updateNodeProxy(editingNode);
            editingNode.element.classList.remove('editing');
            document.getElementById('edit-mode-indicator').classList.remove('visible');
            isEditingNode = false; editingNode = null;
        }

        function updateNodeProxy(node) {
            const textLength = node.text.length;
            const proxyWidth = Math.max(60, Math.min(300, textLength * 7)) * CONFIG.nodeScale;
            const proxyHeight = Math.max(30, Math.ceil(textLength / 35) * 22) * CONFIG.nodeScale;
            node.proxyObject.geometry.dispose();
            node.proxyObject.geometry = new THREE.PlaneGeometry(proxyWidth, proxyHeight);
        }

        function startDraggingNode(node) {
            draggedNode = node;
            node.element.classList.add('dragging');
            const normal = new THREE.Vector3();
            camera.getWorldDirection(normal);
            dragPlane.setFromNormalAndCoplanarPoint(normal, node.position);
            createGhostNode(node);
            const indicator = document.getElementById('connection-mode-indicator');
            indicator.classList.add('visible'); indicator.classList.remove('disconnect');
            document.getElementById('indicator-text').textContent = 'üîó Arrastra sobre otro / ‚ú• Suelta para mover';
        }

        function createGhostNode(node) {
            const ghostDiv = document.createElement('div');
            ghostDiv.className = 'idea-node ghost';
            ghostDiv.innerHTML = node.element.innerHTML;
            ghostCSSObject = new THREE.CSS3DObject(ghostDiv);
            ghostCSSObject.scale.copy(node.cssObject.scale);
            ghostCSSObject.position.copy(node.cssObject.position);
            scene.add(ghostCSSObject);
        }

        function updateGhostPosition(event) {
            if (!ghostCSSObject || !draggedNode) return;
            const ndcX = (event.clientX / window.innerWidth) * 2 - 1;
            const ndcY = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera({ x: ndcX, y: ndcY }, camera);
            const intersection = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                ghostCSSObject.position.copy(intersection);
            }
        }

        function checkConnectionTarget() {
            if (!draggedNode) return;
            if (potentialTarget) potentialTarget.element.classList.remove('connection-target', 'disconnect-target');
            potentialTarget = null; targetAction = null;
            const indicator = document.getElementById('connection-mode-indicator');
            indicator.classList.remove('disconnect');
            const hit = raycastNodes();
            if (hit && hit.node !== draggedNode) {
                const targetNode = hit.node;
                const existingConnection = connections.find(c => (c.nodeA === draggedNode && c.nodeB === targetNode) || (c.nodeA === targetNode && c.nodeB === draggedNode));
                potentialTarget = targetNode;
                if (existingConnection) {
                    targetAction = 'disconnect'; targetNode.element.classList.add('disconnect-target');
                    indicator.classList.add('disconnect');
                    document.getElementById('indicator-text').textContent = '‚úÇÔ∏è Suelta para DESCONECTAR';
                } else {
                    targetAction = 'connect'; targetNode.element.classList.add('connection-target');
                    document.getElementById('indicator-text').textContent = 'üîó Suelta para CONECTAR';
                }
            } else {
                document.getElementById('indicator-text').textContent = '‚ú• Suelta para MOVER';
            }
        }

        function finishDraggingNode() {
            if (!draggedNode) return;
            draggedNode.element.classList.remove('dragging');
            if (potentialTarget && targetAction) {
                if (targetAction === 'connect') createConnection(draggedNode, potentialTarget);
                else if (targetAction === 'disconnect') removeConnection(draggedNode, potentialTarget);
                potentialTarget.element.classList.remove('connection-target', 'disconnect-target');
            } else if (ghostCSSObject) {
                const newPos = ghostCSSObject.position.clone();
                draggedNode.position.copy(newPos);
                draggedNode.cssObject.position.copy(newPos);
                draggedNode.proxyObject.position.copy(newPos);
                updateNodeConnections(draggedNode);
            }
            if (ghostCSSObject) { scene.remove(ghostCSSObject); ghostCSSObject = null; }
            potentialTarget = null; targetAction = null; draggedNode = null;
            document.getElementById('connection-mode-indicator').classList.remove('visible', 'disconnect');
        }

        function createConnection(nodeA, nodeB) {
            const existing = connections.find(c => (c.nodeA === nodeA && c.nodeB === nodeB) || (c.nodeA === nodeB && c.nodeB === nodeA));
            if (existing) return;
            const curve = new THREE.CatmullRomCurve3(generateCurvePoints(nodeA.position, nodeB.position));
            const geometry = new THREE.TubeGeometry(curve, CONFIG.connectionSegments, 0.02, 6, false);
            const material = new THREE.MeshBasicMaterial({ color: 0x4DDBFF, transparent: true, opacity: 0.6 });
            const line = new THREE.Mesh(geometry, material);
            scene.add(line);
            const connection = { id: 'conn_' + Date.now(), nodeA, nodeB, line, curve, phase: Math.random() * Math.PI * 2 };
            connections.push(connection);
            nodeA.connections.push(connection); nodeB.connections.push(connection);
            updateStats();
            return connection;
        }

        function removeConnection(nodeA, nodeB) {
            const connection = connections.find(c => (c.nodeA === nodeA && c.nodeB === nodeB) || (c.nodeA === nodeB && c.nodeB === nodeA));
            if (!connection) return;
            scene.remove(connection.line);
            const idx = connections.indexOf(connection);
            if (idx > -1) connections.splice(idx, 1);
            const idxA = nodeA.connections.indexOf(connection);
            if (idxA > -1) nodeA.connections.splice(idxA, 1);
            const idxB = nodeB.connections.indexOf(connection);
            if (idxB > -1) nodeB.connections.splice(idxB, 1);
            updateStats();
        }

        function updateNodeConnections(node) {
            node.connections.forEach(conn => {
                scene.remove(conn.line);
                conn.line.geometry.dispose();
                conn.curve = new THREE.CatmullRomCurve3(generateCurvePoints(conn.nodeA.position, conn.nodeB.position));
                conn.line.geometry = new THREE.TubeGeometry(conn.curve, CONFIG.connectionSegments, 0.02, 6, false);
                scene.add(conn.line);
            });
        }

        function generateCurvePoints(start, end) {
            const points = [];
            const perpendicular = new THREE.Vector3().subVectors(end, start).cross(new THREE.Vector3(0, 1, 0)).normalize();
            const distance = start.distanceTo(end);
            const amplitude = CONFIG.connectionAmplitude * distance;
            points.push(start.clone());
            for (let i = 1; i < 4; i++) {
                const t = i / 4;
                const point = new THREE.Vector3().lerpVectors(start, end, t);
                const wave = Math.sin(t * Math.PI) * amplitude;
                const noise = (Math.random() - 0.5) * amplitude * 0.2;
                point.add(perpendicular.clone().multiplyScalar(wave + noise));
                point.y += Math.sin(t * Math.PI * 2) * amplitude * 0.2;
                points.push(point);
            }
            points.push(end.clone());
            return points;
        }

        function animateConnections(time) {
            connections.forEach(connection => {
                const pulse = Math.sin(time * 2 + connection.phase) * 0.15 + 0.6;
                connection.line.material.opacity = pulse;
            });
        }

        function showNodeInput(screenX, screenY) {
            isCreatingNode = true;
            const modal = document.getElementById('node-input-modal');
            const input = document.getElementById('node-input');
            modal.style.left = screenX + 'px'; modal.style.top = screenY + 'px';
            modal.classList.add('visible');
            input.value = ''; input.style.width = '20px'; input.style.height = 'auto';
            setTimeout(() => input.focus(), 10);
        }

        function autoResizeInput() {
            const input = document.getElementById('node-input');
            input.style.height = 'auto'; input.style.width = 'auto';
            const textWidth = Math.max(20, Math.min(350, input.scrollWidth + 5));
            input.style.width = textWidth + 'px'; input.style.height = input.scrollHeight + 'px';
        }

        function onNodeInputKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); confirmNodeCreation(); }
            if (event.key === 'Escape') cancelNodeCreation();
            event.stopPropagation();
        }

        function onNodeInputBlur() {
            const input = document.getElementById('node-input');
            if (input.value.trim()) confirmNodeCreation();
            else cancelNodeCreation();
        }

        function confirmNodeCreation() {
            const input = document.getElementById('node-input');
            const text = input.value.trim();
            if (text && pendingNodeScreenPosition) {
                const worldPos = screenToWorld(pendingNodeScreenPosition.x, pendingNodeScreenPosition.y);
                createNode(text, worldPos);
            }
            cancelNodeCreation();
        }

        function cancelNodeCreation() {
            isCreatingNode = false; pendingNodeScreenPosition = null;
            document.getElementById('node-input-modal').classList.remove('visible');
        }

        function updateStats() {
            document.getElementById('node-count').textContent = nodes.length;
            document.getElementById('connection-count').textContent = connections.length;
        }

        function updateCoordinates() {
            document.getElementById('coord-x').textContent = Math.round(avatarObject.position.x);
            document.getElementById('coord-y').textContent = Math.round(avatarObject.position.y);
            document.getElementById('coord-z').textContent = Math.round(avatarObject.position.z);
        }

        function toggleHelp() { document.getElementById('help-tooltip').classList.toggle('visible'); }

        function centerView() {
            if (nodes.length === 0) { avatarObject.position.set(0, 0, 0); return; }
            const center = new THREE.Vector3();
            nodes.forEach(n => center.add(n.position));
            center.divideScalar(nodes.length);
            avatarObject.position.copy(center);
            orbitCenter = null; deselectNode();
        }

        function clearAll() {
            connections.forEach(c => scene.remove(c.line)); connections = [];
            nodes.forEach(n => { scene.remove(n.cssObject); scene.remove(n.proxyObject); });
            nodes = []; selectedNode = null; orbitCenter = null;
            updateStats();
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            if (isTransitioning && transitionTarget) {
                const targetPos = transitionTarget.position.clone();
                const dir = new THREE.Vector3().subVectors(camera.position, targetPos).normalize();
                const targetCamPos = targetPos.clone().add(dir.multiplyScalar(transitionTarget.distance));
                camera.position.lerp(targetCamPos, CONFIG.transitionSpeed);
                const targetLookAt = transitionTarget.position.clone();
                currentLookAt.lerp(targetLookAt, CONFIG.transitionSpeed);
                camera.lookAt(currentLookAt);
                if (camera.position.distanceTo(targetCamPos) < 0.1) {
                    isTransitioning = false; syncAvatarWithCamera();
                    if (transitionCallback) { transitionCallback(); transitionCallback = null; }
                }
            } else if (!isEditingNode) {
                updateMovement(delta); updateCamera(); 
            }
            updateCoordinates();
            nodes.forEach(node => { node.cssObject.lookAt(camera.position); node.proxyObject.lookAt(camera.position); });
            if (ghostCSSObject) ghostCSSObject.lookAt(camera.position);
            animateConnections(time);
            webglRenderer.render(scene, camera);
            cssRenderer.render(scene, camera);
        }

        function updateMovement(delta) {
            const speed = CONFIG.cameraSpeed;
            const inputForward = (moveForward ? 1 : 0) - (moveBackward ? 1 : 0) + joypadLeftY;
            const inputStrafe = (moveRight ? 1 : 0) - (moveLeft ? 1 : 0) + joypadLeftX;
            const inputUp = (moveUp ? 1 : 0) - (moveDown ? 1 : 0) + joypadRightY;
            const inputRotate = (rotateRight ? 1 : 0) - (rotateLeft ? 1 : 0) - joypadRightX;
            yawAngle -= inputRotate * CONFIG.rotationSpeed; 
            const direction = new THREE.Vector3(-Math.sin(yawAngle), 0, -Math.cos(yawAngle));
            const right = new THREE.Vector3(-Math.sin(yawAngle - Math.PI / 2), 0, -Math.cos(yawAngle - Math.PI / 2));
            if (Math.abs(inputForward) > 0.1) avatarObject.position.addScaledVector(direction, inputForward * speed);
            if (Math.abs(inputStrafe) > 0.1) avatarObject.position.addScaledVector(right, inputStrafe * speed);
            if (Math.abs(inputUp) > 0.1) avatarObject.position.y += inputUp * speed;
        }

        function updateCamera() {
            const quaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
            const offset = new THREE.Vector3(0, 0, zoomDistance);
            offset.applyQuaternion(quaternion);
            const targetPosition = new THREE.Vector3().copy(avatarObject.position).add(offset);
            camera.position.lerp(targetPosition, CONFIG.cameraSmoothing);
            currentLookAt.lerp(avatarObject.position, CONFIG.cameraSmoothing);
            camera.lookAt(currentLookAt);
        }
    </script>
</body>
</html>
